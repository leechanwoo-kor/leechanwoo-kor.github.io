---
title: "[Operating System] Memory Management"
categories:
  - Operating System
tags:
  - Memory Management
toc: true
toc_sticky: true
toc_label: "Memory Management"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/222906118-9c24d371-e8b0-44e2-b765-ab3aa0f3a94e.png)

<br>

# Memory Management

## Background

- Types of memories in computer systems
  - Processor registers
  - Cache memory
  - **Main memory**
  - **Auxiliary memory (보조기억장치)**
- Notes
  - Block
    - Data transfer unit between primary memory and secondary storage
    - Size: 1 ~ 4 KB (128B ~ 8MB)
  - Word
    - Data transfer unit between primary memory and CPU
    - Size: 16 ~ 64 bits

<br>

<img width="820" alt="image" src="https://user-images.githubusercontent.com/55765292/231419858-ce494cff-ef51-462e-bb18-46f29135ffe3.png">{: .align-center}

<br>

- Cache
  - CPU register access time
    - Generally takes 0~1 cycles of the CPU clock
  - Memory access time
    - Generally takes 50~200 cycles of the CPU clock
    - CPU normally needs to stall during the memory access
    - Intolerable because of the frequency of memory accesses
  - Cache memory
    - Used to accommodate the speed differentia
  - Intel Core i7 cache :

<img width="476" alt="image" src="https://user-images.githubusercontent.com/55765292/231422203-f9dbb8a3-59c6-4746-863a-80c8fce10549.png">{: .align-center}

<br>

- CPU-memory performance gap

<img width="864" alt="image" src="https://user-images.githubusercontent.com/55765292/231422999-f885893b-f47f-4669-b4e8-b3e240934542.png">{: .align-center}

<br>

### Address binding

<img width="864" alt="image" src="https://user-images.githubusercontent.com/55765292/231423473-63d868e9-01bf-475d-b4bc-bc3c35865b63.png">{: .align-center}

<br>

- Compile-time binding
  - When it is known at compile time where the process will reside in memory, then **absolute code** can be generated
  - Changing the starting location requires recompilation
  - MS-DOS .COM-format programs

<br>

<img width="643" alt="image" src="https://user-images.githubusercontent.com/55765292/231425716-04f938a7-d508-47e0-83c4-c92d3b893055.png">{: .align-center}

<br>

- Load-time binding
  - When it is not known at compile time where the process will reside in memory, then the compiler must generate **relocatable code**
  - Final binding is delayed until load time
  - Changing the starting location requires reloading or **relocation** of the user code

<br>

<img width="959" alt="image" src="https://user-images.githubusercontent.com/55765292/231426284-d44827b7-02e7-4c4e-a692-e2ebbaa2ab53.png">{: .align-center}

<br>

- Run-time binding
  - Processes can be moved during its execution from one memory location to another
  - Special hardware is required
  - Used in most general-purpose operating systems
  - Run-time mapping from logical(virtual) address to physical address is performed by a hardware device called MMU(Memory Management Unit)

<br>

<img width="936" alt="image" src="https://user-images.githubusercontent.com/55765292/231427557-6c1a0142-d4c0-42b7-8e2b-41c705253453.png">{: .align-center}

<br>

- Notes
  - Logical address (relative address, virtual address)
    - An address generated by the CPU
  - Physical address
    - An address seen by the memory unit
    - An address loaded into MAR
  - Relocation register (base register)
    - Holds the allocation address (smallest physical address)
  - Limit register
   - Contains the range of logical addresses

<br>

### Dynamic linking

- **Linking is postponed until execution time**
- Usually used with system libraries
  - Without this facility, each executable on a system must include a copy of its library
    - Wastes both disk space and main memory

- Uses **stub* concept
  - Included in the image for each library routine reference
  - Small piece of code that indicates how to locate or load the appropriate library routine (in memory or from the library)
  - Replaces itself with the code that contains the address of the routine and executes the routine
    - At the next time that the code segment is reached, the library routine is executed directly without further dynamic linking

<br>

- Code sharing
  - All processes that use a library execute only one copy of the library code
- Supports the concept of shared libraries
- Requires help from the OS

<br>

### Overlay structure

- Keep in memory only those instructions and data that are needed at any given time
- Example) Assembler
  - Symbol table(1MB), Common routines(2MB), Pass-1(3MB), Pass-2(4MB)
  - Primary memory size: 8MB


<br>

<img width="610" alt="image" src="https://user-images.githubusercontent.com/55765292/231429144-6ada32c6-1064-45b4-982f-c2eeb0c83599.png">{: .align-center}

<br>

### Swapping

- A process can be swapped temporarily out of memory to a **backing store (swap device(swap file system))** 

<br>

<img width="926" alt="image" src="https://user-images.githubusercontent.com/55765292/231429701-403afede-aa40-4535-b284-968d62e11423.png">{: .align-center}

<br>

**Notes on swapping**
- Time quantum vs swap time
  - Time quantum should be substantially larger than swap time (context switch time) for efficient CPU utilization
- Pending I/O
  - If I/O is asynchronously accessing the user memory for I/O buffers, then the process cannot be swapped
  - Solutions
    - Never swap a process with pending I/O
    - Execute I/O operations only into kernel buffers (and deliver it to the process memory when the process is swapped in)

<br>

- Swap device (swap file system)
  - Swap space is allocated as a chunk of disk
    - Contiguous allocation of the process image
    - Fast access time

<br>

**Ordinary file system** <br>
Discontiguous allocation of the file data blocks <br>
Focuses on the efficient file system space management
{: .notice--warning}

<br>

### Memory Management

<img width="967" alt="image" src="https://user-images.githubusercontent.com/55765292/231431474-5d7497e8-1ac4-4c8a-8218-f67b1fd47c0f.png">{: .align-center}

<br>

## Contiguous Memory Allocation

- Basic policies
  - Each process (context) is contained in a single contiguous section of memory
- Policies for memory organization
  - Number of processes in memory
    - Affects multiprogramming degree
  - Amount of memory space allocated for each process
  - Memory partition methods
    - Fixed(static) partition multiprogramming
    - Variable(dynamic) partition multiprogramming

<br>

### Uniprogramming

- Only 1 process in memory
- Simple memory management scheme

<img width="857" alt="image" src="https://user-images.githubusercontent.com/55765292/231433288-da400d68-dcd4-4743-982e-3ac33258a0d5.png">{: .align-center}

<br>

- Issue-1
  - Program-size > memory-size
    - Uses **overlay structure**
    - Requires support from compiler/linker/loader

<img width="857" alt="image" src="https://user-images.githubusercontent.com/55765292/231433611-38d5639c-7980-44de-ae01-2a488108eb0c.png">{: .align-center}

<br>

- Issue-2
  - Kernel protection
    - Boundary register

<img width="857" alt="image" src="https://user-images.githubusercontent.com/55765292/231433709-16942ffb-232c-47db-ad0f-6c948c074c2d.png">{: .align-center}

<br>

- Issue-3
  - Low system resource utilization
  - Low system performance
  - Solution
    - Multiprogramming → FPM or VPM

<br> 
