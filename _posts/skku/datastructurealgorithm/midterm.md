# 1. 다음의 알고리즘 SAMPLE을 참조하라

```
SAMPLE(int n)
  int sum = 0;                          --- ①
  for (i = n; i > 0; i = i/2) do        --- ②
    for (j = 0; j < n; j = j + 1) do    --- ③
      sum = sum + 1                     --- ④
  return(sum)                           --- ⑤
```

## (1) 위의 각 괄호와 일치하는 왼쪽의 명령어들이 총 몇 번 수행하는지 모두 채워라.
- ① : 1번
- ② : $\log_2n$번
- ③ : n번
- ④ : $n \cdot log_2n$
- ⑤ : 1번

## (2) 위 알고리즘의 Worst Case의 시간 성능을 Big Oh 표기로 나타내라.
- $O(n \cdot log_2n)$



# 2. 다음의 알고리즘 SAMPLE을 참조하라. 여기서 X와 Y는 각각 n개의 정수들을 저장하는 array이다.

```
SAMPLE(int (X[n]))
  for (i = 0; i <= n-1; i = i+1) do
    {
      sum = X[0]
      for (j = 0; j <= l; j = j+1) do
        sum = sum + X[j]
      Y[i] = sum / (l + 1)
    }
  return Y
```

## (1) X[8]에 다음 값이 있다고 할 때, 수행 후 Y[8]에 어떤 값들이 return 되는지 보여라

||0|1|2|3|4|5|6|7|
|---|---|---|---|---|---|---|---|---|
|x[8]|30|28|17|37|48|20|30|62|

Y[8] = (30+28+17+37+48+20+30+62)/9

## (2) 위의 알고리즘의 수행시간은 $O(n^2)$이다. 불필요한 연산을 소거하여 $O(n)$이 되도록 위와 동등한 알고리즘으로 작성하라.

```
SAMPLE(int (X[n]))
  sum = X[0]
  for (j = 0; j <= l; j = j+1) do
    sum = sum + X[j]
  for (i = 0; i <= n-1; i = i+1) do
    Y[i] = sum / (l + 1)
  return Y
```



# 3. 

## (1) 다음은 10진수 n을 2진수로 변환하는 알고리즘이다. 괄호 ①과 ②에 올바른 연산을 채워 완성하라.

```
CONVERT(int n)
  if n == 0
    return 0;
  else {
    CONVERT( ① )
    return ( ② )
  }
```

- ① : n / 2
- ② : CONVERT(n/2) * 10 + (n % 2)


## (2) 다음은 정수 n이 소수(prime number)이면 true를, 아니면 false를 return하는 알고리즘이다. 이 알고리즘의 시간 성능이 O(Root(n))이 되도록, 괄호 ①과 ②를 올바른 연산을 채워 완성하라.

```
TEST(int n)
for (i = 2; ( ① ) <= n; i++)
  if ( ② ) == 0
    return false
  else
    return true;
```

- ① : i * i
- ② : n % 1



# 4. 다음은 Circular Queue의 Insert와 Delete 연산을 작성한 알고리즘이다.

```
max = 3; int queue[3];
int rear = 0; int front = 0;

INSERT(int X)
  { rear = (rear + 1) MOD max
    if (front == rear)
      {
        print(“Sorry, queue is full”)
        ( ① )
      }
    print("OK, X is added”)
    queue[rear] = X
  }

DELETE
  { if ( ② ) print(“Sorry, queue is empty”)
    front = (front + 1) MOD max
    print(“OK, X is deleted”)
    X = queue[front]
  }
```

## 1) 위의 알고리즘의 괄호 ①, ② 안에 들어 갈 명령어를 각각 작성하라.
- ① : rear = (rear - 1 + max) MOD max;
- ② : front == rear

## 2) 이제 아래와 같은 순서로 호출했다고 할 때, 출력되는 메시지를 차례대로 적어라.
1) INSERT(20); 2) INSERT(30); 3) INSERT(40); 4) INSERT(50); 5) DELETE; 6) INSERT(60); 7) DELETE; 8) DELETE; 9) DELETE

- OK, X is added 20
- OK, X is added 20 30
- OK, X is added 20 30 40
- Sorry, queue is full
- OK, X is deleted 30 40
- OK, X is added 30 40 60
- OK, X is deleted 40 60
- OK, X is deleted 60
- OK, X is deleted -



# 5. 다음의 15 개의 key들에 대해 Binary Search를 적용했을 때 3 번 이하의 비교로 찾을 수 있는 key들을 모두 적어라.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15



# 6. 어떤 Binary Search Tree에 1부터 1000까지의 정수들이 저장되었다고 하자. 이제 363 이란 값을 탐색한다고 할 때, 다음 문항들 중 올바르지 않은 탐색 순서들에 해당하는 것을 찾아서 모두 적어라. 단 여러 개의 답안도 가능함.

- 1) 2, 252, 401, 398, 330, 344, 397, 363. (X)
- 2) 924, 220, 911, 244, 898, 258, 362, 363. (X)
- 3) 925, 202, 911, 240, 912, 245, 363. (O)
- 4) 2, 399, 387, 219, 266, 382, 381, 278, 363. (O)
- 5) 935, 278, 347, 621, 299, 392, 358, 363. (X)



# 7. 다음의 후위 표현(Postfix)을 계산하는 과정을 단계별로 보여라. 여기서 %는 나머지 연산자이고, eos는 이 표현의 맨 끝을 나타내는 특수 심볼이다.

3 5 + 4 * 8 – 8 2 / 5 3 % + – eos

- [3]
- [3, 5]
- [3, 5, +] => [8]
- [8, 4]
- [8, 4, \*] => [32]
- [32, 8]
- [32, 8, -] => [24]
- [24, 8]
- [24, 8, 2]
- [24, 8, 2, /] => [24, 4]
- [24, 4, 5]
- [24, 4, 5, 3]
- [24, 4, 5, 3, %] => [24, 4, 2]
- [24, 4, 2, +] => [24, 6]
- [24, 6, -] => [18]



# 8.

## (1) 높이가 h인 Complete Binary Tree에서 node의 최소 개수와 최대 개수를 계산하여 각각 h에 대한 식으로 표현하라. 단, root의 level을 1로 가정한다.

- node의 최소개수 : $2^{h-1}$
- node의 최대개수 : $2^h-1$

## (2) (1)에서 구한 node의 수를 n이라 할 때, 이를 이용하여 Complete Binary Tree의 최대 높이를 n으로 표현하라

node의 최대 개수는 2^h-1개 이므로 이를 n으로 놓고 h에 대해 풀어보면

- 2^h-1 = n
- 2^h = n+1
- h = $\log_2(n+1)$

따라서, Complete Binary Tree의 최대 높이는 $\log_2(n+1)$이다.



# 9. 다음의 비어 있는 array에 {30, 10, 40, 20, 70, 50, 60, 80} 의 8 개의 key들을 차례대로 insert 할 때, Max Heap이 만들어지는 과정을 완성시켜라. (array의 첫 주소는 1로 시작하는 것으로 하고, 반드시 각 과정을 array에서 보일 것. 

- [], 초기 배열
- [30], 첫 번째 key 30을 insert, 30 하나만 있는 Complete Binary Tree가 됨
- [30,10], 두 번째 key 10을 insert, 부모 노드 30은 자식 노드 10보다 크므로 Heapify 과정 없이 그대로 insert
- [30,10,40], 세 번째 key 40을 insert
- [40,10,30], 자식 노드 40은 부모 노드 10보다 크므로 두 노드를 swap, 부모 노드 40과 자식 노드 30을 비교하여 swap
- [40,10,30,20], 자식 노드 20은 부모 노드 10보다 크므로 두 노드를 swap
- [40,20,30,10], 자식 노드 20은 부모 노드 40보다 작으므로 Heapify 과정 없이 그대로 insert
- [40,20,30,10,70], 자식 노드 70은 부모 노드 20보다 크므로 두 노드를 swap
- [40,70,30,10,20], 자식 노드 70과 부모 노드 40을 비교하여 swap
- [70,20,40,10,30]

다섯 번째 key 70을 insert
배열: [70, 20, 40, 10, 30, , , ], 자식 노드 70은 부모 노드 20보다 크므로 두 노드를 swap한 후, 부모 노드 70과 자식 노드 40을 비교하여 swap

여섯 번째 key 50을 insert
배열: [70, 50, 40, 20, 30, 10, , ]
(자식 노드 50은 부모 노드 70보다 작으므로 Heapify 과정 없이 그대로 insert)

일곱 번째 key 60을 insert
배열: [70, 50, 60, 20, 30, 10, 40, ]
(자식 노드 60은 부모 노드 50보다 크므로 두 노드를 swap한 후, 부모 노드 70과 자식 노드 60을 비교하여 swap)

여덟 번째 key 80을 insert
배열: [80, 70, 60, 20, 30, 10, 40, 50]
(자식 노드 80은 부모 노드 80보다 크지 않으므로 Heapify 과정 없이 그대로



# 10. 다음의 array에 구현된 Max Heap을 이용하여 8 개의 key들을 올림 차순으로 sort 하는 과정을 완성시켜라. (힌트: 매번 delete를 하면서, 삭제된 값을 array의 맨 끝에 저장할 것.)

주어진 array는 Max Heap의 조건을 만족하고 있으므로, 이를 이용하여 Heap Sort 알고리즘을 적용하여 오름차순으로 sort할 수 있습니다.

초기 배열: [30, 25, 28, 20, 18, 12, 16, 15]
(주어진 array)

첫 번째 delete
배열: [28, 25, 16, 20, 18, 12, 15, ]
(삭제된 값 30은 맨 끝에 저장)

두 번째 delete
배열: [25, 20, 16, 15, 18, 12, , ]
(삭제된 값 28은 맨 끝에 저장)

세 번째 delete
배열: [20, 18, 16, 15, 12, , , ]
(삭제된 값 25는 맨 끝에 저장)

네 번째 delete
배열: [18, 15, 16, 12, , , , ]
(삭제된 값 20은 맨 끝에 저장)

다섯 번째 delete
배열: [16, 15, 12, , , , , ]
(삭제된 값 18은 맨 끝에 저장)

여섯 번째 delete
배열: [15, 12, , , , , , ]
(삭제된 값 16은 맨 끝에 저장)

일곱 번째 delete
배열: [12, , , , , , , ]
(삭제된 값 15은 맨 끝에 저장)

여덟 번째 delete
배열: [, , , , , , , 12]
(삭제된 값 12는 맨 끝에 저장)

위의 과정을 통해 Max Heap에서는 항상 root 노드가 최대값을 가지므로, delete를 반복하면서 맨 끝에 저장된 값들이 오름차순으로 정렬됩니다. 따라서, 위의 배열을 Heap Sort 알고리즘을 적용하여 올림차순으로 sort하면 [12, 15, 16, 18, 20, 25, 28, 30]이 됩니다.



# 11. 다음 6 개의 key들에 대해 다음의 각 순서로 삽입된 경우, 탐색 시간이 가장 작은 것을 골라라. {2, 7, 8, 10, 15, 20}

1) 15, 2, 20, 8, 7
2) 8, 20, 7, 2, 15, 10
3) 7, 2, 10, 8, 15, 20 (O)
4) 10, 7, 15, 20, 8



# 12. 1 부터 10까지 10개의 정수들이 있다고 하자. 이제 Max Heap을 만들려고 하는데, PREORDER로 순회한 결과, 10 개의 정수들이 내림 차순으로 정렬된 결과를 보여줄 수 있는 Max Heap를 찾아 그려라. 



# 13. n 개의 node를 갖는 Binary Tree에서 Leaf Node의 최소 개수와 최대 개수를 각각 구하라. 풀이 과정에서 최소와 최대인 경우에 Binary Tree가 각각 어느 유형인지를 보인 후, 이를 근거를 n에 대한 수식으로 개수를 계산하라.

n개의 노드가 있는 이진 트리에서 리프 노드의 최소 수는 1이며, 이는 트리가 스큐 트리라고도 하는 퇴화 트리일 때 발생하며 모든 n개의 노드가 루트에서 리프 노드까지 단일 경로에 있습니다.

n개의 노드가 있는 이진 트리에서 리프 노드의 최대 수는 (n+1)/2이며, 이는 트리가 완전한 이진 트리일 때 발생합니다. 여기서 트리의 모든 수준은 마지막 수준을 제외하고 완전히 채워집니다. 왼쪽에서 오른쪽으로 채워집니다.

노드가 n개인 완전한 이진 트리에서 리프 노드의 최대 수에 대한 공식을 유도하려면 높이가 h인 완전한 이진 트리의 노드 수가 2^(h+1)-1이며 여기서 h는 높이입니다. 나무의. n개의 노드가 있는 완전한 이진 트리에서 리프 노드의 최대 수를 m이라고 합니다. 그런 다음 우리는:

2^(h+1)-1 <= n < 2^(h+2)-1

트리가 완성되었으므로 마지막 레벨은 왼쪽에서 오른쪽으로 채워져야 하며 마지막 레벨의 리프 노드 수는 1에서 2^(h+1)-1 사이입니다. 따라서 다음이 있습니다.

m >= 2^h m <= 2^(h+1)-1 2^(h+1)-1 <= n < 2^(h+2)-1

이러한 불평등을 결합하면 다음을 얻습니다.

2^h <= (n+1)/2 < 2^(h+1)

이 부등식의 양변에 천정 함수를 취하면 다음을 얻습니다.

m = 셀((n+1)/2)

따라서 n개의 노드가 있는 이진 트리의 최대 리프 노드 수는 (n+1)/2이며 가장 가까운 정수로 반올림됩니다.

n개의 노드가 있는 퇴화 트리에서 리프 노드의 최소 수에 대한 공식을 도출하려면 트리의 각 노드에 최대 하나의 자식이 있습니다. 따라서 트리의 리프 노드 수는 자식이 없는 노드 수와 같습니다. n개의 노드가 있는 축퇴 트리의 최소 리프 노드 수를 m이라고 합니다. 그런 다음 우리는:

m + (nm) = n

트리의 각 노드에는 최대 하나의 자식이 있으므로 트리에는 정확히 n-1개의 가장자리가 있어야 합니다. 따라서 트리에서 잎이 아닌 노드의 수는 n-1-m입니다. 리프가 아닌 각 노드에는 정확히 하나의 자식이 있으므로 자식이 있는 노드는 정확히 n-1-m개여야 합니다. 따라서 다음이 있습니다.

n-1-m <= m n-1-2m <= 0 2m >= n-1 m >= (n-1)/2

따라서 n개의 노드가 있는 이진 트리에서 리프 노드의 최소 수는 ceil((n-1)/2)이며 가장 가까운 정수로 반올림됩니다.
