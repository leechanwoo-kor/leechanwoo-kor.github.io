---
title: "[Kafka] 아파치 카프카(Apache Kafka)란 무엇인가?"
categories:
  - Java
tags:
  - Kafka
toc: true
toc_sticky: true
toc_label: "아파치 카프카(Apache Kafka)란 무엇인가?"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/147999953-c14f55bf-d198-4437-bfe3-50f7e81e64a1.png){: width="100%" height="100%"}{: .align-center}

<br><br>

# 아파치 카프카(Apache Kafka)란 무엇인가?

데이터 파이프라인(Data Pipeline)을 구축할 때 가장 많이 고려되는 시스템 중 하나가 '카프카(kafka)'일 것이다. 아파치 카프카(Apache Kafka)는 링크드인(LinkedIn)에서 처음 개발된 분산 메시징 시스템이다.

2011년 오픈 소스로 공개되었으며 이후 2011년 10월 아파치 인큐베이터를 종료했다. 현재 링크드인에서 카프카를 개발하던 제이 크렙스(Jay Kreps)를 비롯한 일부 엔지니어들이 'Confluent'라는 회사를 설립하여 카프카와 관련된 일을 하고 있다.

카프카라는 이름은 유명한 작기인 '프란츠 카프카(Franz Kafka)'에서 따왔다.

>I thought that since Kafka was a system optimized for writing using a writer's name would make sense. I had taken a lot of lit classes in college and liked Franz Kafka. Plus the name sounded cool for an open source project.
>So basically there is not much of a relationship

제이 크렙스에 의하면, 쓰기에 최적화된 시스템이기 때문에 작가의 이름을 붙이는 게 좋겠다고 생각하던 차에 대학에서 다양한 수업으로 접했던 프란츠 카프카의 이름을 따서 이름을 짓게 되었고, 붙여보니 오픈소스 이름으로 괜찮은 이름이라 계속 사용하게 되었다고 한다. 카프카라는 이름이 아키텍처 혹은 구조와 크게 관련은 없다. 마치 하둡처럼?


## Publish/Subscribe (펍/섭) 시스템

카프카는 기본적으로 Publish-Subscribe 모델을 구현한 분산 메시징 시스템이다. Publish-Subscribe 모델은 데이터를 만들어 내는 프로듀서(Producer, 생산자), 소비하는 컨슈머(Consumer, 소비자) 그리고 이 둘 사이에서 중재자 역할을 하는 브로커(Broker)로 구성된 느슨한 결합(Loosely coupled)의 시스템이다.

프로듀서는 브로커를 통해 메시지를 발행(Publish)한다. 이때 메시지를 전달할 대상을 명시하지는 않으며 관련 메시지를 구독(Subscribe)할 컨슈머가 브로커에게 요청하여 가져가는 식이다. 마치 블로그 글을 작성하여 발행하면 블로그 글을 구독하는 독자들이 따로 읽어가는 형태를 생각하면 된다. (반대되는 개념으로는 글을 작성한 프로듀서가 구독하려는 컨슈머에게 직접 메일을 보내는 걸 생각하면 된다.)

![image](https://user-images.githubusercontent.com/55765292/148000307-f3698abd-e928-48c7-a1d0-c41f586201f1.png){: width="80%" height="80%"}{: .align-center}

카프카 역시 카프카 클러스터로 메시지를 전송할 수 있는 프로듀서와 카프카로부터 메시지를 읽어 갈 수 있는 컨슈머 클라이언트 API를 제공한다. 그 밖에 데이터 통합을 위한 커넥터(Connector)와 스트림 처리를 위한 스트림즈(Streams) API도 있지만 이 역시 크게 보면 프로듀서와 컨슈머의 확장이라고 볼 수 있다.

카프카에서 프로듀서는 특정 토픽(Topic)으로 메시지를 발행할 수 있다. 컨슈머 역시 특정 토픽의 메시지를 읽어 갈 수 있다. 카프카에서 토픽은 프로듀서와 컨슈머가 만나는 지점이라고 생각할 수 있다. (블로그의 RSS 피드 정도로 생각하면 되겠다. 티스토리는 카프카에 해당하며 티스토리에 존재하는 블로그 하나하나는 각각 하나의 토픽으로 대응될 수 있다. 프로듀서에 해당하는 블로거는 특정 블로그에 글을 작성하여 발행할 수 있고, 컨슈머에 해당하는 독자는 특정 블로그의 RSS를 구독하는 것을 생각하면 된다).

![image](https://user-images.githubusercontent.com/55765292/148000466-83e9313d-42e6-4bc1-869b-c7bc67642002.png){: width="80%" height="80%"}{: .align-center}

카프카는 수평적인 확장(scale horizontally, scale out)을 위해 클러스터를 구성한다. 카프카를 통해 유통되는 메시지가 늘어나면 카프카 브로커의 부담(Load)이 증가하게 되어 클러스터의 규모를 확장할 필요가 있다. 카프카는 여러 브로커들의 클러스터링을 위해 아파치 주키퍼(Apache ZooKeeper)를 사용한다. 주키퍼를 사용하면 브로커의 추가 및 장애 상황을 간단하게 대응할 수 있다.

카프카 클러스터 위에서 프로듀서가 전송한 메시지는 중복 저장(Replication)되어 장애상황에서도 고 가용성(High Availability)을 보장하게 된다. 프로듀서가 메시지를 카프카 클러스터로 전송하면 브로커는 또 다른 브로커에게 프로듀서의 메시지를 중복해서 저장한다. 만약 한 브로커에 장애가 생기더라도 중복으로 저장된 복사본을 컨슈머에게 전달할 수 있으므로 장애 상황에 대비(Fault-tolerant)할 수 있다.

