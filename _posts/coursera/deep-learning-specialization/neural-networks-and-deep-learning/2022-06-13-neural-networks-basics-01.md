---
title: "[Ⅰ. Neural Networks and Deep Learning] Neural Networks Basics (1)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
toc: true
toc_sticky: true
toc_label: "Neural Networks Basics (1)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/172768350-41a6b2f0-9468-4b13-bc94-4a38f89ce5e6.png)

<br><br>

# Neural Networks Basics

## Logistic Regression as a Neural Network

### Binary Classification
이번 포스팅에서는 신경망 프로그래밍의 기초에 대해 알아보도록 하겠습니다. 신경망을 구현할 때는 매우 중요한 몇 가지 기술이 있습니다. 예를 들어, $m$개의 훈련 예제를 가진 훈련 세트가 있으면, 훈련 예제에 대해서 for문을 돌리면서 하나씩 훈련 세트를 처리 해 왔을 것입니다. 하지만 신경망을 구현할 때는 일반적으로 전체 훈련 세트를 반복하기 위해 for문을 사용하지 않고 처리하고자 합니다. 따라서 이번 포스팅에서 그 방법을 알게 될 것입니다.

또 다른 아이디어는 신경망의 계산을 구성할 때 일반적으로 순방향 전달(forward pass) 또는 순방향 전파(forward propagation) 단계 그 다음에는 역방향 전달(backward pass) 또는 역방향 전파(backward propagation) 단계라는 것이 있습니다. 그래서 이번 포스팅에서는 신경망 학습의 계산이 왜 전파가 되는지와 왜 역방향 전파가 되는지에 대해 소개하도록 하겠습니다.

이 포스팅에서 이해를 돕고자 로지스틱 회귀를 통해 아이디어를 전달하려 합니다. 하지만 예전에 로지스틱 회귀에 대해서 들어보셨을지라도, 이 포스팅에서 몇 가지 새롭고 흥미로운 아이디어를
얻을 수 있을 것이라고 생각합니다. 그럼 시작해보도록 합시다.

![image](https://user-images.githubusercontent.com/55765292/173289066-8343da2d-e5bc-46bc-9a0a-a1f3fb674efa.png)


로지스틱 회귀는 이진 분류를 위한 알고리즘입니다. 문제를 통해 이야기해 보도록 합시다. 여기 예로 이진 분류 문제가 하나 있습니다. 여기와 같이 입력 이미지가 있습니다. 이미지를 인식하기 위해서 고양이일 때에는 $1$로, 고양이가 아닐 때는 $0$으로 레이블을 출력하려 합니다. 그리고 출력 레이블을 나타내기 위해 $y$를 사용하도록 하겠습니다.

이미지는 컴퓨터에서 어떻게 표현되는지 살펴 보겠습니다. 이미지를 저장하기 위해서 컴퓨터는 각각 빨간색, 녹색, 파란색 채널에 해당하는 세 개로 분리된 행렬을 사용합니다. 따라서 입력 이미지가 64 x 64 픽셀인 경우 빨간색, 녹색, 파란색 픽셀의 채도값에 해당하는 3개의 64 x 64 행렬이 있을 것입니다. 이 작은 슬라이드를 만들기 위해 훨씬 더 작은 행렬로 그렸지만 실제로는 64 x 64가 아닌 5 x 4 행렬입니다. 이 픽셀들의 채도값을 특징 벡터로 바꾸기 위해 여기 픽셀값 모두를 하나의 입력 특징 벡터 $x$에 펼쳐 보았습니다. 모든 픽셀 채도값을 특징 벡터에 나열하기 위해서 다음과 같이 이 이미지에 해당하는 특징 벡터 $x$를 정의해 봅시다.

![image](https://user-images.githubusercontent.com/55765292/173293274-a13bc777-7854-4ee8-876f-661cefd69f90.png){: .align-center}

우리는 모든 픽셀 값 255, 231 등을 취할 것입니다. 255, 231, 이런식으로 빨간색 픽셀값 모두를 나열합시다. 그리고 결국 255, 134, 255, 134 등등 이 이미지의 모든 빨강, 초록, 파랑 픽셀 채도값을 나열하는 긴 특징 벡터를 얻을 때까지 계속합니다. 이 이미지가 64 x 64 이미지인 경우 이 벡터 $x$의 전체 차원은 64 x 64 x 3이 될 것입니다. 왜냐하면 이 모든 행렬에서 우리가 가지고 있는 총 숫자이기 때문입니다. 이 경우에는 12,288이 되겠고 여기 모든 숫자를 곱하면 얻을 수가 있습니다. 그래서 $n_x=12,288$을 사용하여 입력 특징 $x$의 차원을 나타낼 것입니다. 그리고 때때로 간결하게 입력 특징 벡터의 차원을 나타내기 위해 소문자 $n$을 쓰겠습니다.

따라서 이진 분류에서 우리의 목표는 이 특징 벡터 $x$로 표현되는 이미지를 입력할 수 있는 분류기를 배우는 것입니다. 그리고 해당 레이블 $y$가 $1$인지 $0$인지 즉, 고양이 이미지인지 고양이가 아닌 이미지인지 예측합니다. 앞으로 이 강의에서 사용하게 될 몇 가지 표기법을 정리해 보겠습니다.

---

![image](https://user-images.githubusercontent.com/55765292/173289088-22ddcd64-4a5a-42e1-8203-32dfc254fd26.png)

하나의 훈련 표본은 $(x,y)$쌍으로 표기되며 여기서 $x$는 $x$차원을 가진 특징 벡터이고 $y$는 $0$ 혹은 $1$중에 하나의 값을 가지는 레이블입니다. 훈련 세트는 소문자 $m$ 훈련 예제로 구성되어 있습니다. 그래서 당신의 훈련 세트는 $(x^{(1)}, y^{(1)})$로 작성될 것이며 이는 첫 번째 훈련 예제 $(x^{(2)}, y^{(2)})$의 입력값과 출력값이며 마지막 훈련 표본 $(x^m, y^m)$으로 적을 수가 있습니다. 그리고 그것은 모두 당신의 전체 훈련 세트입니다.

훈련 예제의 수를 나타내기 위해 소문자 $m$을 사용하도록 하겠습니다. 그리고 가끔 훈련 예제의 숫자임을 강조하기 위해 이것을 $m=m_train$ 으로 적도록 하겠습니다. 그리고 테스트 세트를 이야기할 때 테스트 예제의 수를 나타내기 위해 $m_test$를 사용할 수도 있습니다. 그래서 이것이 테스트 예제의 수입니다.

마지막으로 모든 훈련 예제를 더욱 간결한 표기법으로 출력하기 위해서 대문자 $X$로 행렬을 정의하겠습니다. 이 행렬은 훈련 세트 입력값들 $x^{(1)}, x^{(2)}$ 등을 가져와서 열로 입력값들을 쌓은 것입니다 그래서 $x^{(1)}$을 가져와서 여기 행렬의 첫번째 열에 놓고 $x^{(2)}$는 두번째 열, 이런식으로 $x^{(m)}$까지 놓겠습니다. 그러면서 행렬 $X$가 만들어지겠습니다. 따라서 이 행렬 $X$는 $m$개의 열을 가질 것이며 m은 훈련 예제의 수와 훈련의 수를 나타내고, 이 행렬의 높이는 $n_x$입니다. 다른 원인에서는 행으로 훈련 예제를 쌓아 정의된 행렬 $X$를 보실 수 있습니다 $x^{(1)}$ 전치시키고, 아래로 가서 $x^{(m)}$까지 전치시키는 식으로 말입니다. 하지만 신경망을 구현할 때는 왼쪽에 있는 이 규칙을 사용하면 구현이 훨씬 쉬워집니다.

그래서 요약하면, $X$는 $n_x$ x $m$차원을 가진 행렬이고, 파이썬을 코딩할 때 나오는 X.shape는 행렬의 형태를 알기 위한 파이썬 명령어이고 $(n_x, m)$이라는 것을 알 수 있습니다. 따라서 그것은 단순히 $n_x$ x $m$차원의 행렬이라는 것을 의미합니다. 이것이 훈련 예제를 그룹화하고 $x$를 행렬에 입력하는 방법입니다.

그렇다면 출력 레이블 $Y$는 어떻게 할까요? 신경망을 좀 더 쉽게 구현할려면 $Y$도 열로 해서 쌓는 것이 더 편리합니다. 그래서 우리는 대문자 $Y$를 $y^{(1)}, y^{(2)}$와 동일하게 y^{(m)}까지 정의하려고 합니다. 그러면 여기 있는 $Y$는 1 x $m$ 차원 행렬이 됩니다. 그리고 다시 파이썬에서 Y.shape로 보면 $(1, m)$이 되겠죠. 즉, 이것은 1 x $m$ 행렬임을 의미합니다. 그리고 이 과정의 후반부에서 신경망을 구현하면 유용하다는 것을 알게 될 것입니다. 규칙은 다른 훈련 예제와 관련된 데이터를 적용시키는 것이며 여기서 데이터는 $x$ 또는 $y$ 또는 나중에 다룰 데이터의 양입니다 그러나 여기에서 x와 y에 대해 수행한 것처럼 다른 훈련 예제와 관련된 자료 또는 데이터를 가져와서 다른 열에 쌓는 방식으로 진행합니다. 따라서 그것은 로지스틱 회귀에 사용할 표기법입니다. 다음에는 이 표기법을 사용하여 로지스틱 회귀를 도출하는 법을 다루겠습니다.
