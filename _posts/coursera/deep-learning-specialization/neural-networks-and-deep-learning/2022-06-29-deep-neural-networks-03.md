---
title: "[Ⅰ. Neural Networks and Deep Learning] Deep Neural Networks (3)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
toc: true
toc_sticky: true
toc_label: "Deep Neural Networks (3)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/172768350-41a6b2f0-9468-4b13-bc94-4a38f89ce5e6.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Deep Neural Networks

## Deep Neural Network

### Why Deep Representations?

여러 가지 문제에서 심층 신경망이 잘 작동한다고 많이 들었을텐데요. 단순히 신경망의 크기가 커서 잘되는 것이 아닙니다. 신경망 네트워크는 깊고 숨겨진 레이어가 많아야 합니다. 왜 그런걸까요? 몇 가지 예를 살펴보고 심층 네트워크가 잘 작동하는 이유에 대한 직관을 얻으려고 합니다.

![image](https://user-images.githubusercontent.com/55765292/176356740-234e9b52-cbc4-4ea4-b6b9-d4710d0f1581.png)

그럼 먼저 심층 네트워크 컴퓨팅이란 무엇일까요? 얼굴식이나 얼굴감지를 위한 시스템을 구축하고 있다면 심층 신경망이 할 수 있는 일은 다음과 같습니다.

얼굴 사진을 입력한 후 신경망의 첫 번째 레이어를 특징 탐지기 또는 가장자리 탐지기로 생각할 수 있습니다. 이 예제에서는 20개 정도의 은닉 유닛을 가진 신경망이 이 이미지에서 무엇을 계산하려고 하는지 플로팅합니다. 이 작은 사각형 상자로 시각화된 20개의 은닉 유닛이 있습니다.

예를 들어 이 작은 시각화는 이미지에서 해당 방향의 가장자리가 어디에 있는지 알아내려는 은닉 유닛을 나타냅니다. 어쩌면 이 은닉 유닛은 이 이미지에서 수평 가장자리가 어디에 있는지 알아내려고 하는 것일 수도 있습니다. 그리고 이후 과정에서 컨볼루션 네트워크에 대해 이야기할 때 이 특정 시각화가 좀 더 이해가 될 것입니다.

하지만 그 형태는  신경망의 첫 번째 레이어를 생각하시면 되는데 그림을 보고 이 사진의 가장자리가 어디에 있는지 알아내려고합니다. 이제 픽셀을 그룹화하여 가장자리를 형성함으로써 이 그림의 가장자리가 어디에 있는지 생각해보겠습니다. 그런 다음 가장자리를 감지하고 가장자리를 그룹화하여 면의 일부를 형성할 수 있습니다.

예를 들어 눈을 찾고 있는지 코의 해당 부분을 찾고 있는지 확인할 수 있습니다. 이렇게 모서리들을 취합하는 과정을 통해 얼굴의 다른 부분들을 탐지할 수 있는 것입니다. 그런 다음 마지막으로 눈, 코, 귀, 턱 등 얼굴의 다른 부분을 조합하여 다양한 유형의 얼굴을 인식하거나 감지하려고 시도할 수 있습니다.

직관적으로 신경망의 이전 레이어를 가장자리와 같은 단순한 기능을 감지하는 것이라고 생각할 수 있습니다. 그리고나서 다음 단계의 신경망 레이어에서 함께 구성하여 점점 더 복잡한 함수를 학습할 수 있도록 합니다. 이러한 시각화 컨볼루션 네트에 대하 이야기할 때 더 이해가 있을 것입니다.

이 시각화의 기술적인 세부 사항 중 하나는 에지 디렉터가 이미지의 비교적 작은 영역 아마도 아주 작은 영역을 찾고 있다는 것입니다. 그리곤다서 얼굴 감지기는 훨씬 더 넓은 범위의 이미지를 볼 수 있습니다. 하지만 여기서 중요한 직관은 가장자리와 같은 단순한 것을 찾아 쌓는 것입니다. 눈이나 코와 같 더 복잡한 것들을 탐지하기 위해 그것들을 함께 구성하고, 더 복잡한 것들을 찾기 위해 그것들을 함께 구성합니다.

이러한 유형의 단순에서 복잡한 계층적 표현 또는 구성적 표현은 이미지 및 얼굴 인식 이외의 다른 유형의 데이터에도 적용됩니다.

예들 들어 음성 인신 시스템을 구축하려는 경우 음성을 시각화하기는 쉽지 않지만, 오디오 음성 클립을 입력하면 신경망의 첫 번째 레벨은 낮은 레벨의 오디오 웨이브 형식을 감지하도록 배울 수 있습니다. 톤이 올라가는지 내려가는지 백색소음인지 아닌지 그리고 피치는 무엇인지 등 

그것에 관해서 그러한 낮은 수준의 파형을 기능을 감지합니다. 그런 다음 낮은 수준의 파형을 구성하여 소리의 기본 단위를 감지하는 법을 배우게 될 것입니다. 언어학에서는 음소라고 부릅니다. 하지만, 예를 들어 'cat'이라는 단어에서 c, a, t는 각각 다른 음소 입니다.

그러나 소리의 기본단위를 찾는 법을 배우고 그런 다음 함께 작곡하면 오디오에서 단어를 인식하는 방법을 배울 수 있습니다. 그리고 그것들을 함께 구성해서 전체 문구나 문장을 인식할 수 있을 겁니다.

따라서 여러 개의 숨겨진 레이어를 가진 심층 신경망은 이전 레이어가 이러한 낮은 수준의 간단한 기능을 학습한 다음 나중에 더 깊은 레이어에서 감지된 더 간단한 것을 결합하여 특정 단어를 인식하거 구 또는 문장을 감지할 수 있도록 만듭니다. 음성인식 기능을 수행하기 위해서 말이죠.

우리가 보는 것은 다른 레이어가 컴퓨팅하는 동안 가장자리가 어디에 있는지와 같은 비교적 간단한 입력 함수처럼 보이는 것이 네트워크 깊숙히 진입하면 놀랍게도 복잡한 것들을 다루게 됩니다. 예를 들어 얼굴을 감지하거나 단어, 구 또는 문장을 탐지합니다.

어떤 사람들은 심층 신경망과 인간의 뇌 사이의 유추를 선호하는데요. 신경과학자들은 인간의 뇌가 눈에 보이는 가장자리 같은 단순한 것들을 감지하기 시작하고 여러분이 보는 얼굴과 같은 더 복잡한 것들을 감지하기 위해 그것들을 축적한다고 믿습니다.

딥 러닝과 인간의 두뇌의 유사점은 때때로 조금 위험하다고 생각합니다. 하지만 인간의 두뇌가 작동하는 방식에는 많은 진실이 있는데요 인간의 뇌는 아마도 가장자리 같은 단순한 것들을 먼저 감지한 다음 점점 더 복잡한 물체에서 그것들을 합친다는 것입니다. 일부 딥 러닝에 대한 영감도 제공합니다.


![image](https://user-images.githubusercontent.com/55765292/176356819-0e294f62-7d7c-4ee6-aff2-817a398e510c.png)

딥 네트워크가 잘 작동하는 이유에 대한 또 다른 직관은 다음과 같습니다. 따라서 이 결과는 다른 AND 게이트, OR 게이트, NOT 게이트 기본적으로 논리 게이트로 계산할 수 있는 함수의 유형에 대한 생각과 관련된 회로 이론에서 비롯됩니다.

비공식적으로, 이 함수들은 작지만 심층 신경망으로 계산되며 작다는 것은 은닉 유닛의 수가 상대적으로 적다는 것을 의미합니다. 그러나 얕은 네트워크로 동일한 함수를 계산하려고 하면 은닉층이 충분하지 않다면, 계산하기 위해 은닉 유닛이 기하급수적으로 더 많이 필요할 수 있습니다.

그래서 한 가지 예제를 보여주고 이것을 약간 비공식적으로 설명하겠습니다. XOR 또는 모든 입력 특성의 패리티를 계산하려고 한다고 가정해 보겠습니다.

따라서 $n$ 또는 $n_x$의 특징이 있는 경우 $x_1$ XOR $x_2$ XOR $x_3$ XOR ... XOR $x_n$을 계산하려고 합니다. 이렇게 XOR 트리에 삽입하면 $x_1$과 $x_2$의 XOR을 계산하고 $x_3$과 $x_4$를 취해서 XOR을 계산합니다.

엄밀히 이야기하면, AND 또는 NOT 게이트를 이용하는 경우, XOR 함수를 계산하기 위해 두 개 정도의 레이어가 필요할 수 있지만 상대적으로 적은 회로를 사용하여 XOR 등을 계산할 수 있습니다. 그런 다음 실제로 XOR 트리를 구축할 수 있습니다.

이렇게 해서 최종적으로 y라고 불리는 회로를 만들 수 있습니다. $\hat{y}$의 출력은 y와 같습니다. 모든 입력 비트의 패리티인 XOR입니다. 따라서 XOR을 계산하기 위해 네트워크의 깊이는 $O(log{n}$의 순서로 됩니다. XOR 트리만 있으면 됩니다.

따라서 이 네트워크 내의 노드 수, 회선 컴포넌트 수, 게이트 수는 그다지 많지 않습니다. XOR을 계산하는 데 그리 많은 게이트가 필요하지 않습니다.

하지만 이제 여러 개의 은닉층이 있는 신경망을 사용할 수 없다면 이 경우에는 로그와 은닉층을 봐야하는데요 만약 하나의 은닉층으로 함수를 계산해야 한다면 이 모든 것들이 은닉 유닛으로 들어가게 하는 것입니다.

그런 다음 이러한 것들이 y를 출력합니다. 이 XOR 함수를 계산하려면 이 은닉층이 기하급수적으로 커야합니다. 2의 n승의 배열을 열거해야 하기 때문이죠. 따라서 2의 n에 대한 순서로 XOR이 1또는 0이 되는 입력 비트의 구성이 가능합니다.

따라서 비트 수가 기하급수적으로 많은 은닉층이 필요합니다. 기술적으로 2에서 n-1의 은닉 유닛으로 이 작업을 수행할 수 있습니다. 하지만 이 값은 오래된 2의 n승이므로 비트 수에서 기하급수적으로 커집니다. 그래서 얕은 네트워크보다 깊은 네트워크에서의 계산이 훨씬 쉬운 수학 함수가 있다는 것을 알 수 있기를 바랍니다.

사실 저는 회로이론의 결과가 직관력을 얻는데 덜 유용하다는 것을 느꼈지만 이것은 사람들이 매우 깊은 표현의 가치를 설명할 때 자주 인용하는 결과 중 하나입니다.

이상 딥러닝이 잘 작동하는 이유에 대한 직관적인 부분은 모두 설명해 드렸는데요. 이제 순전파뿐만 아니라 역전파를 구현하는 방법에 대한 메커니즘을 살펴보겠습니다.


### Building Blocks of Deep Neural Networks

이번 주의 초기 영상과 지난 몇 주 동안의 영상에서 여러분은 심층 신경망을 구현하는 데 필요한 핵심 요소인 순방향 전파 및 역방향 전파의 기본 빌딩 블록을 보았습니다. 이러한 구성 요소를 결합하여 심층 네트워크를 구축하는 방법을 살펴보겠습니다.

![image](https://user-images.githubusercontent.com/55765292/176574988-2823242f-a63f-4aee-b1e9-035d057b0e15.png)

여기 몇 개 레이어의 네트워크가 있습니다. 한 레이어를 선택해보죠. 그리고 지금은 그 레이어에만 초점을 맞춘 계산을 살펴봅시다. 따라서 레이어 L의 경우 일부 매개변수 $w^{[l]}, b^{[l]}$이 있고 순방향 전파의 경우 이전 레이어의 활성화 $a^{[l-1]}$을 입력하고 $a^{[l]}$을 출력합니다.

앞에서 설명한 방법은 $z^{[l]} = W^{[l]}a^{[l-1]} + b^{[l]}$을 계산하는 것입니다. 그리고 나서는 $a^{[l]} = g^{[l]}(z^{[l]})$인거죠. 바로 이런 방법으로 입력 $a^{[l-1]}$으로부터 출력 $a^{[l]}$이 나오게 됩니다.

그리고 나중에 사용할 때는 $z^{[l]}$값을 캐시하는 것도 유용한 것으로 나타났습니다. $z^{[l]}$값을 저장하는 것이 역방향 전파 단계에서 유용하기 때문에 캐시에도 포함시키겠습니다.

그다음, 역방향 단계나 역방향 전파 단계에서 다시 이 레이어 l을 위한 계산에 초점을 맞추면 $da^{[l]}$을 입력하는 함수를 구현할 것입니다. 그리고 $da^{[l-1]}$을 출력하고 세부 사항을 구체화하기 위해, 입력은 실제로 $da^{[l]}$와 캐시를 통해 계산한 $z^{[l]}$ 값을 사용할 수 있으며, 추가로 다음을 출력합니다.

$da^{[l-1]}$ 학습을 위한 기울기 하강을 구현하기 위해 원하는 출력 또는 기울기를 가져옵니다. 이것은 순방향 단계를 구현하는 방법, 순방향 함수라고 부르는 것 그리고 역방향 함수라고 부를 역방향 단계에 대한 기본 구조입니다.

요약하면, 레이어 l에서는 순방향 함수의 순방향 단계 또는 순방향 전파가 있을 것입니다. 입력 $a^{[l-1]}$과 출력 $a^{[l]}$ 및 이 계산을 수행하기 위해 필요한 경우에는 $w^{[l]}, b^{[l]}$을 사용해야 합니다. 또한 $z^{[l]}$을 포함하는 캐시도 출력합니다.

그리고 나서 역방향 함수 역방향 단계를 사용하여 그것은 이제 $da^{[l]}$를 입력하고 $da^{[l-1]}$를 출력하는 또 다른 함수가 될 것입니다. 따라서 이러한 활성화에 대한 도함수가 주어지면 $da^{[l]}$이 도함수가 무엇인지 알려줍니다.

아시다시피 $a^{[l-1]}$은 이전 레이어의 비활성화와 관련하여 계산된 도함수를 변경합니다. 박스안에서요. $w^{[l]},b^{[l]}$을 사용해야 하는데, $dz^{[l]}$를 계산하는 과정에서 이 상자를 사용하면, 이 역방향 함수는 $dw^{[l]},db^{[l]}$도 출력할 수 있지만 때때로 역방향 반복을 나타내기 위해 빨간색 화살표를 사용했습니다.

이 두함수를 구현할 수 있다면, 신경망의 기본 계산은 다음과 같습니다.

![image](https://user-images.githubusercontent.com/55765292/176575057-b558d9b8-dbe5-40d3-964b-be1ebbb4f274.png)
