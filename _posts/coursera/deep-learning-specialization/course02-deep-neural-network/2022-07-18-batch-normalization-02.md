---
title: "[Ⅱ. Deep Neural Network] Batch Normalization (2)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Tensorflow
  - Deep Learning
  - Mathematical Optimization
  - Hyperparameter Tuning
toc: true
toc_sticky: true
toc_label: "Batch Normalization (2)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/177095282-038ee3ed-f543-4793-9eff-f2d5ac239f36.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Optimization Algorithms

## Batch Normalization

### Fitting Batch Norm into a Neural Network

그럼 어떻게 해야 하는지 방정식을 보셨는데요 배치 노름을 개발하는 공식을 보았는데요. 심층신경망의 훈련에는 어떻게 맞는지 한번 보겠습니다. 

---

![image](https://user-images.githubusercontent.com/55765292/179446431-46e9e4f3-9933-4d66-b9a3-2570b9ad2eb3.png)

이렇게 생긴 신경망이 있다고 가정해보겠는데요. 각각의 유닛을 두 가지를 계산하는 것으로 볼 수 있다고 말하는 것을 본 적이 있습니다. 첫번째로 z의 값을 계산하고 다음으로 활성화 함수를 적용하여 a를 구합니다. 그래서 우리는 이 원들이 각각이 2단계 연산을 나타낸다고 생각할 수 있습니다. 다음층도 이와 비슷하게 z21, a21 등등 말이죠.

그러므로 여러분이 배치 노름을 적용하지 않는 것이면 첫 번째 은닉층에 맞는 입력 x를 가질 수 있고 그리고 먼저 z1의 값을 산출하고 이 값은 파라미터 w1, b1에 따라 달라집니다. 그리고 보통은 z1을 활성화 함수에 삽입하여 a1의 값을 구할 것입니다.

하지만 배치 노름에서 할 것은 여기 z1의 값을 갖고, 그리고 배치 노름을 적용시킬 것입니다. 가끔씩 BN으로 줄여서 부릅니다. 그리고 이 값은 파라미터 베타 1과 감마 1에의해 지배될 것입니다. 그러면 여기 새롭게 정규화된 z1 값을 줄 것입니다. 그리고 a1의 값을 갖기 위해 이 값을 활성화 함수에 삽입하고, 이 값은 $g^{[1]}(\tilde{z}^{[1]})$입니다. 그러면 이제 첫번째 층에 대한 계산을 마쳤는데요. z와 a사이에서 실제로 산출 과정에서 배치 노름이 발생합니다.

다음으로, a[1]값을 갖고 z[2]를 계산하며, 이제 그러면 이 값은 w[2], b[2]에 의해 관리되겠죠. 그리고 첫번째 층에서 했던 것과 같이 비슷하게, z[2]의 값을 갖고 배치 노름에 적용 시키고 그리고 이것은 이제 BN으로 줄여서 쓰죠. 이것은 다음 층에 특정한 배치 노름 파라미터에 의해 지배됩니다. 즉, 베타 2와 감마 2이며 그럼 이제 z틸더[2]의 값을 얻을텐데요. 활성화 함수 등을 적용하여 A[2]를 계산하는 데 사용합니다. 다시 한번, 배치 노름은 Z와 A를 계산하는 사이에서 발생합니다.

그럼 직관적인 부분은 정규화가 안된 z의 값을 사용하는 대신에 정규화 z틸더 값을 사용할 수 있으며 그것은 첫번째 층이겠죠. 두번째 층에서도 마찬가지로 정규화 안된 z[2]값을 사용하는 대신에 평균 값과 분산이 정규화된 z틸더[2]값을 이용할 수 있습니다. 그러면 파라미터의 네트워크는 w[1], b[1]이 될 것입니다.

지금은 매개변수가 일반적인 W[l]이라고 상상해 보겠습니다. 추가적인 파라티머 베타 1, 감마 1, 베타 2 , 감마 2 그리고 계속 되며 배치 노름을 적용하는 각각의 층에 말이죠. 명료성을 위해 여기 베타 값은 여러 지수 가중 평균을 구했을 때 산출했던 모멘텀에서 있었던 하이퍼 파라미터 베타와는 상관이 없습니다. Adam 논문의 저자들은 베타를 사용해서 하이퍼 파라미터를 표기합니다. 그리고 배치 노름 논문의 저자들은 여기 이 파라미터를 나타내기위해 베타를 썼고요. 하지만 여기 2개는 완전히 다른 베타들입니다.

2개의 경우 모두에서 베타를 쓰기로 했는데요. 여러분이 논문을 읽으실 경우, 하지만 베타1, 베타2 등등과 같이, 배치 노름이 배우려고 하는 것은 다른 베타입니다. 모멘텀에 사용되는 하이퍼파라미터 베타와 Adam과 RMSprop 알고리즘입니다. 이제 이것들은 단순한 경사 하강이 아니라 이제 어떤 최적화 방법을 사용할 것입니다. 도입하기 위해 기울기 하강과 같은 방법을 말이죠.

예를 들어, 어떤 층에 대해 d 베타 l을 계산할 수 있겠죠. 그리고 그 후로 파라미터를 업데이트 하는데요. Adam 이나 RmsProp 또는 모멘텀을 사용해서 베타나 감마와 같은 파라미터를 업데이트할 수 있는데요. 알고리즘의 새로운 파라미터입니다. 그리고 심지어 이전에는 배치 노름이 하는 일을 설명 드렸는데요. 평균값, 분산을 계산하고 이 값을 빼고 나눈다고 했는데요. 만약 딥러닝 프로그래밍 프레임워크를 쓰는 경우엔 보통은 배치 노름 단계 또는 배치 노름 층을 여러분이 직접 도입할 필요가 없을 것입니다.

따라서 탐색 프레임워크는 이것은 한줄의 코드일 수 있는데요. 예를 들어 흐름 프레임워크 측면에서 `tf.nn.batch-normalization` 이 함수를 이용해서 배치 노름을 도입할 수 있습니다. 프로그래밍 프레임워크에 대해서는 나중에 더 이야기 하겠습니다. 하지만 실제로는 여기 이런 상세한 부분들은 본인이 직접 도입할 필요가 없고 여러분이 이것이 어떻게 작동하는지 이해하고 코드가 무엇을 하는지 배우는 것입니다. 그런데 배치 노름을 도입하는 것은 딥러닝 프레임워크에서 보통 한줄의 코드입니다. 현재까지 배치 노름이 마치 전체 훈련 세트에서 한번에 훈련 시키는 것처럼 이야기 했는데요. 마치 배치 기울기 하강을 쓰는 것처럼 말이죠.

---

![image](https://user-images.githubusercontent.com/55765292/179446469-f5bcdcae-212e-4f27-ba3c-f9c19776f656.png)

실제로는 배치 노름은 보통 훈련 세트의 미니 배치와 같이 적용됩니다. 그러면 배치 노름을 적용하는 방식은 첫번째 미니 배치를 가지고 z1을 계산합니다. w1과 b1 파라미터를 사용해서 이전에 한 것 처럼 말이죠. 그 다음 이 미니 배치를 가지고 z1의 평균값과 분산을 구하고 그런 다음 배치 노름은 평균을 빼고 표준 미분으로 나눈 다음 베타 1, 감마 1로 다시 조정하여 z1을 제공합니다.

이 모든 것은 그러면 첫번째 미니 배치에 있겠죠. 그 이후에, 활성화 함수를 적용하여 a1을 구하고, 그 다음, w2, b2 등을 이용하여 z2를 구합니다. 그러면 여러분은 이 모든 것을 첫번째 미니 배치에서의 기울기 하강을 수행한 다음 두 번째 미니 배치 x2로 이동하기 위해 이 모든 작업을 수행하며 그리고 여기서도 비슷하게 하는데요.

이제는 두번째 미니 배치에서 z1을 계산하고, 배치 노름을 이용해서 z1 틸더를 구합니다. 그러면 여기 배치 노름 단계에서 두 번째 미니 배치의 데이터만 사용하여 Z 틸더를 정규화할 수 있습니다. 그럼 여기 배치 노름 단계에서도 마찬가지죠. 두번째 미니 배치의 예시를 볼텐데요. z[1]의 평균값과 분산을 계산하는데요. z 틸더를 얻기 위해 베타 및 감마로 다시 스케일링하는 등의 작업을 수행합니다. 그리고 이것을 세번째 미니 배치에서도 하여 계속 훈련합니다.

매개변수화에서 한가지 정리하고 싶은 상세 부분이 있는데요. 이전에 파라미터가 각각의 층에 대해서 w[l], b[l], 그리고 베타 [l], 그리고 감마 L이라고 했는데요. z가 계산된 방식을 한번 보겠습니다. Z[L] = W[L] x A[L - 1] + B[L] 인데요. 그런데 배치 노름이 하는 것은 미니 배치를 보고나서 Z[L]을 첫번째 평균값 0 그리고 표준 분산을 정규화하고나서 베타와 감마로 재조정 할 것입니다.

이것이 뜻하는 바는 b[l]이 어떤 값을 갖더라도 실제로는 뺄 것인데 왜냐하면 배치 노름 단계 동안에 Z[L]의 평균값을 구한 뒤에 평균값을 뺄 것이기 때문입니다. 그러므로 여기 모든 미니 배치 예제에서 상수를 더하는 것은 아무 변화도 일으키지 않습니다. 그 이유는 상수가 더해지더라도 평균값이 빼지므로 그 효과가 취소되기 때문입니다. 

그러므로 배치 노름을 쓰는 경우 이 파라미터를 제거할 수 있고 또는 원하실 경우 이것을 영구적으로 0으로 설정하는 것을 생각해보세요. 그러면 z[l]의 매개변수화 w[l] 곱하기 a[l-1]이 됩니다. 그런 다음 정규화된 Z[L]을 계산하는데요. 그 다음 z 틸더 값은 감마 Z[L] 더하기 베타인데요. 여기 베타 L 파라미터를 쓰게 됩니다. z 틸더 l의 평균값을 정하기 위해서 말이죠. 그 다음 이 값이 다음 층으로 넘어갑니다.

복습하자면 여기 층에 있는 Z[L] 값들에 대해서 배치 노름은 평균값을 0으로 만들기 때문에 여기 BL 파라미터를 갖는 의미가 없습니다. 그러므로 그냥 없애는 것이며 그리고 대신해서 베타 L로 대체되었고요. 베타 L은 이동이나 바이어스 항들에 영향을 주는 파라미터입니다.

마지막으로 Z[L]의 차원을 기억하셔야 하는데요. 하나의 예시에서 진행할 경우 그 값은 N[L] x 1 인데요0 그러면 B[L]은 한 차원 N[L] x 1인데요. 만약 N[L]이 l층에서의 은닉 단위의 수라고 하면 말이죠. 그러면 베타 L과 감마 L의 차원 역시 마찬가지로 N[L] x 1이 될것인데요. 그 이유는 이것이 은닉 단위의 수이기 때문입니다. N[L]개의 은닉 단위가 있고 각각의 은닉 단위에 대해서 베타 L, 감마 L을 통해 평균값과 분산이 스케일링되는 것입니다. 네트워크가 원하는 설정값대로 말이죠.

---

![image](https://user-images.githubusercontent.com/55765292/179446486-b2f21698-15c1-4012-b916-dbbf9ab9177b.png)

이제 그러면 모든 것들을 취합해서 배치 노름을 이용해서 기울기 하강을 도입하는 방법을 보겠습니다. 미니 배치 기울기 하강을 사용한다는 가정하에 T=1에서 미니 배치 숫자까지 반복하는데요. 그리고 미니 배치 X{T}에 대해서 순전파를 도입할텐데요. 그리고 각각의 은닉 단위에 대해서 순전파를 하는 것은 Z[l]을 Z 틸더 L로 바꾸기 위해 배치 노름을 사용하세요.

그러면 여기 미니 배치 안에서 z의 값은 정규화된 평균값과 분산을 갖게 되는데요. 여기 값과 버전은 z 틸더 l이 됩니다. 그 다음에 역전파를 이용해서 dw, db 그리고 모든 l의 값에 대해서 d 베타, d 감마입니다. 비록 기술적으로 b를 없애야 하므로 이거는 사실 사라집니다.

마지막으로 파라미터를 업데이트 시킵니다. 그러면 w 는 w 빼기 학습률 곱하기, 이전과 같이 말이죠, 베타는 베타 빼기 학습률 곱하기 db 그리고 감마도 비슷하게 계산합니다. 그리고 여러분이 기울기를 이와 같이 계산한 경우 기울기 하강을 이용할 수 있습니다.

하지만 이것은 기울기 하강과 모멘텀에서도 잘 작동하는데요. 또는 RmsProp 또는 Adam에서도 말이죠. 여기 기울기 하강 업데이트를 갖는 대신에 미니 배치를 사용하면 이러한 다른 알고리즘에서 제공하는 업데이트를 사용할 수 있습니다. 여기 다른 최적화 알고리즘은 베타와 감마와 같은 배치 정규화가 알고리즘에 더한 것들을 이용해서 파리미터를 업데이트 하는데 사용될 수도 있습니다.
