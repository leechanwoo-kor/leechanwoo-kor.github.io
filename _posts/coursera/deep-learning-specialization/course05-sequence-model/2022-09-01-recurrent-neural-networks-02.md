---
title: "[Ⅴ. Sequence Models] Recurrent Neural Networks (2)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Deep Learning
  - Facial Recognition System
  - Convolutional Neural Network
  - Tensorflow
  - Object Detection and Segmentation
toc: true
toc_sticky: true
toc_label: "Recurrent Neural Networks (2)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/187809649-f4918caf-ae96-4f46-a0cf-42ba990450d9.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Recurrent Neural Networks

## Recurrent Neural Networks

### Recurrent Neural Network Model

시퀀스 학습 문제에서 정의할 표기법들을 보았습니다. 이제 모델을 구축하는 방법에 대해 얘기하겠습니다. x에서 y로 매핑하는 신경망을 구축하겠습니다.

#### Why not a standard network?

![image](https://user-images.githubusercontent.com/55765292/187847331-11cd8fed-832d-4ba8-9860-0b6d7eeb0554.png)

지금 할 수 있는 것은 이 작업에 대한 **표준 신경망standard network**을 사용해 보는 겁니다. 이전 예제에서 9개의 입력 단어가 있었습니다. 9개의 입력 단어를 받아들이는 것을 상상할 수 있습니다.

아마 9개의 원-핫 벡터가 표준 신경망에 입력되고 몇 개의 히든 레이어 최종적으로 각 단어가 사람 이름인지 나타내는 0 또는 1의 값을 가진 9개의 출력값이 나옵니다.

하지만 이 방법은 잘 작동하지 않으며 두 가지 문제점이 있습니다.

**Problems:**
- Inputs, outputs can be different lengths in different examples.
- Doesn't share features learned across different positions of text.

첫 번째는 **입력과 출력은 다른 길이와 다른 예시가 될 수 있습니다.** 따라서 모든 단일 예시가 같은 입력 길이 $T_x$이거나 같은 $T_y$를 가지지 않고 모든 문장은 최대 길이가 아닙니다. 아마 입력에 임의의 값이나 0을 채워 넣어서 최대 길이로 동일하게 맞출 수 있지만 여전히 좋은 표현은 아닙니다.

두 번째이면서 더 심각한 문제는 이러한 나이브 **신경망 아키텍처는 텍스트의 서로 다른 위치에서 학습한 기능을 공유하지 않습니다.** 특히 신경망이 Harry라는 단어를 학습하여 사람 이름의 일부라는 신호를 위치 1에서 준다면 다른 위치인 $x^{< t >}$에서 Harry가 나올 경우 자동으로 사람 이름일 가능성이 높다고 추론하는 것이 더 좋을 겁니다.

이는 이미지의 한 부분을 학습하여 이미지의 다른 부분을 생성하길 원했던 합성곱 신경망에서 본 것과 유사하며 시퀀스 데이터에서도 유사한 효과를 기대합니다. 그리고 자신감을 갖고 본 것과 유사하게 더 좋은 표현은 모델의 매개변수 수를 줄일 수도 있습니다.

따라서 이전에 이들 각각은 10,000차원 원-샷 벡터이며 입력 크기가 최대 단어 수 곱하기 1만인 아주 큰 입력 레이어입니다. 첫 번째 계층의 가중치 행렬은 엄청난 수의 매개변수를 가지게 됩니다.

이어서 설명할 **순환 신경망recurrent neural networks**은 이러한 단점이 없습니다. 순환 신경망은 무엇일까요? 한번 만들어 봅시다.

#### Recurrent Neural Networks

![image](https://user-images.githubusercontent.com/55765292/187850150-38fa65cb-a2b2-4d0d-81e4-aa6d444d0412.png)

좌에서 우로 문장을 읽는다면 처음 읽는 단어를 $x^{<1>}$이라고 가정하고 첫 번째 단어를 신경망 레이어에 넣습니다. 첫 신경망의 히든 레이어가 있고 출력값을 예측하는 신경망이 있을 수 있습니다. 사람 이름의 일부분인지 아닌지를 예측합니다.

순환 신경망이 하는 것은 문장의 두번째 단어 $x^{<2>}$를 읽을 때 $\hat{y}^{<2>}$를 예측할 때 $x^{<2>}$만 사용하는 것이 아니라 첫 번째 단계에서 연산한 정보의 일부도 가져옵니다.

구체적으로 첫 번째 단계의 비활성화 값이 두 번째 단계에 전달됩니다. 그리고 다음 시점에 순환 신경망은 세 번째 단어 $x^{<3>}$를 입력하여 $\hat{y}^{<3>}$을 예측하고 이런 식으로 계속 해서 마지막 시점은 $x^{< T_x >}$를 입력해 $\hat{y}^{< T_y >}$를 예측합니다.
  
적어도 이 예제에서는 $T_x$와 $T_y$가 동일하며 다르다면 아키텍처가 일부 변경될 겁니다. 따라서 각각의 단계에 전달하는 순환 신경망은 이를 사용하기 위해 다음 단계까지 활성화 됩니다.

그리고 이 모든 것을 시작하기 위해서 시간 0에 가짜 활성화도 만들겠습니다. 보통 영벡터입니다. 일부 연구원들은 무작위로 $a^{<0>}$을 초기화합니다. $a^{<0>}$을 초기화하는 다른 방법이 있지만 시간 0에 가짜 활성화로 영벡터을 실제로 사용하는 경우가 가장 일반적입니다.

이를 통해 신경망에 대한 입력을 얻을 수 있습니다. 일부 연구 논문이나 책에서는 모든 단계에 $x$와 $\hat{y}$을 입력하는 오른쪽과 같은 다이어그램으로 그린 신경망의 유형을 볼 수 있습니다.

때로는 $< t >$ 인덱스가 있을 수도 있고 순환 연결을 표시하기 위해 레이어가 셀에 피드백하는 루프를 그리기도 합니다. 경우에 따라 음영 처리된 상자를 그려 표시하고 한 단계의 지연 시간을 나타냅니다.

개인적으로 이 순환 다이어그램을 해석하는 것이 훨씬 더 어려워서 왼쪽에 있는 것과 같은 펼쳐진 다이어그램을 그리겠지만 교과서나 연구 논문에서 오른쪽 다이어그램 같은 것을 보게 된다면 왼쪽 다이어그램처럼 펼치는 것이 해당 다이어그램의 실제 의미라는 것을 또는 제가 생각하던 방식이라는 것을 보시게 될 겁니다.

순환 신경망은 왼쪽에서 오른쪽으로 데이터를 스캔합니다. 각 시간 단계에서 사용하는 매개변수는 공유됩니다.

다음에 더 자세한 내용을 설명할 매개변수 세트가 있지만 $x^{<1>}$에서 히든 레이어로 연결을 관리하는 매개변수는 매개변수 세트 $W_{ax}$이며 이 매개변수는 각 단계에서 사용하는 매개변수와 동일합니다. 여기서도 $W_{ax}$를 쓸 수 있을 것 같습니다.

비활성화, 수평 연결은 모든 시간 단계에서 사용되는 일부 매개변수 세트 $W_{aa}$와 동일한 매개변수 $W_{aa}$와 출력 예측을 제어하는 합계 $W_{ya}$에 의해 제어됩니다.

다음 줄에 이 매개변수가 어떻게 작동하는지 설명하겠습니다. 즉, 세번째 순환 신경망에서 이것이 의미하는 것은 $\hat{y}^{<3>}$을 예측할 때 $x^{<3>}$뿐만 아니라 $x^{<1>}$과 $x^{<2>}$의 정보도 얻을 수 있다는 것입니다. $x^{<1>}$의 정보가 $\hat{y}^{<3>}$의 예측을 돕는 이 경로로 전달되기 때문입니다.

RNN의 한가지 약점은 RNN은 앞서 나온 정보만을 사용해서 예측을 한다는 것입니다. 특히 $\hat{y}^{<3>}$를 예측할 때 $x^{<4>}$, $x^{<5>}$, $x^{<6>}$ 등에 대한 정보를 사용하지 않습니다.

> He said, "Teddy Roosevelt was a great President."

> He said, "Teddy bears are on sale!"

이것은 문제가 되는데 왜냐하면 만약 여러분에게 그는 테디 루즈벨트가 훌륭한 대통령이라고 말했습니다 라는 문장이 주어지면 Teddy라는 단어가 사람의 이름의 일부인지 결정하기 위해서 첫 두 단어의 정보뿐만 아니라 문장 중 그 뒤에 있는 단어들의 정보를 아는 것도 매우 유용하기 때문입니다.

Teddy는 그들이 판매하는 테디 베어를 말했다. 라는 문장의 첫 세 단어만 고려하면 테디라는 단어가 사람의 이름의 일부인지 확실히 알 수 없습니다.

첫 번째 예제는 그렇습니다. 두 번째 예제는 그렇지 않습니다. 하지만 처음 세 단어만 보면 차이를 구별할 수 없습니다.

따라서 이 특정 신경망 구조의 한 가지 한계는 특정 시점의 예측이 시퀀스에 이전에 입력된 입력값이나 정보를 사용하지만 그 뒤에 나온 정보는 사용하지 않는다는 것입니다.

이 문제는 양방향 순환 신경망이나 BRNN에 대해 추후에 다루겠습니다. 지금으로선 이 단순한 단방향 신경망 아키텍처가 핵심적인 개념을 설명하는데 충분할 것입니다.

예를 들어 $\hat{y}^{<3>}$의 예측이 시퀀스의 앞부분의 정보와 뒷부분의 정보를 모두 사용할 수 있도록 하려면 나중에 이러한 아이디어를 빠르게 수정해야 합니다.

이제 이 신경망이 수행하는 계산이 무엇인지 명백하게 쓰겠습니다.

#### Forward Propagation

![image](https://user-images.githubusercontent.com/55765292/187852151-1fb2ca35-7fdc-4a3c-9617-1bdcec964174.png)

이것은 신경망 그림의 정리된 버전입니다. 앞서 말씀드렸듯이 일반적으로 시작한 입력 $a^{<0>}$은 영벡터와 같습니다. 다음으로 이것이 순전파의 모습입니다. $a^{<1>}$을 계산하려면 활성화 함수 $g$에 $(W_{aa} \times a^{<0>} + W_{ax} \times x^{<1>} + bias)$을 곱하여 계산합니다. 저는 $b_a$라고 쓰겠습니다.

시간이 1일 때의 예측값인 $\hat{y}^{<1>}$을 계산하기 위해서 어떤 활성화 함수일 수도 있고 위의 함수와는 다른 활성화 함수일 수도 있지만 $(W_{ya} \times a^{<1>} + b_y)$를 곱합니다.

해당 예시와 같은 이러한 행렬의 기판을 위해 사용하려는 표기 규칙은 $W_{ax}$입니다. 두 번째 인덱스는 이 $W_{ax}$가 어떤 $x$와 같은 양과 곱해진다는 뜻이며 $a$와 같은 양을 계산하기 위해 사용된다는 것을 의미합니다.

유사하게 $W_{ya}$는 $y$와 같은 양을 계산하기 위해 $a$와 같은 양을 곱하는 것을 볼 수 있습니다. RNN을 선택했을 때의 활성화 함수의 사용이나 활성화를 계산하는 방법은 보통 tanh 함수이고 실제로 tanh가 꽤 일반적인 선택임에도 가끔 ReLU가 사용되기도 합니다.

그리고 기울기 소실 문제를 방지하기 위한 다른 방법이 있지만 추후에 말씀드리겠습니다. 출력값 $y$가 무엇인지에 따라 이진 분류 문제인 경우 Sigmoid 활성화 함수를 사용하고 다중 분류 문제에서는 소프트맥스가 될 수 있습니다.

즉 활성화 함수의 선택은 출력값 $y$의 유형이 무엇인지에 달려있습니다. 그래서 $y$가 0과 1이었던 개체명 인식 작업의 경우 두 번째 g가 Sigmoid 활성화 함수일 수 있습니다.

그런 다음 이것이 다른 활성화 함수인지 식별하고 싶다면 $g_2$를 쓸 수 있지만 저는 보통 그렇게 하지 않습니다. 그리고 더 일반적으로 시간 t에서 $a^{< t >}$는 g에 $(W_{aa} \times a^{< t-1 >} + W_{ax} \times x^{< t > } + b_a)$를 곱한 값이 될 것이고 $\hat{y}^{< t >}$는 활성화 함수는 다를 수 있지만 $g$에 $(W_{ya} \times a^{< t >} + b_y)$를 곱하면 됩니다.

그래서 이 방정식은 신경 네트워크에서 모두 영벡터 $a^{<0>}$로 시작하는 순전파로 정의됩니다. 여기서 $a^{<0>}$과 $x^{<1>}$을 사용하여 $a^{<1>}$ 과 $\hat{y}^{<1>}$ 을 계산하고 $x^{<2>}$와 $a^{<1>}$을 사용하여 $a^{<2>}$ 와 $\hat{y}^{<2>}$을 계산하며 그림의 왼쪽에서 오른쪽 방향으로 순전파 전달을 진행할 수 있습니다.

이제 좀 더 복잡한 신경망을 개발하기 위해서 이 표기법을 가지고 조금 단순화하려고 합니다.

#### Simplified RNN notation

![image](https://user-images.githubusercontent.com/55765292/187853885-0762fe26-5095-448f-acb5-579b0cd25d97.png)

제가 할 것은 실제로 사용하는 것입니다. 조금 단순화하기 위해서 이것을 가지고 조금 더 간단한 방법으로 쓰겠습니다. 그래서 저는 이것을 $a^{< t >} = g(W_a[a^{< t-1 >}, x^{< t >}] + b_a)$ 라고 쓰겠습니다.

밑줄 그은 왼쪽과 오른쪽의 근본적인 양은 동등해야 합니다. 우리가 $W_a$를 정의하는 방법은 이 행렬 $W_{aa}$와 이 행렬 $W_{ax}$를 나란히 놓아서 다음과 같이 수평적으로 쌓아 놓는 것입니다. 이것이 $W_a$가 될 것입니다.

예를 들어, a가 100차원이고 x가 10,000차원이라면 $W_{aa}$는 100 * 100차원 행렬이 되고 $W_{ax}$는 100 * 10,000차원 행렬이 될 것입니다.

우리가 이 두 행렬을 함께 쌓아감에 따라 이쪽은 100차원이 될 것입니다. 이건 100이 될 것이고 이것은 1만 개의 엘리먼트가 될 겁니다. 따라서 $W_a$는 100 * 10100차원 행렬이 될 겁니다. $W_{ax}$는 아주 넓은 행렬이기에 왼쪽에 있는 이 다이어그램은 스케일을 위해 그려지지 않은 것 같습니다.

이 표기법이 의미하는 바는 단지 두 개의 벡터를 함께 쌓아 놓은 것입니다. 표기법을 사용해서 표시하면 100차원의 벡터 $a^{< t-1 >}$를 $x^{< t >}$ 위에 쌓아서 10100차원 벡터가 됩니다.

잘 된다면 이 행렬과 이 벡터를 곱하면 원래의 수량을 되찾게 될 겁니다. 왜냐하면 이 행렬의 $[W_{aa}, W_{ax}]$를 $[a^{< t-1 >}, x^{< t >}]$ 벡터로 곱하면 $W_{aa} \times a^{< t-1 >} + W_{ax} \times x^{< t >}$와 같고, 이는 이전에 여기 있던 것과 똑같기 때문입니다.

이 표기법의 장점은 $W_{aa}$와 $W_{ax}$라는 두 개의 매개변수 행렬을 사용하기 보다는 하나의 매개변수 행렬 $W_a$로 압축할 수 있으며 더 복잡한 모델을 개발할 때 표기법을 단순화한다는 것입니다.

그리고 이와 유사한 방법으로 이것을 약간 다시 쓰겠습니다. $W_y \times a^{< t >} + b_y$로 써서 $W_y$와 $b_y$로 두 개의 기판으로 표기할 수 있습니다 이는 계산하는 입력값 양의 유형을 나타냅니다.

따라서 $W_y$는 가중치 행렬이나 $y$와 같은 양의 계산을 나타냅니다. 여기 위에 $W_a$와 $b_a$는 활성화 출력값 양과 같은 계산을 위한 이 매개변수들이 어디에 있는지 나타냅니다.


### Backpropagation Through Time

RNN의 기본 구조에 관해서는 이미 배우셨습니다. 이번에는 순환 신경망 내에서 역전파가 어떻게 작동하는지 볼 수 있습니다.

일반적으로 프로그래밍 프레임워크에서 이러한 기능을 구현할 때 프로그래밍 프레임워크는 종종 역전파를 자동으로 처리합니다. 하지만 RNN 내 역전파 작동 방식을 알고 있다면 유용할 것입니다.

한번 자세히 살펴봅시다.

#### Forward Propagation and Backpropagation

![image](https://user-images.githubusercontent.com/55765292/187867130-76b569b2-1118-4f1e-8214-776e51a8ad67.png)

순전파의 경우 이렇게 활성화되는 것을 신경망의 왼쪽에서 오른쪽으로 이러한 활성화를 계산하여 모든 예측을 출력합니다. 역전파는 여러분이 이미 짐작하셨겠지만 기본적으로 순전파의 반대 방향으로 역전파 계산을 진행하게 됩니다.

---

![image](https://user-images.githubusercontent.com/55765292/187867419-360d6d19-5d54-40f8-b315-0e9a1e6c5a53.png)

그럼 순전파 계산을 해보겠습니다. 이 입력 시퀀스는 $x^{<1>}, x^{<2>}, x^{<3>}, ..., x^{< T_x>}$ 까지 제공됩니다. 그런 다음 $x^{<1>}$과 $a^{<0>}$을 사용하여 $a^{<0>}$을 계산합니다.

$x^{<2>}$와 $a^{<1>}$는 $a^{<2>}$ 계산을 위해 사용되며 이어서 $a^{<3>}, ..., a^{< T_x>}$까지 계산합니다. 그리고 실제로 $a^{<1>}$ 을 계산하려면 매개변수도 필요합니다.

녹색으로 $W_a$와 $b_a$를 그려줍니다. 이것들은 $a^{<1>}$ 계산에 사용되는 매개변수입니다. 이러한 매개변수는 실제로 각 시간 단계마다 사용되며 $a^{<2>}, $a^{<3>}$등을 계산하는 데 사용됩니다.

마지막 시간 단계까지 모든 활성화는 $W_a$ 와 $b_a$에 의해 결정됩니다.

이 그래프를 계속 봅시다. 이제 주어진 $a^{<1>}$은 신경망이 첫 예측인 $\hat{y}^{<1>}$을 계산한 다음 두 번째 시간 단계인 $\hat{y}^{<2>}$와 이어서 $\hat{y}^{<3>}, ..., \hat{y}^{< T_y>}$까지 계산할 수 있습니다.

다시 다른 색깔의 매개변수를 그려보겠습니다. $\hat{y}$을 계산하기 위해서는 매개변수 $W_y$와 $b_y$가 필요하며 다른 모든 것들과 마찬가지로 이 노드로 전달됩니다. 이를 녹색으로도 그리겠습니다.

다음으로 역전파를 계산하려면 **손실 함수**가 필요합니다. 먼저 요소별 손실을 정의해 봅시다. 이는 시퀀스 내 특정 단어여야 합니다. 이것은 사람 이름이므로 $y^{< t>}$는 1입니다.

그리고 신경망은 특정 단어가 사람의 이름일 0.1의 확률을 출력합니다. 저는 이것을 표준 로지스틱 회귀 손실로 정의하며 교차 엔트로피 손실이라고도 부르겠습니다. 이전에 이진법 분류 문제를 살펴본 적이 있으신 분이라면 익숙하실 겁니다.

즉, 한 단어에서 단일 위치 또는 단일 시간 세트에서의 단일 예측값과 연관된 손실입니다. 이제 전체 시퀀스의 전체 손실을 정의하겠습니다.

$L$은 시간 1부터 $T_x$까지와 같은 전체 시간에 대한 합계로 정의됩니다. $T_y$라고하죠. 개별 시간 단계에서 이 예시의 $T_x$는 $T_y$와 같습니다. 따라서 이 위첨자가 없는 대문자 $L$은 전체 시퀀스의 손실입니다.

그래서 계산 그래프에서 주어진 $\hat{y}$의 손실을 계산하기 위해 두 번째 시간 단계의 손실과 세 번째 시간 단계의 손실 그리고 이어서 마지막 시간 단계의 손실까지 계산한 것을 고려하면 첫 번째 시간 단계의 손실을 계산할 수 있습니다.

마지막으로 전체 손실을 계산하기 위해 이것들을 모두 더하면 아래 수식에서 사용한 $L$을 얻을 수 있습니다. 이는 각 시간 단계별 손실의 합계입니다. 이것이 계산 문제이며 역전파에서 봤던 초기 예시들에서 단순히 반대방향으로 계산을 하거나 메시지를 분석하기만 하면 됩니다.

이 4가지 전파 단계의 화살표 모두를 반대로 하면 결국 이렇게 됩니다. 그러면 모든 적절한 양을 계산할 수 있습니다. 매개변수에 대해서 역을 취하고 경사 하강법을 사용하여 매개변수를 업데이트할 수 있습니다.

이 역전파 과정에서 가장 중요한 메시지나 가장 중요한 반복되는 계산은 오른쪽에서 왼쪽으로 가는 이 계산이며 이는 시간펼침 역전파라는 꽤 멋진 이름으로 불립니다.

그리고 이 이름의 원동력은 순전파를 위한 것으로 시간이 증가함에 따라 왼쪽에서 오른쪽으로 스캐닝하는데 반해 역전파는 시간을 거슬러 오른쪽에서 왼쪽으로 스캐닝하게 됩니다.

따라서 정말 멋진 이름을 붙일 수 있을 것 같습니다. 시간을 거슬러 올라가는 시간 펼침 역전파, 어떤가요? 이 출력값을얻으려면 타임머신이 필요하다는 것처럼 들립니다. 시간 펼침 역전파가 알고리즘에서 가장 멋진 이름 중 하나라고 생각합니다.

RNN에서 순전파와 역전파의 작동 방식을 이해하셨길 바랍니다. 지금까지는 입력 시퀀스의 길이와 출력 시퀀스의 길이가 같은 RNN에서 주된 동기 부여 예제만 살펴보았습니다.

다음에는 훨씬 광범위한 RNN 아키텍처를 보여 드리겠습니다. 더 광범위한 애플리케이션 세트에 대해
알아보겠습니다.
