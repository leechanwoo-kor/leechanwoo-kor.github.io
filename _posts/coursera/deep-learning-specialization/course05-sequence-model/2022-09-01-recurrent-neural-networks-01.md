---
title: "[Ⅴ. Sequence Models] Recurrent Neural Networks (1)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Deep Learning
  - Facial Recognition System
  - Convolutional Neural Network
  - Tensorflow
  - Object Detection and Segmentation
toc: true
toc_sticky: true
toc_label: "Recurrent Neural Networks (1)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/187809649-f4918caf-ae96-4f46-a0cf-42ba990450d9.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Recurrent Neural Networks

## Recurrent Neural Networks

### Why Sequence Models?

이번에는 딥러닝에서 가장 흥미로운 분야 중 하나인 시퀀스 모델에 관해 보겠습니다. 순환 신경망 네트워크나 RNN과 같은 모델은 음성 인식, 자연어 처리 등의 영역을 변형시켰습니다.

그리고 이런 모델을 직접 만드는 방법을 보겠습니다. 먼저 시퀀스 모델이 유용한 몇 가지 예를 살펴보겠습니다.

![image](https://user-images.githubusercontent.com/55765292/187811228-78be8148-94c5-4e65-b4ba-d2b4483e4e4c.png)

**음성 인식**에서 입력 오디오 클립 X가 주어지고 이를 옮겨적은 텍스트 Y에 매핑하도록 요청받습니다. 여기의 입력과 출력은 모두 시퀀스 데이터입니다.

왜냐하면 X는 오디오 클립이므로 시간이 지남에 따라 재생되고 Y는 단어 시퀀스이기 때문입니다. 따라서 순환 신경망 네트워크와 다른 종류들과 같은 시퀀스 모델이 잠시 후에 음성 인식에 매우 유용했다는 걸 알게 될 겁니다.

**음악 생성**은 시퀀스 데이터 문제의 또 다른 예입니다. 이 경우 출력 Y만 시퀀스이고 입력은 빈 세트이거나 또는 단일 정수일 수 있으며 어쩌면 생성하려는 음악의 장르나 원하는 음악의 처음 몇 음을 의미합니다. 하지만 여기서 X는 아무것도 아니거나 정수일 수도 있고 출력 Y는 시퀀스입니다.

**감성 분류**에서 입력 X는 시퀀스입니다. "이 영화에는 좋은 부분이 없다"라는 입력 구문이 주어지면 이 리뷰는 별이 몇 개일 것 같습니까?

시퀀스 모델은 **DNA 시퀀스 분석**에도 아주 유용합니다. 그래서 여러분의 DNA는 4개의 알파벳 A, C, G, T를 통해 나타납니다. 따라서 해결을 도울 수 있는 시퀀스 모델인 주어진 DNA 시퀀스로 DNA 시퀀스의 어떤 부분이 단백질과 일치하는지 알 수 있습니다.

**기계 번역**에서 여러분에게 다음과 같은 입력 문장이 주어지고 Voulez-vous chanter avec moi? 다른 언어로 번역을 출력해 달라는 요청을 받습니다.

**비디오 활동 인식**에서는 비디오 프레임 시퀀스가 주어지고 활동을 인식하도록 요청받을 수 있습니다. 

그리고 **개체명 인식**에서는 한 문장이 주어지고 문장 내 사람을 식별하도록 요청받을 수 있습니다. 따라서 이러한 모든 문제는 훈련 세트로 레이블 데이터 X, Y를 사용하여 지도 학습으로 해결할 수 있습니다.

하지만 이 예제 목록에서 알 수 있듯이 많은 다양한 유형의 시퀀스 문제들이 있습니다. 어떤 경우에는 입력 X와 출력 Y가 모두 시퀀스이며 그러한 경우 X와 Y의 길이가 다르거나 아니면 이 예나 이 예에서 X와 Y의 길이가 같은 경우도 있습니다.

그리고 이러한 예들 중 일부는 X나 반대되는 Y만 시퀀스입니다. 따라서 적용할 수 있는 시퀀스 모델에 대해 학습하기 때문에 이러한 모든 다른 설정에 적용할 수 있습니다.

따라서 이런 시퀀스 문제를 정의하기 위해 사용하는 문제를 레이블링할 수 있습니다. 그럼 정의를 내리기 시작하는 것으로 넘어가겠습니다. 흥미로운 표기법 세트에 대한 감각을 배우셨으면 합니다.


### Notation

시퀀스 모델을 적용할 수 있는 다양한 애플리케이션을 살펴보았습니다. 이러한 시퀀스 모델을 구축하기 위해 사용할 표기법 정의부터 시작해 보겠습니다

![image](https://user-images.githubusercontent.com/55765292/187812055-b3707989-477e-46f6-967b-64521695cdb7.png)

동기 부여 예시로서 다음과 같은 문장 입력을 위한 시퀀스 모델 구축을 원한다고 가정합시다.

해리 포터와 헤르미온느 그레인저는 새로운 주문을 만들었습니다.
{: .text-center}
Harry Potter and Hermione Granger invented a new spell.
{: .text-center}

그리고 이 캐릭터들은 J.K.롤링의 소설인 해리 포터 시리즈에서 가져왔습니다. 이 문장 내 인물의 이름들이 어디에 있는지 자동으로 알려주는 시퀀스 모델을 만들고자 한다고 가정해 봅시다.

이는 **개체명 인식name entitiy recognition**이라 불리는 문제이며 검색 엔진에 사용됩니다. 예를 들어 뉴스 기사에 언급된 모든 사람의 지난 24시간 뉴스를 인덱싱하여 올바르게 인덱싱할 수 있도록 합니다.

그리고 인식 시스템에 들어가는 이름은 여러 유형의 텍스트로 사람 이름, 회사명, 시간, 위치, 국가명, 화폐 단위 등을 찾는 데 사용될 수 있습니다.

이제 이 입력값 x가 주어지면 모델이 작동하기를 원한다고 가정합시다. 입력 단어당 하나의 출력값이 있는 y를 조작해 타깃 출력값은 y를 설계하여 사람 이름의 일부라는 것을 알려줍니다. 그리고 기술적으로 이것이 최적의 출력 표시는 아니며 사람 이름의 한 부분이 아닌 알길 원하는 사람 이름의 시작과 끝이 문장 어디에 있는지 알려주는 더 복잡한 표시가 있습니다.

해리 포터는 여기서 시작하고 여기서 끝나며 여기서 시작하고 여기서 끝나죠. 하지만 이 동기 부여 예시의 경우 더 간단한 출력 표시로 계속 진행하겠습니다.

입력은 아홉 단어의 시퀀스입니다. 이러한 아홉 단어를 표시하는 아홉 개의 기능 세트가 생길 것이고 위치와 시퀀스에 들어가는 인덱스로는 x를 사용한 다음 윗첨자 꺾쇠괄호 1, 2, 3과 계속하여 다른 위치에 인덱싱하기 위해 9까지 쓰겠습니다.

시퀀스 중간의 위치에 인덱싱하기 위해 인덱스 t가 있는 $x^{< t >}$를 사용하겠습니다. 그리고 t는 시퀀스가 일시적이든 아니든 일시적인 시퀀스이라는 것을 나타냅니다. 인덱스 t를 사용하여 시퀀스 내의 위치에 인덱싱하겠습니다.

그리고 유사하게 출력의 경우 이러한 출력을 y로 1, 2, 3부터 9까지로 인덱싱 하겠습니다. 그리고 $T_x$를 사용하여 입력 시퀀스의 길이를 나타내겠습니다. 이 경우 아홉 단어이므로 $T_x$는 9와 같습니다.

그리고 $T_y$를 사용하여 출력 시퀀스의 길이를 나타내겠습니다. 이 예시에서 $T_x$는 $T_y$와 같지만 지난번에 봤듯이 다를 수도 있습니다.

따라서 여러분은 사용한 표기법을 기억해야 하며 $x^{(i)}$ 써서 i 훈련 예시를 표시합니다. 따라서 TIF 엘리먼트나 훈련 예시 i의 시퀀스 내 TIF 엘리먼트를 참조하려면 이 표기법을 사용하고 만약 $T_x$가 시퀀스의 길이라면 훈련 세트 내 다른 예시의 길이가 다를 수 있습니다.

따라서 $T_x^{(i)}$는 훈련 예시 i에 대한 입력 시퀀스 길이가 됩니다.

그리고 유사하게 $y^{(i)< t > }$는 예시에 대한 i의 출력 시퀀스 내의 TIF 엘리먼트를 의미하며 $T_y^{(i)}$는 i 훈련 예시 내의 출력 시퀀스의 길이가 됩니다.

따라서 이 예제에서 $T_x^{(i)}$는 9가 되며 15 단어 문장의 훈련 예시와 상당히 다를 것이며 15와 근접할 겁니다.

이제 NLP, 자연어 처리를 처음으로 다루겠습니다. 문장에서 개별 단어를 표현하는 방법에 대해 이야기해 봅시다.

#### Representing Words

![image](https://user-images.githubusercontent.com/55765292/187812103-57397301-6fbe-4051-92cc-7eafd5b18214.png)

![image](https://user-images.githubusercontent.com/55765292/187812125-7c3cca1e-38dd-49ca-9471-08fd171172df.png)

문장에서 단어를 표현하기 위해 가장 먼저 해야 할 일은 단어 집합을 만드는 것입니다. 때때로 **사전dictionary**이라고도 부르며 이 말인 즉슨 표현에 사용할 단어 목록을 만든다는 의미입니다.

따라서 어휘의 첫 번째 단어는 사전의 첫 번째 단어가 될 것입니다. 두 번째 단어는 Aaron이며 조금 더 아래에 and, 내려가다 보면 Harry, 최종적으로 Potter, 계속 내려가다보면 마지막 단어로 Zulu가 나올 수 있습니다.

따라서 a가 첫 번째, Aaron이 두 번째 단어이고 제 사전에서 and는 위치 색인 367에 있습니다. Harry는 4,075번째 Potter는 6,830번째 Zulu는 사전의 마지막 단어로 아마 10,000번째쯤일 겁니다. 따라서 이 예에서 10,000단어 크기의 사전을 사용하고자 합니다.

현대 NLP 애플리케이션에 비하면 꽤 작습니다. 상용 애플리케이션의 경우 비주얼 크기의 상용 애플리케이션의 경우 3만~5만 정도가 더 일반적이고 10만은 흔치 않습니다.

몇몇 대규모 인터넷 기업은 100만 단어나 심지어 그 이상인 사전을 사용할 겁니다. 하지만 대부분의 상용 애플리케이션은 3만에서 5만 단어를 사용합니다. 하지만 숫자가 깔끔하기 때문에 1만 단어를 사용하겠습니다.

1만 단어 사전을 골랐을 때 사전을 만드는 한 가지 방법은 훈련 세트를 살펴보고 빈도수 상위의 단어 1만 개를 찾는 것입니다. 또한 몇몇 온라인 사전들을 살펴보고 저장된 영어 중 가장 일반적인 단어 1만 개를 살펴보는 것입니다.

그런 다음 이러한 단어 각각을 나타내는 **원-핫one-hot** 표현을 사용합니다. 예를 들어 Harry를 나타내는 $x^{<1>}$은 4075가 사전에서의 Harry의 위치이기 때문에 해당 위치의 1을 제외한 모든 0을 가진 벡터입니다.

$x^{<2>}$ 역시 유사하게 6830에서 1을 제외한 모든 0을 가진 벡터이며 모든 곳에 0이 있습니다. and는 367번째에 위치하므로 $x^{<3>}$는 367번째만 1이고 나머지가 0인 벡터입니다.

사전이 1만개 단어라면 이들 각각은 10,000차원 벡터가 됩니다. 그리고 a는 어떤 사전이든 첫 번째 단어이기 때문에 a에 해당하는 $x^{<7>}$은 벡터 1입니다. 사전의 첫 번째 엘리먼트이고 나머지는 0입니다.

따라서 이 표현에서 문장의 t번째 $x^{< t >}$는 원-핫 벡터입니다. **원-핫one-hot**인 이유는 딱 하나만 1이고 나머지는 0이기 때문이며 이 문장의 9개 단어를 나타내려면 9개가 있어야 하기 때문입니다.

목표는 이렇게 표현된 x를 시퀀스 모델을 사용하여 타깃 출력 y로 매핑하는 것을 학습하는 것입니다. 지도 학습 문제로 진행할 것이고 x와 y를 포함하는 데이터 테이블을 제공하겠습니다.

마지막으로  단어 집합에 없는 단어가 나오면 어떻게 할 것인가입니다. 답을 드리자면, 새로운 토큰 혹은 단어 집합에 없는 단어를 표현하기 위해 UNK로 표시되는 모르는 단어라 불리는 가짜 단어를 만들면 됩니다.
