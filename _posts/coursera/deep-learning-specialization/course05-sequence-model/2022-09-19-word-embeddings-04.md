---
title: "[Ⅴ. Sequence Models] Natural Language Processing & Word Embeddings (4)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Natural Language Processing
  - Long Short Term Memory (LSTM)
  - Gated Recurrent Unit (GRU)
  - Recurrent Neural Network
  - Attention Models
toc: true
toc_sticky: true
toc_label: "Natural Language Processing & Word Embeddings (4)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/187809649-f4918caf-ae96-4f46-a0cf-42ba990450d9.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Natural Language Processing & Word Embeddings

## Learning Word Using Word Embeddings: Word2Vec & GloVe

### Negative Sampling

**스킵-그램 모델**로 지도 학습 문제를 만드는 방법을 보았습니다. 그래서 우리는 맥락에서 타깃으로 매핑하고 이를 통해 유용한 단어 임베딩을 학습할 수 있습니다. 하지만 이것은 소프트맥스 객체의 계산 속도가 느리다는 단점이 있습니다.

이번에는 스킵-그램 모델과 유사한 것을 할 수 있지만 훨씬 더 효율적인 학습 알고리즘인 **네거티브 샘플링negative sampling**이라는 수정 학습 문제를 살펴보겠습니다. 어떻게 할 수 있는지 봅시다.

#### Defining a New Learning Problem

![image](https://user-images.githubusercontent.com/55765292/190996827-912e2e76-bb2c-42bc-b039-8796ecbffeac.png)

여기서 다루는 알고리즘을 통해서 새로운 지도 학습 문제를 만들고자 합니다. 그리고 문제는 orange와 juice와 같은 단어 쌍이 상황에 맞는 맥락 타깃 쌍인지 예측하는 것입니다. 이 예에서 orange juice는 긍정적인 예시였습니다. orange와 king은 어떨까요? 이건 부정적인 예시니
타깃에 0을 적겠습니다.

그래서 우리가 할 일은 실제로 맥락과 타깃 단어를 샘플링하는 것입니다. 이 경우에는 orange와 juice가 있고 레이블 1과 이를 연관시켜서 중간에 단어를 두겠습니다. 그런 다음 긍정적인 예제를 생성해냄으로써 이전과 정확히 동일한 방식으로 긍정적인 예제가 생성됩니다.

맥락 단어를 샘플링하고 10개 단어 내외에서 타깃 단어를 한 개 고릅니다. 이렇게 해서 orange, juice, 1로 이 표의 첫 행을 만들 수 있습니다. 부정적인 예를 하나 생성하기 위해서 같은 맥락 단어를 선택하고 사전에 있는 단어를 무작위로 고릅니다. 이 경우에 무작위로 단어 king을 선택했고 0으로 레이블링합니다.

그리고 orange와 사전에서 임의의 단어를 하나 더 골라봅시다. 무작위로 고른 단어가 orange라는 단어와 연관되지 않을 것이라는 가정 하에 orange, book, 0입니다. 다른 걸 더 골라보겠습니다.

orange, 어쩌면 우연히도 the을 고르고, 0입니다. 그리고 orange, 그리고 어쩌면 우연히 of를 고르고 여기에 0을 넣습니다. 단어가 실제로 orange 옆에 나타나더라도 모든 것이 0으로 레이블링된 것을 알게됩니다.

요약하면 이 데이터 세트를 만드는 방식은 맥락 단어를 선택한 다음 그런 다음 타깃 단어를 선택하면 이것이 이 표의 첫 번째 행이고 긍정 예시를 보여주죠. 따라서 맥락, 타겟, 그리고 그 레이블을 1로 지정합니다.

횟수를 예를 들어, k번이라고 하면 같은 맥락 단어를 사용해서 king, book, the, of 등 무작위 단어를 사전에서 뽑아 0으로 레이블링하면 이것들이 부정적 예시가 됩니다. 우연히 우리가 사전에서 무작위로 뽑은 가령 10개 내외의 단어가 맥락 단어 orange 옆에 나타나도 괜찮습니다.

그런 다음 학습 알고리즘이 이 단어 쌍 x를 입력하고 출력 y를 위한 타깃 레이블을 예측하는 지도 학습 문제를 생성합니다. 그래서 문제는 orange와 juice 같은 한 쌍의 단어들이 실제로 함께 나타나는 것 같습니까? 서로 가까운 두 단어를 샘플링하여 이 두 단어를 얻은 것 같습니까? 아니면 텍스트에서 한 단어로 가져온 것 같은가요? 사전에서 무작위로 선택된 하나의 단어인가요?

샘플링한 단어 쌍들을 이 두 가지 유형의 분포로 구별하는 것이 중요합니다. 이런 방식으로 훈련 세트를 생성합니다. k를 선택하는 방법은 소규모 데이터 세트의 경우 k를 5~20으로 할 것을 권장합니다. 아주 큰 데이터 세트가 있다면 더 작은 k를 선택합니다. 데이터 세트가 클 경우 k는 2~5이고 작은 데이터 세트인 경우 k값은 더 작습니다.

이 예에서는 k=4를 사용하겠습니다. 다음으로, x에서 y로 매핑하는 것을 학습하는 지도 학습 모델을 설명하겠습니다.

#### Model

![image](https://user-images.githubusercontent.com/55765292/190997452-411f1b08-69c1-4189-a889-321619027398.png)

이전에 본 소프트맥스 모델이 있습니다. 그리고 여기 이전 그림에서 얻은 훈련 세트가 있습니다. 다시 말하면, 이것은 새로운 입력 x이고 이것은 여러분이 예측하려는 y값이 될 겁니다. 모델을 정의하기 위해 맥락 단어는 c로 가능한 타깃 단어는 t로 표기하고 y를 사용하여 0, 1을 나타내며 이것은 맥락 타겟 쌍입니다.

이제 로지스틱 회귀 모델을 정의하겠습니다 c, t 쌍이 주어졌을 때 y가 1일 확률은 기본적으로 이를 회귀 모델로 만들 것이지만 $\sigma(\theta_t^T e_c)$와 같습니다. 따라서 매개 변수는 전과 유사하며 각각의 가능한 타깃 단어를 위한 하나의 매개 변수 벡터 세타를 갖게 되고 그리고 별도의 매개변수 벡터, 즉 임베딩 벡터는 각각의 가능한 맥락 단어를 위한 것입니다.

그리고 이 공식을 사용해서 y가 1일 확률을 예측합니다. 따라서 여기 k개의 예시가 있는 경우, 긍정과 부정 예시의 비율이 k 대 1이라고생각할 수 있습니다. 그래서 모든 긍정 예시에서 로지스틱 회귀 같은 모델을 훈련할 k개의 부정 예시가 있습니다. 이것을 신경 연결망으로 그리려면 입력 단어가 orange, 즉 6257번째 단어라면 입력한 원-핫 벡터가 E를 통해 임베딩 벡터 $e_6257$을 얻는 것입니다.

그리고 10,000개의 가능한 로지스틱 회귀 분류 문제를 얻게 됩니다. 이 중 하나가 타깃 단어가 juice인지 아닌지 확인하는 분류기가 될 겁니다. 그리고 또 다른 단어들이 있을 겁니다. 여기 어휘의 가능한 단어에서 예를 들어, king인지 아닌지에 대한 예측이 어딘가에 있을 수 있습니다.

따라서 10,000개의 이항 로지스틱 회귀 분류기가 있다고 생각하고 모든 이터레이션마다. 10,000개 모두를 훈련시키는 대신 5개만 훈련시킬 것입니다. 실제 타겟 단어에 반응하는 것을 훈련시킨 다음 무작위로 선택된 4개의 부정적 예시를 훈련시킬 겁니다. 이것은 k가 4와 같은 경우를 위한 것입니다.

따라서 계산 비용이 매우 비싼 10,000 크기의 대규모 소프트맥스 대신 10,000개의 이항 분류 문제로 바꾸었습니다. 각각 계산 비용이 매우 저렴하죠. 그리고 모든 이터레이션에서 그 중 5개 또는 더 일반적으로 k개의 부정적 예시와 1개의 긍정적 예시인 k+1개를 훈련시킬 겁니다.

이것이 이 알고리즘의 계산 비용이 훨씬 저렴한 이유입니다. 왜냐하면 k+1개를 업데이트하기 때문이죠. 이를 단위로 부릅시다. k+1 이항 분류 문제입니다. 10,000 크기의 소프트맥스 분류기를 업데이트하는 것보다 모든 이터레이션마다 계산하는 것이 상대적으로 저렴한 방법입니다.

이 기술을 네거티브 샘플링이라고 하는데 orange와 juice라는 긍정적인 예시와 의도적으로 부정적 예시들, 즉 네거티브 샘플링을 여러 개 만들어 이진 분류기 네 개를 더 훈련시키기 때문입니다. 그리고 모든 이터레이션 과정에서는 알고리즘을 훈련할 4개의 다른 임의의 부정적 단어를 선택합니다.

이제 마무리 하기 전에 이 알고리즘에서 더 중요한 점은 어떻게 부정적 예시들을 선택하느냐입니다.

#### Selecting Negative Examples

![image](https://user-images.githubusercontent.com/55765292/190998142-8b82f661-20aa-417e-8d7a-3ea5ad1d2ce5.png)

맥락 단어 orange를 선택한 후에 부정적 예시를 생성하기 위한 단어를 어떻게 샘플링해야 할까요? 한 가지 방법은 중간 부분에 있는 후보 타깃 단어를 샘플링하는 것입니다. 또 한 가지 방법은 말뭉치에 대한 실증적인 빈도에 따라 샘플링을 하는 겁니다. 다른 단어들이 나타나는 빈도에 따라 샘플링하세요.

그러나 여기서 문제는 the, of, and 같은 단어의 빈도가 꽤 높다는 것입니다. 또 다른 극단적인 방법은 1을 어휘 크기로 나눈 값을 사용하여 무작위로 부정적 예시를 샘플로 추출하는 것입니다. 하지만 이는 영어 단어의 분포를 대표하지 않습니다.

실증적으로 가장 잘 작동하는 방법이 경험적 빈도, 즉 영어 텍스트에서 관찰된 분포에서부터 균일한 분포까지, 두 극단 사이에서 샘플링한 휴리스틱 값을 취하는 것이라고 합니다. 그리고 단어의 빈도에 3/4을 제곱한 값에 비례하여 샘플링했습니다. 만약 $f(w_i)$가 영어나 훈련 세트 말뭉치에서 특정 단어의 빈도이며 그것에 3/4 제곱을 한다면 이것은 균일한 분포를 갖는 극한의 중간 쯤입니다.

또 다른 극단적인 방법은 훈련 세트에서 관찰된 분포를 취하는 것입니다. 저는 이것이 이론적으로 정당한지는 확신할 수 없지만 많은 연구원들이 휴리스틱을 사용하고 있고 주로 효과가 있는 것 같습니다.

요약하자면 소프트맥스 분류기에서 단어 벡터를 학습하는 방법을 살펴보았지만 이것은 계산 비용이 매우 많이 듭니다. 또한 이것을 수많은 이항 분류 문제로 바꾸어 단어 벡터를 매우 효율적으로 학습할 수 있는 방법도 보았습니다. 그리고 이 알고리즘을 실행하면 꽤 좋은 단어 벡터를 학습할 수 있습니다. 물론 딥러닝의 다른 분야에서도 마찬가지로 오픈 소스 구현이 있습니다.

또한 다른 사람들이 훈련시키고 허가된 라이센스에 따라 온라인에 공개된 단어 벡터들도 있습니다. 그래서 만약 여러분이 NLP 문제를 빨리 다루고 싶다면 다른 사람의 단어 벡터를 다운로드해서 시작하는 것이 합리적입니다. 스킵-그램 모델 설명은 여기까지입니다.

다음에는 지금까지 보여드린 것보다 더 간단할 지도 모르는 단어 임베딩 훈련 알고리즘의 다른 버전을 공유하고자 합니다. 다음에는 GloVe 알고리즘에 대해 알아보겠습니다.


### Glove Word Vectors

단어 임베딩을 계산하는 몇몇 알고리즘에 관해 배웠습니다. NLP 커뮤니티에서 모멘텀이 있는 **GloVe 알고리즘**이라는 것이 있습니다. Word2Vec 또는 스킵그램 모델만큼 많이 사용되지는 않지만 일부 마니아가 있습니다. 제가 생각하기에 그 이유는 단순함 때문입니다. 한번 자세히 살펴볼까요.

#### GloVe(Global Vectors for Word Representation)

![image](https://user-images.githubusercontent.com/55765292/191008114-56f4ea52-0897-48fa-9b08-034d848c6699.png)

GloVe는 단어를 나타내는 **전역 벡터global vector**를 말합니다. 이전에는 텍스트 말뭉치 내에서 각각에 근접하게 나타나는 두 단어를 골라서 맥락과 타깃 단어라는 단어 쌍을 샘플링했습니다. GloVe 알고리즘이 하는 일은 그것을 명시적으로 만드는 것부터 시작하는 일입니다.

자, 예를 들어 $X_{ij}$는 j라는 맥락에서 단어 i가 나타나는 횟수라고 하겠습니다. 여기서 i와 j는 t와 c의 역할을 합니다. 따라서 X_{ij}를 $X_{tc}$라고 생각하시면 됩니다.

그러나 훈련 말뭉치를 살펴보고 다른 단어 j의 맥락에서 단어 i가 나타나는 단어 수를 계산할 수 있습니다. t라는 단어는 c라는 다른 단어들의 맥락에 얼마나 자주 나타나나요? 그리고 맥락 및 타깃 단어의 정의에 따라 $X_{ij}$가 $X_{ji}$와 같을 수 있습니다.

그리고 만약 맥락과 타깃이 각각의 10개 내외의 단어 내에 나타나는지 여부로 정의한다면 대칭적인 관계가 될 것입니다. 하지만 여러분이 선택한 맥락이 항상 타깃 단어 바로 앞의 단어라면 $X_{ij}$와 $X_{ji}$는 이처럼 대칭되지 않을 수 있습니다.

하지만 GloVe 알고리즘의 목적상 두 단어가 서로 10개 내외의 단어 내에 근접하게 나타나는지의 여부로서 맥락과 타깃을 정의할 수 있습니다. 따라서 $X_{ij}$는 i와 j가 서로 얼마나 자주, 얼마나 가깝게 나타나는지 포착하는 수입니다.

#### Model

![image](https://user-images.githubusercontent.com/55765292/191008088-d54c7ce7-e362-4789-bdb4-baa03a5c7932.png)

GloVe 모델이 하는 일은 다음과 같은 것을 최적화하는 것입니다. 다시, i와 j가 t와 c의 역할을 한다고 생각해 보세요. 여러분은 이 두 단어가 얼마나 연관성이 있는지 알고 싶습니다. t와 c는 어떤 관련이 있을까요? 서로 함께 발생하는 빈도수를 측정할 때 단어 i와 j는 어떤 관계가 있을까요? 이 X_ij의 영향을 받는다면요.

그래서 우리가 하려는 것은 경사하강법을 이용해서 매개변수 세타와 e에 대해서 i와 j가 1부터 10,000까지일 때의 합을 최소화하는 것입니다. 따라서 벡터를 배우려는 것입니다. 두 단어가 함께 발생하는 빈도에 대한 좋은 예측기를 만들기 위해서요. 이제 조금 더 설명하면 $X_{ij}$가 0과 같으면 0의 로그는 정의되지 않은 음수의 무한대입니다. 그래서 우리가 하는 일은 $X_{ij}$가 0인 항에 대한 합을 원한다는 것입니다.

따라서 우리는 가중치 항을 더 두려고 합니다. $f(X_{ij}$이 가중치 항이고, $X_{ij}$가 0인 경우에는 0이 됩니다. 그리고 '0log0=0'과 같은 규칙을 사용할 겁니다. 이것이 의미하는 것은 $X_{ij}$가 0과 같으면 그 $X_{ij}$ 쌍을 굳이 합할 필요가 없단 겁니다.

그렇다면 이 log0항은 관련이 없습니다. 즉, 이 합계는 맥락 타깃 관계에서 적어도 한 번 이상 동시에 발생한 단어 쌍에 대한 합이라는 의미입니다.

$f(X_{ij})$가 하는 또 다른 일은 영어에서는 this, is, of, a, 등의 단어가 자주 나타나죠. 이 단어들은 불용어라고도 부르지만 실제로는 자주 쓰는 단어와 자주 쓰지 않는 단어 사이에는 연속체가 있습니다. 그리고 durian 같은 빈도가 드문 단어들이 있죠. 여러분이 실제로 사용하는 단어들이지만 일반적인 단어만큼 자주 언급하지는 않는 것들이죠.

따라서 가중치 인자는 의미 있는 계산량을 제공하고 durian처럼 덜 빈번한 단어에도 더 많은 가중치를 부여하는 함수지만 자주 쓰지 않는 this, is, of, a와 같은 단어에는 과대한 가중치를 부여하지 않습니다.

따라서 이러한 단어에는 많은 가중치를 부여하거나 자주 사용하지 않는 단어에는 적은 가중치를 부여하는 가중치 함수 f를 선택할 수 있는 다양한 휴리스틱이 있습니다. 이 작업을 수행하기 위한 휴리스틱으로 f를 선택하는 방법에 대한 세부 정보가 궁금하시면 이전에 참조한 GloVe 논문을 살펴보시면 됩니다.

그리고 마지막으로 이 알고리즘에 대한 재미있는 점은 세타와 e의 역할이 완전히 대칭적이라는 것입니다. 따라서 계산을 보면 거의 같은 역할을 하고 그걸 뒤집거나 정렬할 수 있다는 점에서 $\theta_i$와 $e_j$는 대칭이고 결국에는 동일한 최적화된 객체가 됩니다.

이 알고리즘을 훈련하는 한 가지 방법은 최소화 하기 위해 경사하강법에 맞춰 세타와 e를 동일하게 초기화하고 이를 모든 단어에 대해서 수행하고 평균을 얻는 것입니다. 주어진 단어 w에 대해서 경사하강법을 통해 훈련된 임베딩과 세타의 합을 2로 나눈 값과 같은 최종 e값을 얻을 수 있습니다.

왜냐하면 서로 다른 역할을 하고 이렇게 평균을 낼 수 없는 이전 영상의 모델과는 여기서의 세타와 e는 대칭적인 역할을 하기 때문입니다. GloVe 알고리즘은 여기까지입니다. 제가 생각하기에 이 알고리즘의 혼란스러운 부분은 이 공식을 보면 너무 간단해 보인다는 것입니다.

어떻게 이런 제곱 비용 함수를 최소화하는 것만으로도 의미있는 단어 임베딩을 학습시킬 수 있을까요? 하지만 실제로 효과가 있는 방법임이 밝혀졌죠. 이 알고리즘을 고안해낸 방식은 새로운 언어 모델과 같이 훨씬 복잡한 알고리즘의 역사를 기반으로 하고 있었고 나중에 Word2Vec, 스킵그램 모델이 나왔으며 그리고 이 모델이 나중에 나왔습니다. 우리는 모든 기존 알고리즘을 단순화하길 원합니다.

#### A Note on the Featurization View of Word Embeddings

![image](https://user-images.githubusercontent.com/55765292/191008046-84c28255-465c-44c9-a63e-54fc78cc4b41.png)

단어 임베딩에 관한 알고리즘에 대한 논의를 끝내기 전에 잠깐 토론해야 할 몇 가지 속성이 있습니다. 우리는 단어 벡터 학습을 위한 동기를 이 피처화 관점으로 시작했습니다.

임베딩 벡터의 첫 번째 구성요소는 성별을 나타내고, 두 번째 구성요소는 얼마나 왕족적인지, 다음으로 나이와 음식인지 등등이 있겠지라고 했습니다. 하지만 우리가 이전에 본 GloVe 알고리즘과 같이 우리가 발견한 알고리즘 중 하나를 사용해서 단어 임베딩을 배울 때 무슨 일이 일어나는가 하면 그 임베딩된 각각의 구성 요소가 해석이 가능한지 보장할 수 없다는 것입니다. 어째서일까요?

첫 번째 축이 성별이고 두 번째 축이 왕족인 공간이 있다고 가정합시다. 당신이 할 수 있는 일은 임베딩 벡터의 첫 번째 축이 성별, 왕족, 나이, 음식의 의미 축과 정렬되도록 보장하는 것입니다. 그리고 이 학습 알고리즘은 이것을 첫 번째 차원의 축으로 선택할 수 있습니다.

단어들의 맥락을 고려한다면 첫 번째 차원은 이 축이 될 것이고 두 번째 차원은 이것이 될 것입니다. 혹은 정형화되지 않거나 어쩌면 두 번째 비정형적인 축이 될 수도 있고 실제 학습하는 단어 임베딩의 두번째 요소가 될 수도 있습니다.

그리고 이것을 볼 때 여러분이 선형대수학에 대한 후속 지식이 있다면 만약 어떤 가역 행렬 A가 있다면, 이것은 $(A \theta_i)^T (A^{-T} e_j)$로 쉽게 대체될 수 있습니다. 왜냐하면 이것을 전개하면 이것은 $\theta_i^T A^T A^{-T} e_j$와 같고 중간 항을 상쇄하면 이전과 똑같기 때문입니다. 선형대수학을 따라가지 못했더라도 걱정하지 마세요.

하지만 이것은 이러한 알고리즘에서 특성을 나타내는 축이 사람이 쉽게 해석할 수 있는 축과 잘 정렬될 것이라고 보장할 수 없다는 증거입니다. 특히, 첫 번째 특성은 성별, 왕족, 나이, 음식, 비용, 크기의 조합일 수 있으며 명시인지 동사인지 다른 특성 여부도 포함될 수 있습니다.

각각의 구성 요소들과 임베딩 행렬의 개별 행을 보고 거기에 인간의 해석을 할당하는 것은 매우 어렵습니다. 하지만 이런 종류의 선형 변환에도 불구하고 우리가 유사점을 설명할 때 작업했던 평행 분포 맵은 여전히 작동합니다.

따라서 이러한 특성의 임의의 선형 변환에도 불구하고 그림 유사점에 대한 평행 분포 맵을 학습하게 됩니다. 여기까지 단어 임베딩을 배웠습니다.
