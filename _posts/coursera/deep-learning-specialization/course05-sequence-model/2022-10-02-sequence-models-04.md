---
title: "[Ⅴ. Sequence Models] Sequence Models & Attention Mechanism (4)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Natural Language Processing
  - Long Short Term Memory (LSTM)
  - Gated Recurrent Unit (GRU)
  - Recurrent Neural Network
  - Attention Models
toc: true
toc_sticky: true
toc_label: "Sequence Models & Attention Mechanism (4)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/187809649-f4918caf-ae96-4f46-a0cf-42ba990450d9.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Sequence Models & Attention Mechanism

## Sequence to Sequence Models

### Speech Recognition

가장 흥미로운 발전 중 하나는 Seq2Seq 모델이 아주 정확한 **음성 인식speech recognition**의 출현이었다는 것입니다. Speech와 같은 음성 데이터가 Seq2Seq 모델에 적용되는 방법에 직관이 여러분에게 전해지길 바랍니다.

#### Speech Recognition Problem

![image](https://user-images.githubusercontent.com/55765292/193447146-17376a20-f1f4-4f8a-9ecf-f9cc145f80af.png)

그럼, 음성 인식 문제는 무엇일까요? 오디오 클립 x가 있다면 텍스트 스크립트 y를 자동으로 찾는 것이 여러분의 일입니다. 오디오 클립의 플롯을 이렇게 그려보면 여기 가로 축은 시간이고 마이크는 공기압의 미세한 변화를 측정하며, 지금 제 목소리를 여러분이 듣는 방법은 여러분의 귀가 공기압의 작은 변화를 감지하는 것으로, 아마 스피커나 헤드셋에서 발생될 겁니다. 그리고 이런 오디오 클립은 시간에 대한 공기압으로 그려집니다.

만약 이 오디오 클립이 제가 말한 "the quick brown fox"라면 음식 인식 알고리즘이 이를 입력하여 스크립트로 출력해 주었으면 합니다. 인간의 귀조차도 있는 그대로의 파동을 처리하지 않지만 귀에는 다양한 주파수의 강도를 측정하는 물리적 구조가 있기 때문에 오디오 데이터를 위한 일반적인 사전 처리 단계는 원음 오디오 클립을 틀고 스펙트로그램을 생성하는 것입니다.

따라서 수평 축은 시간이고 수직 축은 주파수입니다. 다양한 색깔의 강도는 에너지의 양을 보여줍니다. 다양한 주파수와 시간에 따라서 들리는 소리가얼마나 클까요? 그래서 이런 종류의 스펙트로그램은, 혹은 사람들이 잘못된 출력에 대해 이야기하는 것을 들을 수 있으며 종종 오디오가 실행 알고리즘에 전달되기 전에 사전 처리 단계를 적용하는 경우가 많습니다. 사람의 귀는 이러한 사전 처리 단계와 상당히 비슷한 계산을 합니다.

따라서 음성 인식 분야에서 가장 흥미로운 동향 중 하나는 예전에는 **음소phonemes** 기반 음성 인식 시스템이 만들어지곤 했습니다. 저는 이것을 손으로 만든 세포 기본 단위라고 말하고 싶습니다 "the quick brown fox"는 음소로 표현됩니다.

좀 단순화하면, "the"는 "d"와 "e" 소리를 가지고 있고, "quick"은 "k"와 "w", "i", "k" 소리를 가지고 있으며 언어학자들은 이러한 소리의 기본 단위를 썼고 언어를 소리의 기본 단위로 조각냈습니다. "braun" 이는 공식 음소가 아니며 공식은 표기가 좀 더 복잡합니다.

하지만 언어학자들은 소리의 기본 단위인 음소로 오디오를 기록하는 것이 음성 인식을 하는 가장 좋은 방법이 될 수 있다는 가설을 세웠습니다. 하지만 Seq2Seq 딥 러닝으로 음소 표현이 더 이상 필요하지 않다는 것을 알게 되었습니다. 대신 오디오 클립을 입력하는 시스템을 만들고, 손으로 만든 표현을 사용하지 않고도 바로 글로 옮겨 출력할 수 있습니다.

이런 일을 가능하게 한 것 중 하나는 훨씬 더 큰 데이터 세트를 만드는 것이었습니다. 음성 인식에 대한 학문적 데이터 세트는 3백 시간이 될 수 있으며 학계에서는 3천 시간의 전사된 오디오 데이터 세트를 합리적인 크기로 간주합니다.

따라서 많은 연구가 이루어졌고, 데이터 세트에 관한 수많은 연구 논문은 수천개의 목소리를 가집니다. 그러나 현재 최고의 상용 시스템은 1만 시간 이상, 때로는 10만 시간 이상의 오디오를 통해 훈련되고 있습니다. 그리고 이는 훨씬 더 큰 오디오 데이터 세트로 옮겨가고 있으며, x와 y였던 오디오 데이터 세트는, 딥 러닝 알고리즘과 함께하며 음성 인식이 크게 발전했습니다.

그럼, 어떻게 음성 인식 시스템을 만들 수 있을까요? 지난번에 어텐션 모델에 관해 이야기했습니다.

#### Attention Model for Speech Recognition

![image](https://user-images.githubusercontent.com/55765292/193447159-c9c22037-9e9b-4f7b-8289-89f1b0d014dc.png)

여러분이 할 수 있는 것은 가로축에서 다양한 시간 단계의 오디오를 입력한 다음 "the quick brown fox"나 뭔가 말한 것을 글로 옮겨서 출력하려고 시도하는 어텐션 모델을 가질 수 있습니다.

#### CTC Cost for Speech Recognition

![image](https://user-images.githubusercontent.com/55765292/193447172-d3aa9f6b-4012-4fd2-9310-384d30a434b1.png)

또 다른 좋은 방법은 음성 인식을 위한 CTC 비용을 사용하는 것입니다. CTC(Connectionist Temporal Classification)는 연결주의 시계 분류를 뜻합니다.

여기 아이디어가 있는데요. 누군가 오디오 클립에서 "the quick brown fox"라고 말했다고 가정해봅시다. 같은 수의 입력 x와 출력 y로 구성된 이와 같은 신경망을 사용하려고 하며 저는 이것에 대한 단방향 RNN을 간단하게 그렸지만, 실제로 이것은 보통 양방향 LSP와 양방향 GIU 그리고 더 복잡한 모델에 사용될 겁니다.

하지만 여기 있는 시간 단계 수는 아주 크고 음성 인식 시 일반적으로 입력 시간 단계의 수가 출력 시간 단계의 수보다 훨씬 큽니다. 예를 들어 만약 10초 분량의 오디오가 있고 특징이 100Hz인, 초당 100개의 샘플이라면 10초의 오디오 클립은 결국 천 개의 입력이 됩니다.

이는 100Hz 곱하기 10초입니다. 따라서 천 개의 입력이죠. 하지만 출력 결과에 알파벳 천 개나 글자 천 개가 없을 수도 있습니다. 그렇다면 어떻게 할까요? CTC 비용 함수를 사용하면 RNN에서 `ttt`, 여기에 밑줄로 표시하는 공백이라는 특수 문자가 있으며, `h_eee___`와 띄어쓰기가 있을 수 있고 이런 식으로 작성해서 띄어쓰기 다음 `___qqq__`가 됩니다.

이것은 "the q"의 첫 부분에 대한 올바른 출력으로 간주되며, 그리고 CTC 비용 함수의 기본 규칙은 '공백'으로 구분되지 않은 반복된 문자를 축소하는 것입니다. 명확히 말하자면, 이 밑줄들을 사용하여 특별한 공백의 글자를 나타내며 띄어쓰기와는 다릅니다.

여기 "the"와 "quick" 사이에 띄어쓰기가 있습니다. 따라서 띄어쓰기를 출력해야 합니다. 하지만 공백으로 구분되지 않은 반복된 글자를 축소하여 실제로 시퀀스를 t, h, e, 공백, q로 축소합니다. 그리고 이렇게 하면 신경망이 글자 반복 통해 1,000개를 출력할 수 있습니다.

따라서 공백 문자를 많이 삽입하면 출력 텍스트 내용이 훨씬 더 짧아집니다. "the quick brown fox"라는 구절은 공백을 포함해 19자이며 신경망은 네트워크가 공백과 반복되는 문자를 삽입하게 함으로써 1000자 이상으로 강제되며 y값의 1000개 출력으로 이 19자 출력을 나타낼 수 있습니다.

음성 인식 모델의 작동 방식에 대한 감을 잡으셨길 바랍니다. 어텐션 모델 작업과 CTC 모델 작업은 이러한 시스템 구축 방법에 관해 두 가지 다른 옵션을 제시합니다. 오늘날, 생산 기술인 음성 인식 시스템을 효과적으로 구축하려면 상당한 노력이 필요하며 아주 큰 데이터 세트가 필요합니다.

하지만 이어서 훨씬 더 적거나 합리적인 양의 데이터로 더 쉽게 작업할 수 있는 키워드 감지 시스템인 트리거 단어 감지 시스템을 구축하는 방법을 공유하고자 합니다.


### Trigger Word Detection

이제 여러분은 심오한 학습과 순서 모델에 대해 많이 배웠습니다. 이번에 보시는 것처럼 하나의 그림에서 간단히 **트리거 단어trigger word** 시스템을 설명할 수 있습니다. 그러나 음성 인식 기술이 발달하면서 여러분의 목소리를 들으며 깨어날 수 있고 그것들을 트리거 워드
탐지 시스템이라고 부릅니다. 자, 어떻게 트리거 단어 시스템을 만들 수 있는지 봅시다.

#### What is Trigger Word Detection

![image](https://user-images.githubusercontent.com/55765292/193447467-a5c237ab-fa55-417f-930a-c95403ccf973.png)

트리거 워드 시스템들의 예들은 아마존 에코 (Amazon Echo)입니다. 이것은 알렉사 (Alexa) 라는 단어와 함께 깹니다. 애플 시리는 '헤이, 시리' 와 , 구글 홈은 '오케이, 구글' 과 협력하고 있습니다.

만약 당신이 말한다면, 그게 바로 '트리거' 라는 단어를 탐지한 덕분이죠 거실에 있는 아마존 에코는 거실에서 걸을 수 있고 '알렉사, 몇 시야'라고 말하거나 그리고 알렉사 (Alexa) 라는 단어에 의해 잠에서 깨어 음성 질의에 응답하게 되는 것입니다.

그래서, 트리거 단어 감지 시스템을 만들 수 있다면 어쩌면 여러분은 컴퓨터를 "활성화"라고 말함으로써 뭔가 하도록 만들 수도 있습니다. 흥미로운 프로젝트로서의 트리거 단어 종류를 사용하여 특정한 램프를 오프 (off) 하는 것을 포함합니다.

하지만 제가 여러분께 보여드리고 싶은 것은 어떻게 트리거 단어 감지 시스템을 만드는가 입니다

#### Trigger Word Detection Algorithm

![image](https://user-images.githubusercontent.com/55765292/193447490-1312224d-2567-4e02-a448-58e8d21f95a0.png)

트리거된 감지 알고리즘에 대한 문헌은 여전히 진화하고 있기 때문에 아직 폭넓은 합의가 이루어지지 않고 있습니다. 이제 여러분이 사용할 수 있는 알고리즘의 예를 하나 보여드리겠습니다. 이제, 여러분은 이것과 같은 RNN을 보았고 우리가 실제로 하는 것은 오디오 클립을 찍는 것입니다. RNN을 통과하는 $x^{<1>}, x^{<2>}, x^{<3>}$ 오디오 기능, $x^{<1>}, x^{<2>}, x^{<3>}$은 RNN을 통과하는 x3 입니다.

따라서 대상 레이블을 정의하는 작업은 모두 수행됩니다 왜 그럴까요? 오디오 클립에 있는 이 지점이 방금 완료한 사람이 있는 경우 트리거 단어, 예를 들어, Alexa 또는 또는 헤이, Siri 또는 OK 구글 그런 다음, 교육 세트에서 대상 레이블을 0이 되도록 설정할 수 있습니다.

목표 레이블을 1로 설정하기 전과 이후의 모든 것 그리고 잠시 후에, 트리거 단어가 다시 언급되고 이 시점에서 트리거 단어가 언급되었습니다. 1로 다시 설정할 수 있습니다.

이제 RNN에 대한 이러한 유형의 레이블 지정 체계가 작동할 수 있습니다. 사실, 이것은 실제로 상당히 효과적일 것입니다. 이에 대한 약간의 단점 중 하나는 매우 불균형적인 문제를 만든다는 점이다. 훈련 세트는 1보다 훨씬 더 많은 0s를 가지고 있습니다. 여러분이 할 수 있는 한 가지는 이것이 약간의 해킹이지만 좀 더 쉽게 훈련시킬 수 있다는 것입니다.

단일 시간 단계 출력 1을 사용하면 실제로 몇 개의 출력을 출력할 수 있습니다. 다시 0으로 복귀하기 전에 일정한 시간 동안 또는 고정된 시간 동안 그래서 그것은 1대 0의 비율을 살짝 벗어나게 하는 것입니다. 하지만 여기 해킹이 있습니다.

하지만 오디오 클리퍼에 있는 경우에는 트리거 단어가 언급됩니다. 그런 다음 대상 레이블을 1로 설정하고 만약 이것이 다시 한 번 말하는 것이라면 바로 RNN이 하나를 출력하기 원하는 순간이죠.

그리고 이것을 바탕으로 나는 당신이 작동하는 어떤 것을 구현할 수 있기를 바랍니다. 이 과정에서 여러분은 우리의 RNN에 대해 알게 되었습니다. GRU와 LSTM둘 다를 포함한 다음에 당신은 단어의 삽입과 단어의 표현을 배우는 방법에 대해 많은 것을 배웠습니다.
