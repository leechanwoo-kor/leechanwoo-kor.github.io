---
title: "[Ⅴ. Sequence Models] Recurrent Neural Networks (3)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Deep Learning
  - Facial Recognition System
  - Convolutional Neural Network
  - Tensorflow
  - Object Detection and Segmentation
toc: true
toc_sticky: true
toc_label: "Recurrent Neural Networks (3)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/187809649-f4918caf-ae96-4f46-a0cf-42ba990450d9.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Recurrent Neural Networks

## Recurrent Neural Networks

### Different Types of RNNs

지금까지 입력값의 수 $T_x$가 출력값의 수 $T_y$와 동일한 RNN 아키텍처를보았습니다. 다른 애플리케이션에서는 $T_x$와 $T_y$는 항상 같지 않을 수 있으며 이번에는 훨씬 더 풍부한 RNN 아키텍처들을 확인할 수 있습니다.

#### Examples of Sequence Data

![image](https://user-images.githubusercontent.com/55765292/188063231-8de94104-246e-4bb3-9dd5-269c71abb9e9.png)

입력값 x와 출력값 y가 여러 다른 유형일 수 있다는 내용의 이 그림을 기억하실 겁니다 $T_x$가 $T_y$와 항상 같아야 하는 것은 아닙니다.

특히 음악 생성 예에서 $T_x$는 길이가 0이거나 빈 세트가 될 수 있습니다. 그리고 영화 감성 분류와 같은 예시는 입력값이 시퀀스인 반면에 출력값은 1부터 5까지의 정수일 수 있습니다.

그리고 개체명 인식에서 우리가 사용하는 예는 입력값 길이와 출력값 길이가 동일하지만 다를 수도 있다는 문제가 있습니다. 둘 다 시퀀스지만 길이가 다른 것인데 예를 들면 기계 번역에서 프랑스어 문장과 영어 문장이 같은 의미를 나타내기 위한 단어의 수가 다를 수 있습니다.

그래서 이 모든 문제를 해결하기 위해 기본 RNN 아키텍처를 수정할 수 있었습니다. 몇 가지 예를 들어보겠습니다.

#### Examples of RNN Architectures

![image](https://user-images.githubusercontent.com/55765292/188063258-15157b64-f4c4-4d3e-b9ac-2f03de2f1de4.png)

지금까지 사용한 예는 $T_x$와 $T_y$가 같았습니다. 여기서는 입력 시퀀스가 $x^{<1>}, x^{<2>}$에 이어서 $x^{< T_x>}$까지 있었고 순환 신경망은 다음과 같이 $x^{<1>}$으로 $\hat{y}^{<1>}$을 계산하고 이어서 $\hat{y}^{<2>}$와 $\hat{y}^{< T_y>}$까지 계산하는 방식으로 작동합니다.

초기 다이어그램에서는 뉴런을 나타내는 많은 원을 그렸지만 이번에는 이런 작은 원을 그려서 표기를 간단히 하겠습니다. 이것이 **다대다many-to-many 아키텍처**라 부를 수 있는 것인데 왜냐하면 입력 시퀀스에는 시퀀스만큼 많은 입력값이 있고 출력 시퀀스에도 출력값이 많기 때문입니다.

다른 예를 살펴봅시다. 예를 들어 감성 분류를 다루고 싶다고 합시다. 여기서 x는 영화 평론과 같은 "이 영화에는 좋은 부분이 전혀 없다"라는 글이 있을 수 있습니다.

x는 배열될 것이고 y는 1에서 5까지의 숫자가 되거나 0 또는 1이 될 겁니다. 이것은 긍정적인, 또는 부정적인 리뷰이거나 1에서 5까지의 숫자일 수 있습니다. 이것이 별 하나, 별 둘, 셋, 넷 아니면 별 다섯 개의 리뷰라고 생각하나요?

이 경우 다음과 같이 신경망 아키텍처를 단순화할 수 있습니다. $x^{<1>}, x^{<2>}$를 입력하겠습니다. 한 번에 하나씩 단어를 입력합니다. 만약 입력 텍스트가 "이 영화에는 좋은 부분이 전혀 없다" 라면 "이 영화에는 좋은 부분이 전혀 없다"가 입력이 될 겁니다.

그리고 매 순간 출력을 사용해야 하는 것이 아니라 이미 전체 문장이 입력되었다면 RNN이 전체 문장으로 읽어들여 마지막 단계에서 $\hat{y}$을 출력하도록 할 수 있습니다. 즉, 이 신경망은 **다대일many-to-one 아키텍처**가 될 겁니다. 입력이 많은 만큼 많은 단어를 입력한 다음 단 하나의 숫자를 출력하기 때문입니다.

완성도를 위한 **일대일one-to-one 아키텍처**도 역시 있습니다. 이건 아마 재미가 덜할 겁니다. 표준 신경망이 작을수록 약간의 입력값 x를 입력하면 약간의 출력값 y를 얻게 될 겁니다. 따라서 이것은 이 시퀀스 내의 처음에 다룬 신경망의 유형일 수 있습니다. 이제 다대일 아키텍처에서도 일대다 아키텍처를 가질 수 있습니다.

![image](https://user-images.githubusercontent.com/55765292/188063281-3b7e6e27-7a15-448b-9c7c-6b7d3b6f3f17.png)

일대다 신경망 아키텍처의 한 예시는 음악 생성입니다. 신경망으로 음악을 만드는 일련의 음표를 출력하는 것입니다. 입력 x는 어쩌면 원하는 어떤 음악 장르나 첫 음을 나타내는 정수일 수도 있고 아무것도 입력하기 싫다면 x는 null 입력일 수도 있고 항상 영벡터일 수도 있습니다. 이를 위해 신경망 아키텍처는 입력값 x가 될 겁니다.

그런 다음 RNN 첫 번째 출력값을 얻고 더 이상의 입력 없이 두 번째 출력값을 얻게 됩니다. 이어서 세 번째 출력값, 계속해서 이어나가서 음악의 마지막 음을 합성할 때까지 계속 합니다. 원한다면 a_0도
입력할 수 있습니다.

이제 이후에 볼 수 있는 기술 하나는 여러분이 실제로 시퀀스를 생성할 때 이러한 합성된 첫 번째 출력값을 다음 레이어에도 전달합니다. 네트워크 아키텍처는 실제로 이렇게 나타납니다. 일대일과 마찬가지로 다대다, 다대일, 일대다에 관해 다루었습니다.

설명할 만한 흥미로운 다대다 예시가 하나 더 있습니다. 입력과 출력 길이가 다른 경우입니다. 따라서 다대다 예에서 방금 보셨듯이 입력 길이와 출력 길이는 정확히 같아야 합니다.

기계 번역과 같은 애플리케이션의 경우 입력 문장의 단어 수는 프랑스어 문장이고 출력 문장의 단어 수는 영어로 번역한 것이라고 하면 이 문장들의 길이는 서로 다를 수 있습니다.

여기 신경망이 있을 수 있는 다른 새 네트워크 아키텍처가 있습니다. 우선 문장을 읽습니다 먼저 입력값을 읽습니다 영어로 번역하려는 프랑스어 문장이라고 합시다. 그리고 그렇게 하면 신경망이 번역을 출력하게 됩니다.

이러한 모든 $\hat{y}^{< T_y>}$로 말입니다. 이 아키텍처를 사용하면 $T_x$와 $T_y$의 길이는 서로 다를 수 있습니다. 그리고 다시 원한다면 $a^{<0>}$를 그릴 수 있습니다.

이 동일 선상의 네트워크 아키텍처에는 두 가지 별개의 부분이 있습니다. 예를 들어 프랑스어 문장인 입력을 받아들이는 인코더가 있고 문장을 읽고 다른 언어로 번역을 출력하는 디코더가 있습니다. 이것이 다대다 아키텍처의 한 가지 예입니다.

#### Summary of RNN Types

![image](https://user-images.githubusercontent.com/55765292/188063297-47a4fb95-be2a-49ec-8215-60a7e829d26c.png)

광범위한 RNN 아키텍처를 요약하자면 일대일이라는 것이 있습니다. 만약 일대일 관계라면 그냥 이대로인데 이것은 일반적인 신경망입니다. 이런 경우에 RNN은 필요 없습니다.

하지만 일대다인 경우가 있습니다. 이것은 음악 생성이나 배열된 생성의 예시입니다. 그리고 감성 분류의 예시가 되는 다대일이 있습니다. 영화 리뷰에 있는 모든 텍스트를 입력값으로 읽고자 하고 그 영화를 좋아했는지 아닌지 알아보려는 경우입니다.

다대다에서 우리가 예시로 사용했던 개체명 인식은 $T_x$가 $T_y$와 같습니다. 그리고 마지막으로 다대다의 다른 버전인 기계 번역과 같은 애플리케이션은 T_x와 T_y가 더 이상 같을 필요가 없습니다.

이제 여러분은 대부분의 기본 요소를 살펴 보셨고 기본은 거의 여기 있는 이러한 모든 신경망입니다. 시퀀스 생성에 약간의 미묘함이 있다는 점을 제외하면 말입니다. 이에 대해서는 이어서 다룰 것입니다.


### Language Model and Sequence Generation

언어 모델링은 자연 언어 처리에서 가장 기본적이고 중요한 일입니다. 또한 RNN이 매우 잘 하는 것이기도 하죠. 이번에는 RNN을 이용한 언어 모델 구현방법을 배워보겠습니다.

#### What is Language Modelling?

![image](https://user-images.githubusercontent.com/55765292/188067562-0320e5df-b384-4760-af06-ce966cb4dd9c.png)

언어 모델이란 무엇입니까? 여러분이 음성 인식 시스템을 빌드하고 있고 The apple and pear salad is delicious라는 문장이 들린다고 가정해 봅시다. 제가 방금 뭐라고 말했죠? 

> The apple and pair salad

> The apple and pear salad

아마 두 번째 문장이 훨씬 더 가능성이 높다고 생각하실 겁니다. 사실, 그것은 두 문장의 소리가 완벽하게 똑같이 들림에도 불구하고 괜찮은 음성 인식 시스템이 출력하는 것이죠.

음성 인식 시스템이 두 번째 문장을 선택하는 방법은 두 문장의 확률이 얼마인지 알려주는 언어 모델을 사용하는 것입니다.

예를 들어 언어 모델은 첫 번째 문장의 확률은 $3.2 \times 10^{-13}$라고 할 수 있고, 두 번째 문장의 확률은 $5.7 \times 10^{-10}$라고 할 수 있습니다.

그래서 이러한 확률로 두 번째 문장이 첫 번째 문장과 비교하여 $10^3$배 더 가능성이 있어 음성 인식 시스템이 두 번째를 선택하는 것입니다.

언어 모델이 하는 일은 어떤 문장이 주어지든 그 특정한 문장의 확률이 얼마인지를 알려주는 것입니다. 그리고 문장의 확률로, 그러니깐 만약 여러분이 무작위의 신문을 집어서 혹은 무작위의 이메일이나 웹페이지를 열었더니 또는 다른 사람이 하는 말을 듣거나 친구가 말하는 등, 여러분이 세상 어딘가에서 읽은 특정 문장이 The apple and pear salad가 될 확률이 얼마나 될까요?

이는 여러분이 방금 보신 음성 인식 시스템과 번역 시스템이 가능한 문장만 출력하길 원하는 기계 번역 시스템을 위한 기본 요소입니다. 그래서 언어 모델의 기본적인 작업은 제가 쓸 문장을 $y^{<1>},y^{<2>},...,y^{< ty>}$까지의 시퀀스로 입력하는 것입니다.

그리고 언어 모델에 대해 문장들을 input x 보다는 ouput y로 나타내는 것이 유용할 것입니다. 하지만 언어 모델이 하는 일은 단어의 특정 시퀀스의 확률을 추정하는 것입니다.

#### Language Modelling with an RNN

![image](https://user-images.githubusercontent.com/55765292/188067615-3edd2d7c-b065-4caf-aef6-ad5cd960bb95.png)

여러분은 어떻게 언어 모델을 빌드하시나요? RNN을 사용하여 이러한 모델을 만들려면 먼저 대량의 영어 텍스트 혹은 여러분이 언어 모델을 빌드하길 원하는 언어에서의 텍스트의 코퍼스가 포함된 훈련 세트가 필요합니다.

**코퍼스corpus**라는 단어는 분량이 큰 혹은 수십 개의 영어 문장을 의미하는 NLP 용어입니다. 여러분의 훈련 세트에

> Cats average 15 hours of sleep a day.

라는 문장이 있다고 해보죠.

첫 번째로 할 일은 문장을 **토큰화**하는 것인데요. 이는 즉 어휘를 우리가 이전 영상에서 봤던 것처럼 형성하고 이 단어들을 각각 원-핫 벡터나 여러분의 어휘의 색인에 맵핑하는 것을 의미합니다.

또한 문장이 끝날 때를 모델하고 싶을 수 있을 것인데요. 이를 위해 **EOS**이라는 추가 토큰을 더하는 것입니다. 이는 end of sentence를 뜻하며 문장이 언제 끝나는지를 알아낼 수 있도록 해줍니다.

이것에 대해서는 나중에 설명하도록 하죠. 하지만 EOS 토큰은 여러분이 문장 종료 시 모델이 명시적으로 캡처하기를 원하는 경우, 여러분의 훈련 세트에 있는 모든 문장 끝에 추가될 수 있습니다. 일부 응용 프로그램에서 이것을 사용할 수 있으며 어디에서 유용한지는 나중에 알아보도록 하죠.

이 예제에서는 $y^{<1>} y^{<2>}, y^{<3>}, 4, 5, 6, 7, 8, 9$가 있습니다. 이 예제에서 EOS 토큰을 추가하려는 경우 9개의 input입니다.

토큰화 단계를 수행하면 마침표도 토큰이어야 하는지를 결정할 수 있습니다. 이 예제에서 구두점을 무시할 건데요. day를 또 다른 토큰으로 사용하고 마침표를 제외하겠습니다. 만약 마침표나 다른 구두점을 명시적 토큰으로 대하려는 경우 어휘에도 마침표를 추가할 수 있습니다.

이제 또 다른 세부 사항으로 만약 여러분의 훈련 세트의 일부 단어가 어휘에 없다면 어떨까요? 만약 여러분의 어휘가 10,000 단어를 영어에서 가장 흔한 10,000 단어를 사용한다면 Mau라는 용어는 결정으로 Mau is breed of cat은 여러분의 최대 10,000개 토큰 중 하나가 아닐 수도 있습니다.

이 경우에는 Mau라는 단어를 미등록어를 의미하는 **UNK**라는 고유 토큰으로 교체할 수 있으며 우리는 방금 특정한 단어 Mau 대신에 UNK의 확률을 모델링했습니다.

토큰화 단계를 거친다는 건 입력 문장을 가져다 여러분 어휘의 개별 토큰이나 개별 단어에 맵핑한다는 것을 의미합니다.

다음으로 이 여러 시퀀스들의 확률을 모델링하기 위해 RNN을 빌드해 봅시다. 다음에 우리가 볼 것 중 하나는 input $x^{< t>}$을 $y^{< t-1>}$와 동일하게 설정하는 것인데요. 그건 조금 이따가 살펴보도록 하죠. 그럼 RNN 모델을 빌드해 봅시다.

#### RNN Model

![image](https://user-images.githubusercontent.com/55765292/188067672-6cb5b1c1-0836-4db5-9887-2a91e65e654c.png)

> Cats average 15 hours of sleep a day.

이 문장을 실행 예제로 계속 사용할 건데요. 이는 RNN 아키텍처가 될 것입니다. 처음에는 일부 activation $a^{<1>}$을 일부 input $x^{<1>}$의 함수로서 컴퓨팅을 하게 됩니다. 그리고 $x^{<1>}$은 그냥 0 벡터로만 설정되죠. 관례상 이전 $a^{<0>}$도 0 벡터로 설정됩니다.

하지만 $a^{<1>}$는 소프트맥스 예측을 만들어 첫 번째 단어 y의 확률을 파악하려 할 것이고 이게 $y^{<1>}$이 됩니다. 이 단계에서는 소프트맥스로 딕셔너리의 아무 단어의 확률을 예측하려는 것입니다.

첫 번째 단어가 a일 확률이 얼마나 될까요? 첫 번째 단어가 Aaron일 확률은요? 그리고 첫번째 단어가 cats일 가능성 확률이나 첫 번째 단어가 Zulu일 확률은 어떻게 될까요? 아니면 첫 번째 단어가 미등록어이거나, 첫 번째 단어가 문장 안에 있거나 실제로 일어나서는 안 될 확률이 얼마나 될까요?

$\hat{y}^{<1>}$은 소프트맥스에 따른 출력이며 첫 번째 단어가 어떤 단어가 되든 그 단어가 될 확률을 예측합니다. 우리의 예제에서 가장큰 단어는 Cats입니다.

이는 소프트맥스 출력의 10,000가지 방법이 될 것입니다. 만약 여러분이 10,000 또는 10,002개의 어휘가 있다면 미등록어는 하지 못하고 문장은 2개의 추가적 토큰을 가집니다.

그런 다음 RNN은 다음 단계로 나아가 그곳에서 일부 활성화 $a^{<1>}$을 가집니다. 이 단계에서 작업은 두 번째 단어가 무엇인지 파악하는 것입니다. 하지만 이제 우리는 올바른 첫 단어를 말할 것입니다.

G는 현실에서 첫 번째 단어는 사실 cats 이였으며 그리고 그것은 $y^{<1>}$이라고, cats라고 말합니다. 그래서 이것이 $y^{<1>}$이 $x^{<2>}$와 동일한 이유이죠.

두 번째 단계에서 출력은 다시 소프트맥스에 의해 예측되며 RNN의 일은 그것이 어떤 단어가 되었든 그 단어가 될 확률을 예측하는 것입니다. A나 Aaron인지, cats인지 Zulu인지, 아니면 미등록어나 EOS라던지, 무엇이던지 간에 이전에 나왔던 것을 고려해서 말이죠.

이 경우 문장이 cats average로 시작하기 때문에 올바른 정답은 average가 되겠네요. 그런 다음 $a^{<3>}$를 계산하는 RNN의 다음 단계로 넘어갑니다.

하지만 세 번째 단어 즉 15가 무엇인지 예측하기 위해서 첫 두 단어를 말할 수 있습니다. 첫 두 단어인 cats average를 말합니다. 이는 다음에서 입력이 됩니다. $x^{<3>}$는 $y^{<2>}$와 동일할 것입니다. 그래서 단어 average는 입력이며 이는 시퀀스에서 다음 단어를 알아내는 일을 합니다.

또 다른 하나는 방금 전에 나온 단어가 cats average라는 것을 고려할 때 딕셔너리에 있는 단어의 확률이 얼마나 되는지 알아내는 것이었는데요. 이 경우 정답은 15개 정도입니다.

마지막까지 여러분은 시간 단계 9에 도달할 것이며 단어 day인 $y^{<8>}$와 동일한 $x^{<9>}$를 주게 될 것입니다. 그런 다음 이것은 $a^{<9>}$을 가지고 이것의 일은 $\hat{y}^{<9>}$를 여는 것이며 그리고 이것은 EOS 토큰입니다.

어떤 것이든 앞에 있는 모든 것을 고려하면 확률은 어떻게 될까요? 문장 토큰에 EOS이 있을 가능성이 높다는 것을 예상하시길 바랍니다.

하지만 RNN의 각 단계는 일부 앞선 단어 세트를 볼 것인데요. 예를 들어서 처음 세 단어를 고려할 때, 다음 단어의 분포는 무엇일까요? 이 RNN은 왼쪽에서 오른쪽으로 한 번에 한 단어씩 예측하는 것을 배웁니다.

다음으로 네트워크를 통해 이를 훈련하기 위해서. 비용 함수를 정의합니다. 특정 t 에서 단어가 $y^{< t>}$였고, 여러분의 네트워크 소프트맥스가 $hat{y}^{< t>}$를 예측했다면 이것은 여러분이 잘 알고계시는 소프트맥스 손실 함수입니다.

그리고 전체적인 손실은 개별 예측과 관련된 손실의 모든 시간 단계의 합계입니다. 만약 여러분이 이 RNN을 큰 훈련 세트로 훈련하면 그것은 cats average 15나 cats average 15 hours of와 같은 어떤 초기의 단어 세트를 고려했을 때 다음 단어의 확률을 예측할 수 있습니다.

단순함을 위해 단지 세 단어로 이루어진 $y^{<1>}, y^{<2>}, y^{<3>}$라는 새로운 문장을 고려했을 때, 여러분이 이 전체 문장의 확률이 어느 정도인지 알아낼 수 있는 방법은 첫 번째 소프트맥스가 $y^{<1>}$의 확률을 말해줄 것이며 이것이 첫번째 결과일 것입니다.

그런 다음 두 번째는 $y^{<1>}$를 고려한 $y^{<2>}$의 p를 말해줄 겁니다. 그런 다음 세 번째는 $y^{<1>}$과 $y^{<2>}$를 고려한 $y^{<3>}$의 확률을 말해줄 것인데요. 이 세 확률들을 곱한 것이죠.

지금까지가 RNN을 이용한 언어 모델을 훈련하는 기본 구조였습니다.
