---
title: "[Ⅳ. Convolutional Neural Networks] Object Detection (5)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Deep Learning
  - Facial Recognition System
  - Convolutional Neural Network
  - Tensorflow
  - Object Detection and Segmentation
toc: true
toc_sticky: true
toc_label: "Object Detection (5)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/183551502-3482e2d7-efb0-4815-9c94-b662606b4842.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Object Detection

## Detection Algorithms

### Putting It Together: YOLO algorithm

이미 대부분의 객체 감지 구성 요소를 보았습니다 이 강의에서는 모든 구성 요소를 결합하여 YOLO 객체 감지 알고리즘을 구성 해 보겠습니다.

#### Training

![image](https://user-images.githubusercontent.com/55765292/186303379-337812c5-4b24-45cf-8368-2651bbea78f5.png)

먼저, 트레이닝 세트를 구성하는 방법을 살펴 보겠습니다. 보행자, 자동차 및 오토바이의 세 가지 객체를 탐지하는 알고리즘을 학습시킨다고 가정합니다. 그리고 명시적으로 전체 배경 클래스를 가져야 하므로 여기에 클래스 레이블 만 넣으면 됩니다.

두 개의 앵커 박스를 사용하는 경우 아웃풋 y는 $3 \times 3 \times 2 \times 8$이 되겠죠. 이는 $3 \times 3$ 격자판 셀이며, 여기 $\times 2$, 이것은 앵커의 수입니다. 여기에 $\times 8$, 이는 여기 있는 이 차원을 가리키는 것입니다. 8은 사실 5 인데요. 여기에 클래스의 숫자 3을 더한 것입니다.

$P_c$와 여기에 경계 상자를 더하면 여기 5개 되는 것이고, 그리고 나서 $c_1, c_2, c_3$ 이것의 차원은 클래스의 수와 동일합니다. $3 \times 3 \times 2 \times 8$ 이든 $3 \times 3 \times 16$ 이 둘 중 하나를 볼 수 있는 것입니다.

따라서 훈련 세트를 구성하기 위해서는 이 9개 격자판 셀 각각을 살펴보고 적합한 타겟 벡터 y를 만들면 됩니다.

이 첫 번째 격자판 셀을 가지고 와서 이 격자판 셀에서는 감지할만한 것이 없군요. 보행자, 자동차, 오토바이, 이 세 클래스 중에 그 어느 것도 왼쪽 상단 격자판에는 보이지 않습니다. 그래서 이 격자판 셀에 상응하는 타겟은 이것과 동일할 것입니다.

첫 번째 앵커 상자에 있는 $P_c$는 0인데요. 첫 번째 앵커 상자와 관련된 것이 아무것도 없기 때문입니다. 그리고 또한 두 번째 앵커박스도 0 이고 이런 식으로 되어 여기 이 다른 값들도 신경 쓸 필요 없는 것들이 되죠. 대부분의 격자판 셀들 안에는 아무것도 없습니다.

하지만 초록색 상자는 이 타겟 벡터 y를 가지고 있습니다. 여러분의 훈련 세트가 이 자동차에 대해서 경계 박스를 가진다고 추측해볼 수 있습니다. 높이 보다는 옆으로 좀 더 넓게 되어있군요.

그리고 만약 여러분의 앵커 상자가 있는데, 이것이 앵커 상자 1이고, 이건 앵커 상자 2라면, 이 빨간 박스는 앵커 상자 2를 가진 약간만 더 높은 IoU를 가지고 있어서, 이 자동차는 이 벡터의 아래쪽 부분과 연관되는 것입니다.

앵커 상자 1과 연관된 $P_c$는 0이고 이 모든 요소들을 전부 신경 쓸 필요 없는 것들이므로 이 $P_c$는 0 이 됩니다. 그리고 빨간색 경계 상자의 위치를 구체화 하기 위해서는 이것들을 사용해야 하는 것이죠.

그리고 이 옳은 객체가 클래스 2라고 구체화 시키십시오. 이것이 자동차가 맞습니다. 따라서 이렇게 진행하시면 각각의 9 격자판 위치 $3 \times 3$ 격자판 위치에서 여러분은 이런 벡터를 얻게 될 것이고 16개차원의 벡터를 얻게 될 것입니다.

그러므로 최종 출력 볼륨은 $3 \times 3 \times 16$이 될 것입니다. 그리고 평소와 같이 그림의 단순화를 위해 $3 \times 3$ 격자판을 사용했습니다. 실제로는 $19 \times 19 \times 6$에 가까울 수도 있습니다.

실제로 앵커 상자를 더 많이 사용하면 $19 \times 19 \times 5 \times 8$ 이 될 텐데요. $5 \times 8$은 40이므로 $19 \times 19 \times 40$이됩니다.

5 개의 앵커 상자를 사용하면 이것이 바로 학습이죠. 이제 $100 \times 100 \times 3$ 이미지를 입력해서 컨볼네트를 학습시키십시오. 그러면 컨볼네트는 마침내 예제와 같이 $3 \times 3 \times 16$ 혹은 $3 \times 2 \times 8$ 의 출력 볼륨을 출력하게 될 것입니다. 알고리즘이 예측을 어떻게 하는지 보십시오.

#### Making predictions

![image](https://user-images.githubusercontent.com/55765292/186303461-b04519cd-922d-42ea-b30c-a13b33ec7cd0.png)

이미지가 주어지면 신경망은 이것을 $3 \times 3 \times 2 \times 8$ 크기로 출력합니다 9 개의 격자판 셀 각각에 대해 이와 같은 벡터를 얻을 수 있죠.

따라서 왼쪽 위에 있는 격자판 셀의 경우 여기에 객체가 없으면 여기와 여기에서는 0을 출력하고 여기서는다른 값을 출력할 것입니다. 신경망은 물음표를 출력 할 수 없으며 신경 쓰지 않아도 된다는 표시를 하지 못합니다.

그러니 제가 이 나머지에 숫자를 넣도록 하겠습니다. 이 숫자들은 기본적으로 무시되 버릴 것입니다. 신경망이 여기에 객체가 없다고 알려주고 있으니까요.

출력이 경계 상자인지 아니면 자동차인지 그 여부는 중요하지 않습니다. 기본적으로 숫자의 세트 더 많거나 적은 노이즈만 있습니다.

대조적으로, 이 상자에 대해서는 왼쪽 하단의 상자에 대한 y값은 바운딩 상자 1에 대해 0 일 것입니다. 그리고 나서 노이즈처럼 숫자들을 쓰고 아마도 자동차에 대해 정확한 경계 상자를 구체화시키는 숫자 세트를 출력할 수 있을 것입니다.

이것이 바로 신경망이 예측을 하는 방법입니다. 마지막으로 non-max 억제를 통해 이를 실행합니다.

#### Outputting the non-max supressed outputs

![image](https://user-images.githubusercontent.com/55765292/186303508-98ff1e0f-64c7-4f9d-8d37-96b1de33281e.png)

이것을 좀 더 재미있게 하기 위해서 새로운 테스트 세트 이미지를 살펴 보겠습니다. 다음은 non-max 억제를 실행하는 방법입니다.

두 개의 앵커 상자를 사용하는 경우 각 격자판이 아닌 셀에 대해 두 개의 예측된 경계 상자를 얻으십시오. 그 중 일부는 매우 낮은 확률 매우 낮은 P_c를 갖지만 9 개의 격자판 셀 각각에 대해 2 개의 예상 경계 상자를 여전히 얻으면 됩니다.

이것들이 여러분이 얻게 될 경계 상자입니다. 그리고 경계 상자 중 일부는 격자판 셀의 높이와 너비 바깥쪽으로 나갈 수 있습니다. 그런 다음 낮은 확률 예측을 제거합니다 그래서 신경망이 객체는 아마도 거기에 존재하지 않을 거라고 말하는 것조차 없애 버려야합니다. 그러니 이건 제거합시다.

그리고 마침내 여러분이 감지하고 싶은 세 가지 클래스가 있고 보행자, 자동차 및 오토바이를 감지하고 싶으면 여러분이 하실 일은 세 클래스 각각에 대해 그 클래스에서 올 것으로 예측되었던 객체들에 대해 non-max 억제를 독립적으로 실행하십시오.

보행자 클래스의 예측에 대해 non-max 억제를 사용하고 자동차 클래스에 대해 non-max 억제를 실행하고, 오토바이 클래스에 대해 non-max 억제를 실행합니다. 기본적으로 세 번 실행하여 최종 예측을 생성합니다. 그리고 이 출력은 이 이미지에 있는 모든 자동차와 모든 보행자를 감지했을 것입니다. 

---

이것이 YOLO 객체 감지 알고리즘을위한 것이고 실제로 가장 효과적인 객체 감지 알고리즘 중 하나입니다. 이는 또한 객체 감지와 관련된 전체 컴퓨터 비전 문헌을 통틀어 가장 많은 훌륭한 아이디어 들를 아우릅니다.
