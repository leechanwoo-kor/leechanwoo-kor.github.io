---
title: "[Ⅳ. Convolutional Neural Networks] Object Detection (3)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Deep Learning
  - Facial Recognition System
  - Convolutional Neural Network
  - Tensorflow
  - Object Detection and Segmentation
toc: true
toc_sticky: true
toc_label: "Object Detection (3)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/183551502-3482e2d7-efb0-4815-9c94-b662606b4842.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Object Detection

## Detection Algorithms

### Bounding Box Predictions

#### Output accurate bounding boxes

지난번 여러분은 슬라이딩 윈도우의 컨볼루션 구현을 사용하는 방법을 배웠습니다. 계산상 효율적이지만 여전히 가장 정확한 경계 상자를 출력하지 못하는 문제가 있습니다. 이 경계 상자 예측을 보다 정확 하게하는 방법을 함께 보시죠.

![image](https://user-images.githubusercontent.com/55765292/186093590-a9724c01-7b18-4e1e-a451-1a531a55dd17.png)

슬라이딩 윈도우로, 여러분은 이 3 세트의 위치와 크로스파이어를 가할 수 있습니다. 이 경우에, 어느 상자도 자동차 위치와 완벽하게 일치하지 않습니다.

어쩌면 이 상자가 가장 잘 어울리는 것일 수도 있습니다. 또한 완벽하게 경계 상자가 완전히 정사각형이 아니기 때문에 실제로는 약간 더 넓은 직사각형 또는 약간 수평으로 가로 세로 비율이 그려져 있는 것처럼 보입니다.

이 알고리즘이 더 정확한 경계 상자를 출력하도록 하는 방법이 있을까요? 

#### YOLO algorithm

![image](https://user-images.githubusercontent.com/55765292/186093687-11ea9c9a-157c-48b2-89f6-ee48f3e69459.png)


이 출력을 더 정확하게 경계 상자로 가져 오는 좋은 방법은 YOLO 알고리즘을 사용하는 것입니다. YOLO는 You Only Look Once의 약자입니다. 그리고 Joseph Redmon, Santosh Divvala, Ross Girshick 및 Ali Farhadi에 의한 알고리즘입니다.

여기 여러분이 해야 할 일이 있습니다. 입력 이미지가 $100 \times 100$ 인 경우, 이 이미지에 격자판을 배치한다고 가정 해 보겠습니다. 설명을 위해 $3 \times 3$ 격자판을 사용하려고 합니다.

실제 구현에서는 $19 \times 19$ 격자판과 같이 더 미세한 격자판을 사용합니다. 그리고 기본 아이디어는 몇몇 강의에서 보셨던 이미지 분류 및 위치 측정 알고리즘을 사용하여 9 개의 각 격자판에 적용하는 것입니다.

기본 아이디어는 이전에 보셨던 이미지 분류 및 위치 측정 알고리즘을 가지고 9개의 각 격자판에 적용하는 것입니다. 좀 더 구체적으로 여기에 훈련용으로 사용하는 레이블을 정의하는 방법이 있습니다.

따라서 9 개의 격자판 셀 각각에 대해, 레이블 y를 지정합니다. 여기서 레이블 y는 이전에 본 것처럼 8 차원 벡터입니다.

해당 그리드 셀에 이미지가 있는지 여부에 따라 PC 01을 출력한 다음 $b_x, b_y, b_h, b_w$을 사용해서 이미지가 있고, 격자판 셀에 연관된 객체가 있으면 경계 박스를 구체화시킵니다.

그런 다음 $c_1, c_2, c_3$ 배경 클래스를 세지 않고 세 클래스를 시도하고 인식하세요. 그래서 당신은 보행자 클래스, 오토바이 및배경 클래스를 인식하려고 합니다. $c_1, c_2, c_3$ 은 보행자, 자동차 그리고 오토바이 클래스를 말합니다.

이 이미지에서 우리는 9 개의 격자판 셀을 가지므로 각 격자판 셀에 대해 이와 같은 벡터를 가집니다. 그러면 왼쪽 상단 격자판 셀부터 시작해 봅시다. 여기 위에 있는 거로요.

여기엔 객체가 없죠. 왼쪽 위의 격자판 셀에 대한 레이블 벡터 y는 0이 될 것이고 나머지는 고려하지 않을 것입니다. 출력 레이블 y는 이 격자판 셀과 이 격자판 셀, 그리고 아무 것도 없는 모든 격자판 셀에 대해 같을 것이며 흥미로운 객체는 없습니다.

자, 이 격자판 셀은 어떻습니까? 좀 더 자세히 설명하기 위해 이 이미지에는 두 개의 객체가 있습니다. YOLO 알고리즘이 수행하는 작업은 두 객체의 도달 중간 점을 취한 다음, 중간 점을 포함하는 격자판 셀에 이 객체를 할당하는 것입니다.

따라서 왼쪽 자동차는 4번 격자판 셀에 지정되고 이 오른쪽 차는 이 중간 점이 6번 격자판 셀에 지정됩니다. 5번 격자판 셀에는 두 자동차의 일부가 있지만 중앙 격자판 셀은 흥미로운 객체가 없다고 생각해서 중앙 격자판 셀인 레이블 y 클래스는 객체가 없는 이 벡터처럼 보이게 됩니다.

따라서 첫 번째 구성 요소는 PC가 되고, 나머지는 상관없음이 됩니다.

반면에 이 셀에는, 왼쪽에 초록색으로 동그라미 해 놓은 이 셀, 타겟 레이블 y는 다음과 같습니다. 객체가 없고 경계 상자의 위치를 구체화시키기 위해 $b_x, b_y, b_h, b_w$를 씁니다. 그럼 한 번 봅시다.

클래스 1이 보행자라면 그것은 0입니다. 클래스 2는 자동차 입니다. 클래스 3은 오토바이였는데 0 이죠. 그리고 비슷하게 오른쪽에 있는 격자판 셀은 그 안에 객체가 있기 때문에 오른쪽에 있는 격자판 셀에 해당하는 대상 레이블과 같은 벡터를 갖게 됩니다. 따라서 이러한 9 개의 격자판 셀 각각에 대해 결국 8 차원 출력 벡터를 가지게 됩니다.

그리고 여러분은 $3 \times 3$ 격자판 셀을 가지고 있기 때문에 9 개의 격자판 셀을 가지게 됩니다. 출력의 전체 볼륨은 $3 \times 3 \times 8$이 될 것입니다. 그래서 $3 \times 3$ 격자판 셀을 가지고 있기 때문에 목표 출력은 $3 \times 3 \times 8$ 이 될 것입니다. 각각의 $3 \times 3$ 격자판 셀에서 8 차원 벡터 y를 가지고 있습니다.

따라서 목표 출력 볼륨은 $3 \times 3 \times 8$입니다. 예를 들어, 이 왼쪽 상단에서 $1 \times 1 \times 8$ 볼륨 9개 격자판 셀의 왼쪽 상단에 있는 목표 출력에 일치합니다. 그리고 $3 x 3$ 위치 각각에 대해 각 9개 격자판 셀에서 이것은 각각에 대해 출력하고자 하는 8 차원 목표 벡터 y에 해당합니다. 거기에 객체가 없다면 이는 '상관없음' 벡터를 가질 것입니다. 이런 이유로 총 목표 출력, 이 이미지에 대한 출력 레이블인 이 자체로 $3 \times 3 \times 8$ 볼륨입니다.

이제 신경망을 훈련시키기 위해 입력은 $100 \times 100 \times 3$이고 이것은 입력 이미지입니다. 그리고 컨볼 레이어, 맥스풀 레이어 등등을 가진 일반적인 컨볼네트가 있습니다. 마지막으로 이걸 가지고 컨볼레이어와 맥스풀 레이어 등을 선택해서 사용하면 마침내 $3 \times 3 \times 8$ 출력 볼륨으로 매핑됩니다.

이제 여러분이 할 일은 이렇게 생긴 입력 이미지 x를 만들고 $3 \times 3 \times 8$ 인 이러한 목표 라벨 y를 만들 후 신경망 훈련을 위해 방향 전파 를 사용하여 입력 x에서 출력 볼륨 y 매핑합니다.

따라서 이 알고리즘의 장점은 신경망이 다음과 같이 정확한 경계 상자를 출력한다는 것입니다. 테스트 시간에 여러분이 해야 하는 일은 입력 이미지 x를 제공하고 이 출력 y를 얻을 때까지 순전파를 실행하는 것입니다.

그런 출력의 $3 \times 3$ 위치 각각에 대한 9 개의 출력 각각에 대해 1과 0을 읽어낼 수 있게 됩니다. 9 개 위치 중 하나와 관련된 객체가 있나요? 그리고 객체가 있다면, 어떤 객체인가요. 그 격자판 셀의 객체에 대한 경계 상자는 어디에 있나요? 그리고 각 격자판 셀에 하나 이상의 객체가 없으면 이 알고리즘은 잘 작동합니다.

그리드 셀 내에 여러 객체를 갖는 문제는 나중에 다룰 내용입니다.

상대적으로 작은 $3 \times 3$ 격자판을 사용하는 경우를 봅시다. 실제로는 더 미세한 $19 \times 19$ 크기의 격자판을 사용할 수 있습니다. 그럼 $19 \times 19 \times 8$을 얻게 되고 그리고 이것은 격자판을 더욱 미세하게 만듭니다.

이것은 동일한 격자판 셀에 여러 객체가 할당 될 가능성을 줄여줍니다. 다시 말하면, 이는 객체의 중간 점을 보고 객체의 중간 점을 포함하는 격자판 셀 하나에 해당 객체를 할당하는 방법입니다.

따라서 각 객체는 객체가 여러 격자판 셀을 사용하더라도 9개 격자판 셀 중의 하나 아니면 $3 \times 3$ 아니면 $19 \times 19$ 격자판 셀의 하나, 즉 $19 \times 19$ 격자판의 알고리즘에만 할당됩니다.

같은 격자판 안에 객체의 중간 점이 두 개가 될 확률은 좀 더 작아지는 것이죠. 두 가지를 기억하십시오.

첫째, 이것은 이전에 설명한 이미지 분류 및 위치 측정 알고리즘과 매우 유사합니다. 그리고 바운딩 볼이 명시적으로 좌표를 출력하죠. 따라서 네트워크에서 모든 형상비의 경계 상자를 출력 할 수 있을 뿐 아니라 슬라이딩 윈도우 분류기의 스트라이프 크기에 의해 결정되지 않는 훨씬 정확한 좌표를 출력 할 수 있습니다.

두 번째로, 이것은 컨볼루션 구현이며, $3 \times 3$ 격자판에 9를 곱하지 않거나 $19 \times 19$ 알고리즘, 19 제곱인 361 을 사용하고 있다면 같은 알고리즘을 361번 혹은 19의 제곱 번 만큼 실행하지 않은 겁니다.

대신 이것은 한 단위의 컨볼루션 구현입니다. 이것은 여러분의 모든 $3 \times 3$ 혹은 $19 \times 19$이 필요로 하는 연산 간에 공유된 많은 것을 가지고 있는 하나의 컨볼네트를 사용하는 것입니다.

따라서 이것은 매우 효율적인 알고리즘입니다. 사실 YOLO 알고리즘에 대한 좋은 점은 꾸준한 인기가 있다는 것입니다. 이 알고리즘은 컨볼루션 구현이어서 실제로는 매우 빠르게 실행됩니다.

그래서 이것은 실시간 객체 감지의 경우에도 적용됩니다. 마무리하기 전에 공유하고 싶은 또 하나의 세부 사항이 있는데요. 이 경계 상자 $b_x, b_y, b_h, b_w$를 어떻게 인코딩 해야 할까요? 다음 그림에서 이에 대해 논의 해 보도록 하죠 

#### Specify the bounding boxes

![image](https://user-images.githubusercontent.com/55765292/186093772-80ce63f8-a14a-415f-9fcf-aabc6a20f4a7.png)

이 두 대의 자동차를 보시면, 우리는 $3 \times 3$ 격자판을 사용한다는 것을 기억하세요. 오른쪽 차의 예를 들어 봅시다. 이 격자판 셀에는 객체가 있으므로 타겟 레이블 y는 1이 되고, 즉 pc는 1이죠. 그리고 나서 $b_x, b_y, b_h, b_w$와 0, 1, 0입니다.

그럼, 어떻게 경계 상자를 지정할까요? YOLO 알고리즘에서, 이 네모와 관련하여, 여기 왼쪽 위의 점은 (0, 0)이고 (0,0)이고 이 오른쪽 하단은 (1,1)입니다.

그 중간 점의 위치를 지정하기 위해 그 주황색 점 $b_x$는 x가 약 0.4 인 것처럼 보입니다. 아마 오른쪽으로 0.4 정도 갔을 거예요. 그리고 나서 y는 아마 0.3 일 것 같습니다.

그리고 경계 상자의 높이는 192 이 상자의 전체 너비의 비율로 지정됩니다. 그래서 이 빨간 상자의 너비는 아마 그 파란색 선의 90 %입니다. 그래서 $b_h$는 0.9이고 높이는 격자판 셀의 전체 높이의 절반 일 수 있습니다. 그래서 이 경우 $b_w$는 0.5라고 합시다.

다시 말해, 이 $b_x, b_y, b_h, b_w$는 격자판 셀과 관련하여 지정됩니다. 그래서 $b_x$와 $b_y$는 0과 1 사이여야 합니다. 그렇죠? 이는 정의에 따라 보자면 그 주황색 점이 그 할당된 격자판 셀의 범위 내에 있기 때문에 0과 1 사이가 아닌 경우는 네모 밖에 있게 되고 다른 격자판 셀에 할당될 것입니다.

그러나 이것들은 1보다 더 클 수 있습니다. 특히 경계 상자가 이렇게 있는 자동차를 가지고 있다면 경계 상자의 높이와 너비는 1 보다 커질 수 있습니다. 따라서 경계 상자를 지정하는 방법은 여러 가지가 있지만 이것이야말로 매우 합리적인 방법 중 하나입니다.

비록 YOLO 연구 논문을 읽는다면 훨씬 더 잘 작동할 수 있는 파라미터화 된 것들이 있습니다. 이것이 한 가지 합리적인 환경을 제공하여 잘 작동하길 바랍니다. 비록 이것이 0과 1 사이에 있는지 확인하기 위한 시그모이드 함수와 관련된 좀 더 복잡한 파라미터화가 있긴 하지만 말이죠.

그리고 설명 파라미터화를 사용하여 이것들이 음수가 아니라는 것을 확인하세요. 0.9, 0.5 이니까요. 이것은 0보다 크거나 같아야만 합니다. 조금 더 나은 작업을 하는 다른 고급 파라미터가 있지만 여기에서 본 것도 잘 작동할 것입니다.


### Intersection over union

객체 탐지 알고리즘이 잘 작동하는지 어떻게 알 수 있을까요? 이번에는 '합집합에 대한 교집합’ 이라는 함수에 대해 배우게 됩니다. 객체 감지 알고리즘을 평가하는 데도 사용할 수 있으므로 다음에 다룰 내용인 물체 감지 알고리즘에 다른 구성 요소를 추가하여 더 잘 작동하도록 할 수 있습니다.

#### Evaluating object localization

![image](https://user-images.githubusercontent.com/55765292/186105155-93e4de7b-a6d9-40af-b3c2-90b8dadde66f.png)

객체 탐지 과제를 할 때 객체 역시 현지화하기를 원합니다. 그것이 실측된 경계 상자라면 알고리즘이 이 경계 상자를 보라색으로 출력하면 이것은 좋은 결과일까요? 나쁜 결과일까요?

그래서 이 합집합에 대한 교집합, 즉 IoU 함수가 하는 일은 이 두 개의 경계 상자의 합집합에 대한 교집합를 계산하는 것입니다.

따라서 이 두 개의 경계 상자의 결합 부위는 오렌지색 영역인데요. 이것은 이 두 개의 경계 상자 중 모두에게 있는 것이죠. 반면 교집합은 더 작은 영역에 있는 것이죠.

결합된 부위의 교집합이 하는 일은 교차점의 크기를 계산하는 것 입니다. 오렌지색으로 칠해진 이 영역을, 합집합 된 크기로 나누는데 그러면 이 초록색으로 칠한 영역이 되겠죠.

IoU가 0.5보다 클 경우 일반적으로 낮은 컴퓨팅 부서 작업에서는 정답으로 판단합니다. 그리고 만약 예측된 경계 상자와 실측된 경계 상자가 완벽하게 겹쳐지면 IoU는 1 이 되는 것입니다.

왜냐하면 교집합은 이 합집합과 같기 때문입니다. 일반적으로 IoU는 0.5보다 크거나 같기 때문에 그 답안은 옳은 것으로 간주되고 꽤 괜찮아 보이는 것이죠.

관습적으로 매우 흔하게 0.5는 예측된 경계 상자 값이 옳은지를 판단하는 한계 값으로 사용되어집니다. 이것은 그냥 관습적인 것인데요. 보다 엄격하게 하고 싶으시다면 IoU가 0.6과 같거나 큰 경우에만 올바른 답안인 것으로 판단하면 됩니다. IoU가 더 높을수록 경계 상자 값은 더욱 정확합니다.

이는 현지화를 매핑하는 한 가지 방법인데요. 알고리즘이 객체를 올바르게 감지하고 현지화하는 횟수를 세어 보면 객체가 올바르게 현지화되었는지 여부를 정의할 수 있습니다.

다시 말하지만, 0.5는 인간이 선택한 규칙일 뿐입니다. 특별히 깊은 이론적 이유는 없습니다. 더 엄격하게 하려면 0.6과 같은 다른 분계점을 선택할 수도 있습니다. 저는 가끔 사람들이 0.6이나 0.7과 같은 더 엄격한 기준을 사용하는 것을 봅니다. 0.5 아래로 분계점을 떨어뜨리는 사람은 거의 찾아볼 수가 없죠.

이제 IoU의 정의를 내리는 것에 동기 부여하는 것은 객체 현지화 알고리즘이 정확성 여부를 평가하는 방법입니다. 그러나 일반적으로 IoU는 두 개의 경계 상자 사이의 중첩을 측정하는 것입니다.

여러분에게 두 개의 상자가 있는 경우 교집합을 계산하고 합집합 부분을 계산하고 두 영역의 비율을 계산할 수 있습니다. 두 상자가 서로 얼마나 비슷한지 측정하는 방법이기도 합니다.

이걸 다음에 다시 보긴 하겠지만 그리고 non-max 억제에 대해 이야기 할 때 이것은 IoU 즉, 합집합에 대한 교집합을 위한 것입니다. IoU의 약속 어음 개념과 혼동해서는 안되는대요.

만약 누군가에게 돈을 빌려줄 때 ‘저는 이만큼의 돈을 당신에게 빚 졌습니다'라고 쓰여있는 메모를 주는 것이 IOU입니다. 이것은 완전히 다른 개념입니다.

이 두 가지가 비슷한 이름을 가지고 있다는 건 좋지만 말이죠. IoU의 정의는 합집합에 대한 교집합입니다.

다음에 YOLO의 출력을 더 잘 작동시키기 위해 사용할 수 있는 도구인 non-max 억제에 대해 논의하겠습니다.
