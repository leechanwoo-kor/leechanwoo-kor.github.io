---
title: "[Ⅳ. Convolutional Neural Networks] Object Detection (4)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Deep Learning
  - Facial Recognition System
  - Convolutional Neural Network
  - Tensorflow
  - Object Detection and Segmentation
toc: true
toc_sticky: true
toc_label: "Object Detection (4)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/183551502-3482e2d7-efb0-4815-9c94-b662606b4842.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Object Detection

## Detection Algorithms

### Non-max Suppression

지금까지 이것에 대해 배웠던 객체 감지의 문제점 중 하나는 알고리즘이 동일한 객체에 대해 다수의 감지를 찾을 수 있다는 것입니다. 객체를 한 번만 탐지하는 게 아니라, 여러 번 탐지 할 수 있습니다. non-max 억제는 알고리즘이 각 객체를 한 번만 탐지하는지 확인하는 방법입니다. 예를 들어 봅시다.

#### Non-max Suppression Example

![image](https://user-images.githubusercontent.com/55765292/186291511-a5cbe088-55ac-4518-9b57-bbf63af54cec.png)

이 이미지에서 보행자, 자동차 및 오토바이를 감지하고 싶다고 가정 해 보겠습니다. 이 위에 격자판을 배치 할 수 있습니다.

![image](https://user-images.githubusercontent.com/55765292/186291560-a7827f6c-5e54-4fdd-b78b-c1d118e3b406.png)

이것은 $19 \times 19$ 격자판 입니다. 자, 기술적으로 이 차는 단지 하나의 중간 지점을 가지고 있기 때문에, 단지 하나의 격자판 셀에 할당되어야 합니다. 그리고 왼쪽의 차에는 격자판 중간 지점이 하나뿐이므로 기술적으로 격자판 셀 중 하나만이 차가 있다는 것을 예측할 것입니다.

실제적으로, 이 분할 셀들 각각에 대해 객체 분류와 위치 파악 알고리즘을 실행하고 있습니다. 따라서 이 분할 셀은 자동차의 중심이 그 안에 있다고 생각할 수도 있고 이렇게 할 수도 있고, 이렇게 할 수도 있고, 왼쪽의 자동차도 마찬가지 일 수 있습니다.

아마도 이 상자뿐만 아니라 이전에 보았던 테스트 이미지 일 경우 그 상자가 자동차 에있는 것, 아마도 이 상자, 이 상자 및 아마도 다른 사람들도 또한 자동차를 찾은 것으로 생각할 것입니다. 

non-max 억제가 어떻게 작동하는지 예제를 통해 살펴 보겠습니다 

![image](https://user-images.githubusercontent.com/55765292/186291613-cb302d5a-136b-4e07-a6a7-75f9ba12417e.png)

361 개의 격자판 셀에 있는 모든 그리드 셀에서 이미지 분류 및 로컬라이제이션 알고리즘을 실행하고 있기 때문에 많은 사람들이 손을 들고 "내 $P_c$, 여기에 객체가 있고 크다" 라고 생각할 수 있습니다.

19의 제곱, 즉 361 개 중에서 두 개의 격자판 셀을 가진 것이 아니라 그들은 객체를 감지했다고 생각하는 것이죠. 따라서 알고리즘을 실행할 때 각 객체에 대해 여러 감지가 이루어질 수 있습니다.

Non-max 억제가 하는 일은 이러한 감지를 깨끗하게 정리하는 것입니다. 자동차 당 하나의 탐지만 하게 되는 것이죠. 자동차 당 여러 개의 감지를 하는 것이 아닙니다.

자세히 말하자면, 이게 하는 일은 먼저 각각의 감지와 관련된 확률을 봅니다. 실제로 $P_c$ 에 $c_1, c_2$ 또는 $c_3$을 곱하는 것을 가리킵니다. 그러나 지금은 단지 $P_c$가 감지 될 가능성을 말합니다.

그리고 이것은 우선 가장 큰 것을 취하는데요. 이 경우 0.9이며, 그것이 말하는 것은 "그건 내 가장 자신있는 감지입니다. 그러니 이걸 밝아지게 하고, 여기에서 자동차를 발견했다" 입니다.

그렇게 하고 나면 non-max 억제 부분은 남아있는 모든 직사각형을 보게 되며, 많이 겹쳐있고 높은 IoU를 가지고 있으며, 막 출력 한 것을 가지고 있는 모든 것들은 억제되어질 것입니다.

0.6과 0.7의 이 두 직사각형은 이 둘 모두 밝은 파란색 직사각형 모양으로 많이 겹쳐집니다. 따라서, 여러분은 이 둘을 억제시켜서 그것들이 지금 억제되고 있는 중이라는 걸 보여주기 위해 어둡게 만들 것입니다.

다음으로는, 남아있는 직사각형을 살펴보고 가장 높은 확률과 가장 높은 $P_c$를 가진 것을 찾아내십시오. 왼쪽의 경우에 이것은 0.8 입니다.

이 방법대로 하고 ‘여기에서 자동차를 탐지해냈어요’ 라고 말하기로 합시다. 그리고 나서, non-max 억제파트는 높은 IoU를 가진 다른 것들은 지워버릴 것입니다.

그럼 이제 모든 직사각형은 밝아지거나 어두워졌습니다. 어두워진 직사각형들을 없애고 싶다면 밝아진 것들만 남기고 그러면 이것들이 여러분의 두 개의 최종 예측이 됩니다. 이것은 non-max 억제입니다.

non-max는 최대의 확률 분류를 아웃풋하지만 최대치가 아닌 근접한 것을 억제 할 것임을 의미합니다. 따라서 이름이 non-max 억제인 것이죠.

#### Non-max Suppression Algorithm

![image](https://user-images.githubusercontent.com/55765292/186294054-52f2c521-546e-4778-bb18-1121417ee377.png)

알고리즘의 세부 사항을 살펴 보겠습니다. 먼저, $19 \times 19$ 크기의 그리드에서 $19 \times 19 \times 8$ 아웃풋 볼륨을 얻습니다. 이 예시에서는 여러분이 자동차 탐지만 한다고 간소화시켜 보겠습니다. 

따라서, $c_1, c_2, c_3$ 를 제거하고, 이 라인이 $19 \times 19$ 의 각각 즉 361, 19제곱이니까요. 361 포지션의 각각에 다음과 같은 아웃풋 예측 값을 얻게 됩니다.

이는 객체가 있을 확률과 바운딩박스 입니다. 객체가 하나만 있다면 $c_1, c_2, c_3$ 예측은 없습니다. 이제 non-max 억제와 친숙해지기 위해 여러분이 할 일은 모든 상자를 버리고 $P_c$가 특정 임계 값보다 작거나 같은 바운딩박스의 모든 예측을 무시하는 것입니다. 객체가 있을 확률이 0.6만큼 된다고 생각되지 않는다면 그것을 그냥 제거 하십시오.

이로 인해 모든 낮은 확률 출력 상자가 발생했습니다. 이것에 대해 생각하는 방법은 각각의 361 위치에서 경계 상자를 출력하는 것입니다. 좋은 확률을 가진 경계 상자와 함께 말이죠. 따라서 우리는 낮은 확률로 배정 된 모든 경계 상자를 버릴 것입니다.

다음으로는, 아직 버려지거나 처리되지 않은 나머지 경계 상자가 있는 동안 가장 높은 확률을 가지고 있고, 가장 높은 $P_c$를 가지고 있는 상자를 반복적으로 골라서 예측으로 출력 하세요. 이것은 이전 그림에서 경계 상자 중 하나를 가져 와서 색상을 더 밝게 만드는 과정입니다.

그래서 거기에 차가 있다는 예측을 출력하기로 합시다. 그런 다음 나머지 상자를 버립니다. 예측으로 출력하지 않았거나 이전에 버려지지 않은 상자를 버리는 겁니다.

따라서 오버랩이 크고 IOU가 높은 나머지 상자는 이전 단계에서 출력한 상자와 함께 폐기합니다.

while loop에 있는 이 두 번째 단계는 이전 그림에서 본 것처럼 남아있는 경계 상자를 어둡게 만드는 것입니다. 이것은 더 밝게 만들고 강조했던 경계 상자와 많은 겹침 부위를 가지고 있습니다.

아직 처리되지 않은 남아있는 상자들이 여전히 있다면 상자 각각을 취해서 예측 값으로 이것을 출력시키던지 혹은 너무 높은 겹침이나 IoU 때문에 버리게 될 때까지는 여러분은 이것을 계속 진행하세요.

이 IoU는 감지된 물체 중 하나의 예측된 자리 때문에 방금 출력했던 상자들 중 하나를 가지고 있습니다. 이번에는 단 하나의 객체만 사용하여 알고리즘을 설명했습니다.

보행자, 자동차, 오토바이 등 3가지 물체를 실제로 감지하려고 하면 출력 벡터에 3 가지 추가 구성 요소가 생깁니다. 해야 할 일은 각각 non-max억제를 독립적으로 3회 수행하는 것입니다. 출력 클래스 당 하나씩입니다.

여기까지 non-max 억제였습니다. 우리가 설명한 객체 감지 알고리즘을 실행한다면 여러분은 꽤 괜찮은 결과를 얻게 됩니다.

그러나 YOLO 알고리즘의 토론을 끝내기 전에 제가 공유하고 싶은 마지막 아이디어가 하나 있습니다 이 아이디어는 알고리즘이 훨씬 잘 작동하도록 만들어 주고 앵커 상자를 사용하는 것입니다.


### Anchor Boxes

지금까지 보았듯이 객체 감지 문제 중 하나는 각 격자판 셀이 하나의 개체만 감지 할 수 있다는 것입니다. 격자판 셀이 여러 객체를 탐지하려면 어떻게 해야 할까요? 여기 당신이 할 수 있는 것이 있습니다. 앵커 상자의 아이디어를 사용할 수 있습니다. 우선 예제를 봅시다.

#### Overlapping Objects

![image](https://user-images.githubusercontent.com/55765292/186297111-b29fae1d-71e8-494e-b760-aa5e03f38e71.png)

이런 이미지가 있다고 가정 해 봅시다 이 예제에서는 $3 \times 3$ 격자판을 계속 사용하려고 합니다. 보행자의 중간 점과 차량의 중간 점이 거의 같은 위치에 있고 둘 다 동일한 격자판 셀에 속한다는 점을 아셔야합니다.

격자판 셀의 경우, Y가 보행자, 자동차, 오토바이 등 3가지 원인을 감지할때 벡터를 출력하면 두 가지 감지를 출력할 수 없습니다. 그래서 출력할 감지 중 하나를 선택해야 합니다.

앵커 상자에 대한 아이디어를 가지고 여러분이 해야 할 일은 앵커 상자 또는 앵커 상자 모양이라는 두 가지 모양을 사전에 정의하는 것입니다. 그리고 여러분이 이제 하려는 일은 두 개의 앵커 상자를 가진 두 개의 예측과 연관시킬 수 있는가 입니다.

일반적으로 5 개 또는 그 이상의 앵커 상자를 사용할 수 있습니다. 그러나 이번에는 설명을 쉽게 하기 위해 앵커 상자 두 개를 사용하려고 합니다.

왼쪽에 있는 이 벡터 대신에 교차 라벨을 어떤 것인지 정의하세요 기본적으로 이것을 두 번 반복 하는 것입니다.

여러분은 $P_c, b_x, b_y, b_h, b_w, c_1, c_2, c_3$를 가질 것이며, 이것들은 앵커 상자 1과 관련된 8개의 출력입니다. 그리고 나서 여러분은 $P_c, b_x$ 그리고 아래로 $c_1, c_2, c_3$ 및 그리고 앵커 상자 2와 관련된 다른 8 개의 출력이 있습니다.

보행자의 모양이 앵커 상자 1 및 앵커 상자 2의 모양과 더 유사하기 때문에 이 8 개의 숫자를 사용하여 $P_c = 1$로 인코딩 할 수 있습니다.

보행자가 있습니다. 이것을 사용하여 보행자 주변의 바운딩박스를 인코딩 한 다음 이 객체를 사용하여 해당 객체가 보행자임을 인코딩합니다.

그리고 자동차 주변의 상자가 앵커 상자 1보다 앵커 상자 2의 모양과 더 비슷하기 때문에 이걸 이용해서 이 두 번째 객체가 자동차라는 것을 인코딩 할 수 있습니다.

그리고 바운딩 박스를 가지고 있는데요. 검출된 차량과 관련된 모든 파라미터가 되도록 해야합니다.

#### Anchor Box Algorithm

![image](https://user-images.githubusercontent.com/55765292/186297271-e06092c1-70dd-4f2a-94fe-d7112540d108.png)

요약하면, 이전에 앵커 상자를 사용하기 전에 다음과 같은 것을 수행했습니다. 이것은 훈련 세트와 훈련 세트 이미지를 위한 것인데요. 객체는 그것의 중간 지점에 해당하는 격자판 셀에 할당되는 것이었죠.

그래서 출력 y는 $3 \times 3$ 격자판이기 때문에 $3 \times 3 \times 8$입니다 그리고 각 격자판 위치에서 출력 벡터는 $P_c$ 다음으로 경계 상자 그리고 $c_1, c_2, c_3$을 앵커박스와 함께 가지고 있었습니다. 여러분은 이제 다음의 것을 하면 됩니다.

이제 각 객체는 이전과 같은 격자판 셀에 할당되고 객체의 중간 점을 포함하는 격자판 셀에 할당되지만 그러나 이것은 객체 모양과 함께 IoU가 가장 높은 격자판 셀을 가진 앵커 상자에 할당됩니다.

따라서 두 개의 앵커 상자가 있는데요. 객체를 가져 와서 보시죠. 그래서 여러분이 이 모양을 가진 객체를 가지고 있다면 두 앵커 상자를 취하세요. 어쩌면 하나의 앵커 상자는 앵커 상자 1 인이 모양입니다. 어쩌면 앵커박스 2는 이 모양이고 다음으로 2개의 앵커 상자 중 어느 쪽이 IoU가 높은지 확인할 수 있습니다. 

이것은 경계 상자를 통해 그려집니다 그게 어느 것이든, 그 객체는 격자판 셀이 아니라, 한 쌍으로 할당됩니다. 이것은 그리드 셀, 앵커 상자 쌍으로 할당 됩니다. 이것이 대상 라벨에 해당 객체가 인코딩되는 방법입니다.

그리고 이제 출력 y는 $3 \times 3 \times 16$이 됩니다. 이전 슬라이드에서 보았듯이 y는 이제 16 차원입니다. 아니면 원하시면, 이것을 $3 \times 3 \times 2 \times 8$로 볼 수도 있습니다.

왜냐하면 이제 앵커 상자가 있고 y는 8 차원이기 때문입니다. y가 8차원이 되는 것은 세 개의 객체 클래스가 있기 때문입니다. 더 많은 객체들이 있다면 y 차원은 훨씬 높아질 것입니다.

#### Anchor Box Example

![image](https://user-images.githubusercontent.com/55765292/186297349-857f049b-46bd-4b86-a8eb-45ba49809c36.png)

이제 완전한 예를 들어 봅시다. 이 격자판 셀을 위해 y를 지정해 봅시다. 그래서 보행자는 앵커 상자 1의 모양과 더 유사합니다.

보행자의 경우 이 벡터의 위쪽 절반에 이것을 할당 할 것입니다. 여기 객체가 하나 있는데요. 여기에 보행자와 연결된 객체들이 있을 겁니다. 그리고 보행자가 클래스 1 이라면 우리는 $c_1$에는 1, 그 다음에 0, 0 이 됩니다.

자동차의 모양은 앵커 상자 2와 더 유사합니다. 그러면 이 벡터의 나머지 부분이 1이 되고 자동차와 연결된 경계 상자가 있고, 자동차가 $c_2$일 것이고요. 그래서 0, 1, 0 이 됩니다. 이게 바로 이 화살표가 가리키고 있는 것이 가운데 아래 쪽 격자판 셀에 대한 라벨 y입니다.

자, 이 그리드 셀에 자동차만 있고, 보행자가 없으면 어떻게 될까요? 단지 자동차만 있다면 자동차 주변에 경계 상자 모양이 앵커 상자 2 와 여전히 더 많이 유사하다고 가정하면 그러면 타겟 라벨 Y는 여기 자동차만 있고 보행자는 없다고 생각해보면 앵커 상자 2 의 구성 요소들과 여전히 똑같을 것입니다.

이것은 앵커 상자 2에 대응하는 벡터의 일부입니다. 앵커 상자 1에 대응하는 벡터 부분에 대해서는 여러분이 할 수 있는 것은 여기엔 객체가 없다고 생각하는 것입니다. 따라서 $P_c$ 는 0이고, 이 나머지 부분은 신경 쓰지 않아도 되는 부분이 됩니다.

이제 몇 가지 추가 세부 사항만 말씀드리겠습니다. 동일한 격자판 셀에 앵커 상자가 두 개 있지만 객체가 세 개 있으면 어떻게 될까요? 이게 바로 이 알고리즘이 잘 처리하지 못하는 경우입니다. 이런 일은 생기지 않기를 바랍니다.

하지만 만약 그렇다면 이 알고리즘은 이를 처리하는 데 좋은 방법을 가지고 있지 않습니다. 그 경우 디폴트 타이브레이커에 영향을 줄 뿐입니다.

동일한 격자판 셀과 연결된 두 객체가 있지만 두 객체 모두 앵커 상자 모양이면 어떻게 될까요? 또 다시 이 알고리즘이 제대로 처리하지 못하는 또 다른 경우입니다.

그러할 때 타이브레이크의 디폴트 방식으로 영향을 주면 여러분의 데이터 세트에서는 이런 일이 생기지 않길 바랍니다. 이게 그리 많이 생기는 일은 아닙니다. 이것이 또한 성능에도 그다지 영향을 미치지 않습니다 

---

이렇게 해서 앵커 상자에 대한 내용을 다루어 보았습니다. 두 개의 객체가 동일한 격자판 셀에 나타났을 때 처리하는 방법에 대해 앵커 상자에 동기를 부여했지만, 실제로는, 그런 일은 거의 없으며, 특히 $3 \times 3$ 격자판이 아닌 $19 \times 19$ 크기의 격자판을 사용하는 경우에는 더욱 그렇습니다. 361개 셀을 가진 두 개의 객체가 같은 중간 점을 가질 확률은, 일어날 수는 있는 일이지만, 그리 흔하지는 않습니다.

앵커 상자가 제공하는 더 나은 동기 부여 또는 더 나은 결과는 학습 알고리즘을 더 잘 전문화할 수 있다는 것입니다. 특히나, 여러분의 데이터세트가 보행자들처럼 키가 크고 마른 객체이고 자동차같이 약간 하얀 객체들이라면 학습 알고리즘을 전문화 시켜서 몇몇 출력들이 자동차처럼 하얗고, 뚱뚱한 객체들을 인식하는 것을 전문화시킬 것입니다. 몇몇 출력 유닛이 보행자처럼 키 크고 마른 객체들을 인식하는 것을 전문화시켜 줄 것입니다.

마지막으로 앵커 상자는 어떻게 선택하면 되죠? 사람들이 직접 그것들을 선택하기도 했었고 감지하려고 하는 유형들을 커버할 것으로 보이는 다양한 모양의 앵커상자 모양을 다섯개나 열 개 선택하기도 했었습니다.

훨씬 많이 발전된 버전에 따르면 머신러닝에 대해 다른 지식을 가진 사람들에게는 흔한 것입니다. 그리고 이것을 최신 YOLO 연구 논문 중 하나에서 하는 더 좋은 방법은 K-평균 알고리즘을 사용하 두 가지 유형의 객체 모양을 그룹화하는 것입니다. 또한, 여러분이 감지하고자 하는 몇 개의, 어쩌면 몇 십개의, 객체 클래스의 전형적인 대표원 즉, 앵커 상자 세트를 고르는데에 사용할 수 있습니다.

이것이 앵커 상자를 자동적으로 고를 수 있는 훨씬 발전된 방식입니다. 만약 여러분이 다양한 모양들을 직접 선택한다면 객체 모양 세트를 합리적으로 확장하게 되고 여러분은 몇 개의 키가 크고 마른 것 몇 개의 뚱뚱하고 하얀 것을 감지하길 원할 것입니다.

이것들에도 효과가 있을 겁니다. 이것이 바로 앵커 상자입니다. 다음에는 지금까지 본 모든 것을 YOLO 알고리즘으로 다시 연결해 봅시다.
