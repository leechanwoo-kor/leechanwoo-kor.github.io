---
title: "[Ⅳ. Convolutional Neural Networks] Special Applications (4)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Deep Learning
  - Facial Recognition System
  - Convolutional Neural Network
  - Tensorflow
  - Object Detection and Segmentation
toc: true
toc_sticky: true
toc_label: "Special Applications (4)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/183551502-3482e2d7-efb0-4815-9c94-b662606b4842.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Special Applications

## Neural Style Transfer

### Style Cost Function

이전에 신경 스타일 변형을 위한 콘텐츠 비용 함수를 정의하는 방법을 살펴 보았습니다. 다음으로 스타일 비용 함수를 살펴 보겠습니다.

#### Meaning of the "style" of an image

![image](https://user-images.githubusercontent.com/55765292/187153434-b44f794d-edcc-48a6-9184-cefb508d22c2.png)

그렇다면 이미지의 스타일이란 무엇입니까? 이와 같은 인풋 이미지가 있다고 가정 해 봅시다. 여러분은 이런 컨볼네트를 보는 데에 익숙할 겁니다. 다른 레이어가 있는 특성를 계산하는 것이죠.

이미지 스타일의 척도를 정의하기 위해 $l$ 레이어를 선택했다고 가정 해 봅시다. 우리가 해야 할 일은 다른 채널을 가로질러 분포하는 활성 사이의 상관 관계로 스타일을 정의하는 것입니다. 이 레이어 $l$ 활성에서 말이죠. 그것이 의미하는 바는 이렇습니다.

레이어 $l$ 활성을 수행한다고 가정 해 보겠습니다. 이것은 $n_h \times n_w \times n_c$ 블록의 활성이 될 것이고 우리는 어떻게 서로 다른 채널을 통해 활성화가 상호 연관되어 있는지를 물어볼 것입니다.

이것이 의미하는 바를 설명하는 것이 어쩌면 약간 아리송하게 들릴지도 모릅니다. 이 활성 블럭을 가지고 다른 채널을 다른 색상으로 색칠해보겠습니다.

이 아래 예시에서 우리는 다섯 개의 채널을 가지고 있고 따라서 다섯 개의 색상을 사용하고 있죠. 물론 실제로는 신경망에 보통 다섯 개 보다 훨씬 많은 채널이 있습니다. 하지만 다섯 개를 사용하는 것이 더 쉽게 그릴 수 있겠죠.

이 이미지 스타일을 캡쳐하기 위해 우리가 다음과 같은 일을 해야 합니다.

첫 번째 두 채널을 봅시다. 빨간색 채널과 노란 채널, 즉 첫 번째 두 채널에서 활성이 어떤 관계를 가지는지 봅시다.

예를 들어, 오른쪽 하단 코너에 보면 첫 번째 채널의 있는 활성이 보이고, 두 번째 채널에도 활성이 있습니다. 이것이 여러분에게 번호 쌍을 주게 됩니다. 이 블록 활성을 가로질러 분포하고 있는 다른 위치를 보십시오.

그리고 두 쌍의 숫자를 보십시오. 하나는 빨간색인 첫 번째 채널이고 다른 하나는 노란색인, 두 번째 채널입니다. 이 두 쌍의 수를 보고 이 모든 위치를 보시면 이 모든 $n_h \times n_w$ 위치 말이죠. 이 두 숫자가 어떤 상관 관계를 가지는지 알 수 있습니다. 이 캡처는 왜 스타일을 하는 건가요?

#### Intuition about style of an image

![image](https://user-images.githubusercontent.com/55765292/187153557-955eca9f-771f-41a5-abe4-af9c8a429641.png)

또 다른 예시를 봅시다. 이전에 보신 시각화의 하나입니다. 이것은 Matthew Zeiler와 Rob Fergus의 논문에서 인용 한 것입니다.

빨간 신경은 논의를 위한 것이죠. 빨간 채널은 이 신경에 대응한다고 하면 그럼 $n_h$ 이 특정 위치에 있는 이 작은 수직 텍스처가 있다는 것을 알아낼 것입니다. 그리고 이 두 번째 채널, 노란색 두 번째 채널은 이 신경에 상응한다고 하면 이것은 이것은 흐릿한 주황색 패치를 보여줄 것입니다.

이 두 채널이 강한 상관 관계가 있다는 것은 무엇을 의미하나요? 그것들이 강한 상관 관계가 있다면 이 이미지의 이 이미지 부분이 미세한 수직 텍스처 유형을 가지고 있으면 이 이미지 부분도 이 주황빛 계열을 가지게 된다는 뜻입니다.

그렇다면 상관 관계가 없다는 뜻은 무엇인가요? 그것이 의미하는 바는 이 수직 텍스처가 있는 부분이 있더라도 이것은 주황빛 계열이 아닐 수도 있다는 의미입니다. 그리고 이 상관 관계는 이 높은 레벨의 텍스처 구성요소들이 이미지 부분에서 함께 발생할 수도 있고 그렇지 않을 수도 있다는 뜻입니다.

이 상관 관계의 정도는 하나의 측정 방법입니다. 다시 말해서, 높은 레벨의 피처들 예를 들어, 수직 텍스처나 주황빛 혹은 다른 물체들이 이런 한 이미지 상의 다른 부분에 위치할 때 얼마나 자주 같이 발생하고 얼마나 자주 같이 발생하지 않는지 측정하는 것입니다.

만약 스타일의 측정하기 위해 채널 간 상관 관계의 정도를 사용한다면 할 수 있는 일은 생성된 이미지에서 정도를 측정하는 것입니다. 이 첫 번째 채널은 두 번째 채널과 상관관계가 있거나 상관 관계가 없습니다.

그리고 이는 생성된 이미지 상에서 얼마나 자주 이런 유형의 수직 텍스처가 주황빛과 같이 발생하고 혹은 발생하지 않는지를 알려줍니다.

그리고 이는 생성된 스타일이 인풋 스타일 이미지와는 얼마나 비슷한지 그 측정치를 알려주는 것이죠. 이 직관을 공식화 해봅시다.

#### Style matrix

![image](https://user-images.githubusercontent.com/55765292/187153705-0e0dc0e0-96b4-42c3-aaf1-769aabb5024f.png)

여러분이 할 수 있는 일은 주어진 이미지가 스타일 매트릭스라고 불리는 것을 계산하는 것입니다. 그것은 앞의 슬라이드에서 언급한 이 모든 상관 관계를 측정할 것 입니다.

따라서, 공식으로 말하자면 위 첨자 [$l$], 아래 첨자 $i, j, k$는 히든 레이어에서 포지션 $i, j, k$에서의 활성을 표시할 것입니다.

따라서 $i$ 는 높이를 가리키고, $j$ 는 너비를 그리고 $k$는 다른 채널들을 가로질러 분포하는 것을 가리킵니다. 이전 그림에서 다섯 개의 채널을 봤었는데요. $k$는 5개 채널을 가로지르는 것을 가리켰었죠.

따라서 스타일 매트릭스가 할 일은 매트릭스 클래스 G의 [$l$]제곱입니다. 그리고 이것은 $n_c \times n_c$ 차원의 매트릭스가 될 것이고, 바로 제곱 매트릭스가 되겠죠. 여러분에겐 $n_c$ 채널들이 있다는 것을 기억하십시오. 그리고 또한 그들 각각의 쌍이 얼마나 상관되어 있는지를 측정하기 위해 $n_c \times n_c$ 차원의 매트릭스도 있습니다.

특별한 $G, l, k, k'$은 채널 $k$에서의 활성화와 채널 $k'$에서의 활성화가 얼마나 상관 관계가 있는지를 측정 할 것입니다. 여기서는 $k$와 $k'$은 1부터 $n_c$까지의 범위가 되고 이는 곧 이 쪽 위에 있는 레이어의 그 채널의 개수입니다.

그래서 더 공식적으로 $G$와 $l$를 계산하는 방법 이 원소들을 계산하는 공식을 여기에 적어보겠습니다.

이것의 $k$와 $k'$ 이것은 $i$의 합, $j$ 의 합, $i, j, k$ 레이어의 액티베이션 곱하기 액티베이선 $i, j, k'$.

자, 여기서 $i$와 $j$는 블럭에서 다른 위치를 가르 지르는 것을 가리킨다는 것을 기억하세요. 즉, 높이와 너비를 가리킨다는 것을요. 따라서 $i$ 는 1부터 $n_h$까지의 합이고, $j$는 1부터 $n_w$까지의 합. $k$ 와 $k'$은 이 채널을 가리키므로 $k$ 와 $k'$ 는 1부터 신경망 레이어에 있는 채널의 총 개수 가 되는 것입니다.

그래서 이 모든 것이 하는 것은 이미지의 서로 다른 위치에서 높이와 너비에 대한 합이고 채널 $k$와 $k'$ 의 액티베이션을 곱하는 것입니다. 이것이 $G_{kk'}$의 정의입니다.

이 매트릭스 G를 계산하기 위해 $k$ 및 $k'$ 모든 값에 대해 이것을 하는 것입니다. 이는 스타일 매트릭스라고도 불립니다. 만약 이 액티베이션 둘 다 함께 커지는 경향이 있으면 $G_{kk'}$ 도 커질 것이고, 반면에 이 둘이 상관이 안되면, $G_{kk'}$ 는 작아질 것입니다.

그리고 기술적으로 저는 직감을 전달하기 위해 상관 관계라는 용어를 사용 해왔습니다. 그러나 이것은 실제로 비 표준화된 십자 영역입니다. 왜냐하면 우리는 평균을 뺄셈을 하고 있지 않고 이것은 단지 이 요소들에 의해 직접 곱해지고 있기 때문입니다. 이것이 이미지의 스타일을 계산하는 방법입니다.

그리고 여러분은 실제로 두 스타일 이미지 s, n을 생성 된 이미지 G에 대해 이렇게 할 것입니다. 그래서 이것이 스타일 이미지라는 점을 구별하기 위해 S 에 둥근 괄호를 써넣겠습니다. 그러면 이것이 이미지 S에 대한 스타일 이미지 임을 표시할 수 있고, 이것들은 이미지 S의 활성이 되는 것입니다. 그리고 나서는 생성 된 이미지에 대해 똑같은 것을 계산하십시오.

따라서 이것은 정말로 똑같은 것입니다. $i$ 의 합, $j$ 의 합, $a_{ijk}$ 그리고 $l, a_{ijk}$ 그리고 $l$ 그리고 이 합계 부분도 같습니다. 이것을 따라 해봅시다.

그러면 이것이 생성된 이미지 라는 것을 표시하길 원할 것입니다. G 에 둥근 괄호를 표시하겠습니다. 그래서, 여러분은 두 개의 매트릭스를 가지고 있습니다. 이 매트릭스은 이미지 S가 가진 스타일이고, 이것은 이미지 G의 스타일이고, 그런데 이 매트릭스를 표시하기 위해서 알파벳 대문자 G를 사용해왔군요.

선형 대수학에서는 이것들을 그램 매트릭스gram matrix 라고 부릅니다. 하지만 이 강의에서 저는 스타일 매트릭스라는 용어를 사용하겠습니다. 이 용어 그램 매트릭스는 대부분 대문자 G를 사용하고 이 매트릭스들을 표시하기 때문입니다.

마지막으로, 비용 함수, 스타일 비용함수입니다.

여러분이 만약 S 와 G사이의 레이어 l 에서 이걸 하고 있다면, 여러분은 이 차이점을, 이 두 매트릭스 사이의, Gl G 제곱 그리고 이 매트릭스, 이건 그냥 이전 강의들에서 가져온 것들입니다.

이것은 이 두 매트릭스 사이에서 생긴 요소 간 차이 값에 제곱해서 모두 합한 것입니다.

정규화 상수는 그다지 중요하지 않습니다. 왜냐하면 이것이 어떤 하이퍼 파라미터 b를 곱하기 때문입니다.

#### Style cost Function

![image](https://user-images.githubusercontent.com/55765292/187153820-0ca5c506-2e31-447e-a58d-b5f2b7103833.png)

마무리 짓자면 이전 그림에서 보아 듯이 이것은 레이어 $l$을 사용하여 정의된 스타일 비용 함수입니다. 이것은 기본적으로 이미지 S와 이미지 G에서 계산 된 두 개의 스타일 매트릭스 사이의 Frobenius 표준입니다.

Frobenius의 F, 그리고 제곱을 합니다. 이것은 그다지 중요하지 않은 단지 낮은 정규화 상수에 의해서가 아닙니다. 중요하지 않은 정규화 상수 그리고 마지막으로, 만약 여러분이 여러 개의 다른 레이어로부터 스타일 비용 함수를 사용한다면 시각적으로 더 훌륭한 결과를 얻을 수 있습니다.

따라서, 여러분이 정의할 수 있는 전체 스타일 비용 함수는 모든 다른 레이어들의 합, 그 레이어의 스타일 비용 함수, 몇몇 파라미터 세트로 추가적인 하이퍼 파라미터로 가중치, 여기에 $\lambda^{[l]}$로 표시하여 가중치를 주어 정의 내려야 합니다.

따라서 이것이 하는 일은 여러분이 신경망에서 다른 레이어를 사용하도록 하는 것입니다. 앞의 것들은 모서리와 같은 비교적 간단한 낮은 레벨 피처를 측정합니다. 또한 후기 레이어에서는 높은 수준의 피징를 측정하고 스타일을 계산할 때 신경망이 낮은 레벨과 높은 레벨의 상관 관계를 모두 고려하도록 합니다.

다음 연습에서는 이 유형의 매개 변수 람다에 대해 합리적인 선택이 될 수 있는 것에 대해 더 많은 직관을 얻을 수 있을 것입니다.

정리해보면 여러분은 이제 전반적인 비용 함수를 정의 내릴 수 있습니다. 알파 곱하기 C와 G 사이의 컨텐츠 비용 더하기 베타 곱하기 S와 G 사이의 스타일 비용.

이렇게 하면 정교한 방법으로 최적화된 알고리즘을 얻을 수 있습니다. 그럼 정규화된 이미지 G를 찾을 수 있고 이 비용함수 J(G)를 최소화 할 수 있습니다. 그리고 이렇게 하시면 멋져 보이는 신경 예술 작품을 만들어낼 수 있습니다. 또한 이렇게 하시면 예쁘고 멋진 신기한 예술 작품을 만들어 낼 수 있을 것입니다.


### Convolutional Networks in 1D or 3D

여러분은 컨볼네트에 대해 많은 것을 배웠습니다. 컨볼네트의 아키텍처부터 이미지 인식을 어떻게 사용하는지, 객체 감지, 얼굴 인식 및 신경 스타일 변형에 이르기까지 모든 것을 배웠습니다.

그리고 비록 대부분의 논의가 2D 같은 이미지에 초점을 맞추고 있지만 이미지들은 아주 널리 보급되어 있어서 많은 아이디어가 2D 이미지 만이 아니라 3D 데이터나 1D 데이터에도 적용됩니다.

#### Convolutions in 2D and 1D

![image](https://user-images.githubusercontent.com/55765292/187156971-b5514de7-63e4-4112-8eb4-f95ae4cf8eb9.png)

처음에 2D 컨볼루션에 대해 배웠습니다. $14 \times 14$ 이미지를 인풋하고 $5 \times 5$ 필터로 컨볼빙 하는 것이었죠. 그리고 $14 \times 14$ 가 $5 \times 5$ 와 어떻게 컨벌브 되어 있는지를 보았을 때 $10 \times 10$ 출력을 얻을 수 있었습니다.

여러 채널이 있는 경우, 어쩌면 $14 \times 14 \times 3$ 이것은 $5 \times 5$ 이고, 똑같이 3 을 매치 시켰죠. 그리고 나면 여러 개의 필터가 생기는데, 즉 16개 필터가 되고, 최종적으로 $10 \times 10 \times 16$이 됩니다.

이와 비슷한 개념으로 1D 데이터에도 적용됩니다.

예를 들어, 왼쪽에는 심전도라고도 하는 심전도 신호가 있습니다. 기본적으로 가슴 위에 전극을 놓으면 심장 박동에 따라 가슴에 위에서 달라지는 작은 전압을 측정합니다. 심장 박동에 의해 생성 된 작은 전기파는. 한 쌍의 전극으로 측정 할 수 있기 때문에 그래서 이것은 누군가의 심장이 뛰는 EKG 즉 심전도입니다.

그래서 이 봉우리들 각각은 하나의 심장 박동에 해당합니다. 만약 EKG 신호를 사용하여 의료 진단을 하고 싶다면 예를 들어, 여러분은 1D 데이타를 가지게 될 것입니다. 왜냐하면 EKG는 각 순간의 전압을 보여주는 시계열의기 때문입니다.

따라서 $14 \times 14$ 차원 인풋이 아닌 14 차원 인풋 만 있을 수 있습니다. 그리고 이 경우, 1 차원 필터를 사용하여 이를 컨볼루션 할 수 있습니다. 따라서 $5 \times 5$가 아닌 5차원 필터 만 있으면 됩니다.

따라서 2D 데이터를 사용하면 컨볼루션 통해 동일한 $5 \times 5$ 피쳐 검출기를 사용하여 이미지 전체의 여러 위치에 이것을 적용 할 수 있습니다. 이것이 $10 \times 10$ 출력을 얻는 방법입니다. 1D 필터로 할 수 있는 것은 5 차원 필터를 사용하고 이 1D 신호를 통해 여러 다른 위치에서 유사하게 적용하는 것입니다.

그리고 만약 여러분이 이 컨볼루션을 적용한다면 여러분이 이 14차원의 것이 5 차원의 것으로 컨벌브 되어 10 차원 아웃풋을 제공할 것입니다.

다시 말하지만, 여러 개의 채널이 있는 경우 이 경우는 채널 1개만 사용할 수 있죠. EKG는 한 개의 전극만 있으니까요. 따라서 $5 \times 1$ 이죠.

필터가 16 개인 경우, 결국 거기에$ 10 \times 16$이 있고 이것은 컨볼네트의 한 층이 될 수 있습니다. 그리고 컨볼네트의 다음 레이어에 대해, $10 \times 16$ 차원 인풋을 입력하면 5 차원 필터로 다시 컨벌루션 할 수 있습니다.

그렇다면 여기에는 16 개의 채널이 있으므로 일치하는 채널이 있습니다. 32 개의 필터가 있는 경우, 다른 레이어의 출력은 $6 \times 32$입니다. 필터가 32 개이죠. 그렇죠?

그리고 2D 데이터와 유사하게, 이것은 $10 \times 10 \times 16$ 데이터와 비슷하며. $5 \times 5 \times 16$으로 컨벌브 합니다. 그러면 일치하는 것이 생기죠. 그러면 $6 \times 6$ 차원 출력이 나오며 32 개의 필터가 있습니다. 이것이 32 개의 필터가 만들어지는 곳이죠.

따라서 이러한 모든 아이디어는 1D 데이터에도 적용됩니다. 여기에서 이와 같은 동일한 기능 감지기를 다양한 위치에 적용 할 수 있습니다.

예를 들어 심전도 신호에서 다른 심 박동을 감지합니다. 그러나 이 시계 열을 따라 다른 위치에서도 심박동을 감지하기 위해 동일한 피처 세트를 사용하여 1D 데이터에서도 컨볼네트를 사용할 수 있습니다.

1D 데이터 응용 프로그램과 함께 여러분은 실제로 recurrent neural network를 사용하는데 다음에 배우게 됩니다.

그러나 어떤 사람들은 이러한 문제에서 컨볼네트들을 사용해 볼 수도 있습니다. 다음에는 시퀀스 모델 상에서 recurring neural network과 LCM 그리고 이런 다른 모델들에 대해서 이야기하도록 하겠습니다.

우리는 1D 컨볼네트 과 순차적 데이터에 따라 명시적으로 설계된 다른 모델을 사용하는 것에 대한 장단점에 대해 이야기 할 것입니다. 이것이 2D에서 1D 로의 일반화입니다.

3D 데이터는 어떻습니까? 3 차원 데이터 란 무엇입니까? 1D 숫자 목록이나 2D 행렬 대신에 3 차원 인풋 볼륨 인 3D 블록이 있습니다.

#### 3D Data

![image](https://user-images.githubusercontent.com/55765292/187157149-d7ab367c-4f52-43ed-aed5-2a788a3c6234.png)

여기에 CT 스캔을 하는 경우의 예가 있습니다. 이것은 신체의 3 차원 모델을 제공하는 X-ray 스캔 유형입니다. 그러나 CT 스캔 이하는 일은 신체를 통해 다른 조각을 필요로 한다는 것입니다.

그래서 여기서 하고 있는 CT 스캔을 통해 스캔 할 때, 여러분은 인간의 몸통의 다른 슬라이스들이 어떻게 보이는지 볼 수 있습니다. 그래서이 데이터는 근본적으로 3 차원 입니다

![image](https://user-images.githubusercontent.com/55765292/187157172-2f667046-10b6-4825-af88-12c40ca59e24.png)

![image](https://user-images.githubusercontent.com/55765292/187157264-fb2aa4b2-47c6-4021-bd39-fb65b56d1855.png)

![image](https://user-images.githubusercontent.com/55765292/187157420-b82f4836-38fa-4f04-b9e1-89d1410c4f8e.png)

이 데이터를 생각하는 한 가지 방법은 데이터의 높이, 폭, 깊이가 같은지 여부입니다. 이것이 이 볼륨을 통과하는 다른 슬라이스 몸을 통과하는 다른 슬라이스입니다.

#### 3D convolution

![image](https://user-images.githubusercontent.com/55765292/187157105-6f64a656-61fe-494d-8196-815a2ca3ddee.png)

따라서 컨볼네트을 적용하여 이 3 차원 CAT 스캔 또는 CT 스캔에서 피쳐를 감지하려는 경우 첫 번째 슬라이드의 아이디어를 3 차원 컨볼루션으로 일반화 할 수 있습니다.

따라서 3D 볼륨이 있는 경우 단순화를 위해 $14 \times 14 \times 14$ 로, 즉, 인풋 CT 스캔의 높이, 너비 및 깊이를 말합니다.

다시 말하지만 이미지와 마찬가지로 모든 요소가 정사각형이어야 하며 3D 볼륨은 완벽한 큐브 일 필요는 없습니다.

따라서 이미지의 높이와 너비는 달라질 수 있으며 같은 방식으로 CT 스캔의 높이와 너비 및 깊이가 다를 수 있습니다. 하지만 여기서 토론을 단순화 시키기 위해 $14 \times 14 \times 14$를 사용하고 있습니다. 그리고 이것을 $5 \times 5 \times 5$ 필터로 바꾸면 이제 필터가 3 차원이어서 $10 \times 10 \times 10$ 볼륨이 됩니다.

기술적으로 채널 수인 경우 1을 사용할 수도 있습니다. 따라서 이것은 3D 볼륨 일 뿐이지만 데이터의 채널 수에 차이가 있을 수 있습니다. 그러면 1도 마찬가지입니다. 여기 채널 수와 여기 채널 수가 일치해야 하기 때문입니다.

그리고 나서 16 개의 필터가 있다면 $5 \times 5 \times 5 \times 1$이되고 다음 출력은 $10 \times 10 \times 10 \times 16$이 될 것입니다.

따라서 이것은 컨볼네트의 3D 데이터에 대한 하나의 레이어가 될 수 있습니다. 컨볼네트은 $5 \times 5 \times 5 \times 16$ 차원 필터로 다시 컨벌브 시킵니다. 따라서 이 채널 수는 평소처럼 데이터와 일치해야하며 32 개의 필터가 있는 경우. 여러분이 보았던 컨볼네트 이미지와 유사합니다.

그러면 $6 \times 6 \times 6$볼륨이 32채널을 가로지르게 됩니다. 3D 데이터는 또한 3차원 컨볼네트를 사용하여 직접 학습할 수 있습니다. 이러한 필터가 수행하는 작업은 실제로 3D 데이터, 즉, CAT 스캔, 3D 스캔의 한 예시인 의학 스캔, 이것들을 가로질러 피쳐를 감지하는 것 입니다.

그러나 3D 볼륨으로 처리할 수 있는 또 다른 데이터 예시는 바로 영화 데이터입니다. 다른 슬라이스는 영화를 통해 서로 다른 조각이 될 수 있습니다. 그리고 이것을 사용하여 모션이나 영화에서 행동을 취하는 사람들을 감지 할 수 있습니다.

2D 데이터에서 3D 데이터뿐만 아니라 1D까지 컨볼네트의 일반화에 관한 내용이었습니다. 이미지 데이터가 널리 보급되어 컨볼네트의 대다수가 이미지 데이터의 2D 데이터에 있지만 이 다른 모델들도 여러분에게 도움이 되기를 바랍니다.

여러분은 컨볼네트에 대해 많은 것을 배웠고 여러분의 많은 아이디어가 미래의 작업을 위해 유용하게 사용되기를 바랍니다.
