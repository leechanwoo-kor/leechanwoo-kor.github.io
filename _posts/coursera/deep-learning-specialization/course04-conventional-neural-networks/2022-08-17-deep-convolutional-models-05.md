---
title: "[Ⅳ. Convolutional Neural Networks] Deep Convolutional Models (5)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Deep Learning
  - Facial Recognition System
  - Convolutional Neural Network
  - Tensorflow
  - Object Detection and Segmentation
toc: true
toc_sticky: true
toc_label: "Deep Convolutional Models (5)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/183551502-3482e2d7-efb0-4815-9c94-b662606b4842.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Deep Convolutional Models

## Case Studies

### MobileNet Architecture

다시 오신것을 환영합니다. 지난 영상에서 여러분은 depthwise separable 컨볼루션에 대해 배우셨습니다. 이제 MobileNet을 구축 하기 위해 이것을 신경망으로 만들어 봅시다.

![image](https://user-images.githubusercontent.com/55765292/185034545-e719cc9b-2aa4-41d2-a069-7a97e4bd38da.png)

MobileNet의 주요사항은 이전에 여러분이 값비싼 컨볼루션 연산을 사용하던 모든 곳에 있습니다. 여러분은 이제 훨씬 적은 지출이 가능한 depthwise separable 컨볼루션 연산, depthwise 컨볼루션 연산의 구성과 그리고 pointwise 컨볼루션 연산을 대신 사용할 수 있습니다.

MobileNet v1 논문에는 특정 아키텍처가 있는데 이와 같은 블록을 사용하는 경우에는 13배입니다. depthwise 컨볼루션 연산을 사용하여 원래의 raw 입력 이미지에서 최종적으로 분류 예측을 하기 위해 13개의 레이어 스택을 갖습니다.

이 13개의 레이어 다음에 몇 가지 더 상세한 내용을 설명하자면 신경망의 마지막 몇 레이어들은 주로 풀링 레이어이며 완전히 연결된 레이어가 뒤따르고 Softmax가 뒤를 잇는데 클래스 분류 예측을 하기 위해서 입니다.

이것은 일반적인 컨볼루션 연산을 사용한 이전의 알고리즘보다 산출 비용이 훨씬 적게 들면서도 우수한 성능을 발휘하는 것으로 밝혀졌습니다. 이번에는 이 기본 MobileNet 아키텍처의 개선점을 하나 더 알려드리고자 합니다.

이는 MobileNets v2 아키텍처입니다. 이 알고리즘의 기능에 대해 꽤 빠르게 간단히 설명하겠습니다. 상세한 내용을 모두 조사하지 않아도 됩니다. 하지만 이것은 Mark Sandler와 그의 동료들이 발표한 논문인데요. 모바일 네트워크를 더욱 향상시킬 수 있습니다.

MobileNet v2에는 두 가지 주요 변경사항이 있습니다. 하나는 **잔류 연결residual connection**의 추가입니다. 이것은 ResNet를 다룰 때 학습하신 잔류 연결일 뿐입니다. 이 잔류 연결 또는 스킵 연결은 이전 레이어에서 입력을 가져와서 이를 합산하거나 다음 레이어로 직접 전달하여 구성 요소가 더 효율적으로 뒤로 전파되도록 합니다.

두 번째 변화는 확장 레이어로서도 사용할 수 있다는 것이며 자세한 내용은 다음 그림을 참조하시면 되고 depthwise 컨볼루션 전에 pointwise 컨볼루션으로 이어지고 이것을 pointwise 컨볼루션에서 투영법이라고 부릅니다.

실제로 동일한 작업이지만 다음 그림에서 볼 수 있기 때문에 다른 이름으로 지정합니다. MobileNet v2가 하는 일은 이 블록을 사용하고 그리고 이 블록을 몇 번 반복하여 여기서 13배를 한거처럼 MobileNet v2 아키텍처는 17번 이 작업을 하도록 선택하는데요.

이러한 블록 중 17개를 통과해 입력값을 초과한 다음 결국엔 완전히 연결된 일반적인 풀링 softmax로 끝나게 됩니다. 분류 예측을 만들기 위해서 입니다.

하지만 핵심적인 생각은 이런 블록들이 어떻게 또는 이와 유사하게 계산 비용이 감소시키는지 입니다. 여기에 있는 이 블록은 병목 현상 블록이라고도 합니다. MobileNet v2가 어떤 일을 하는지 자세히 알아봅시다.

#### MobileNet v2 Bottleneck

![image](https://user-images.githubusercontent.com/55765292/185034567-17e91ecd-271f-45ca-bcff-5ec8de7fec13.png)

이런 입력이 있었으니 $n \times n \times 3$이며 MobileNet v2 병목 현상은 입력 정보를 출력하여 직접 전달합니다. Resnet처럼 말이죠. 그런 다음 블록의 주요 비-잔류 연결 부분에 대해 먼저 여러분은 확장 연산자를 적용하고 그리고 그것이 의미하는 것은 여러분이 $1 \times 1 \times n_c$를 적용하는 것을 의미합니다.

이 경우 $1 \times 1 \times 3$차원 필터입니다. 그러나 여러분은 그것의 상당히 많은 수를 적용하는데 예를들어 18 필터일 경우 여러분은 이곳에 $n \times n \times 18$차원 블록이 나옵니다.

6의 확장 요소는 MobileNet v2 에서는 꽤 일반적인데 왜 의 입력이 $n \times 3$에서 $n \times 18$로 되는지 그리고 그것이 바로 우리가 확장이라고 부르는 이유입니다. 그것은 이것의 차원를 6으로 증가시키며 다음 단계는 depthwise separable 컨볼루션입니다.

약간의 패딩으로 여러분은 $n \times n \times 18$에서 동일한 차원으로 이동할 수 있습니다.

최근에 우리는 $6 \times 6 \times 3$부터 $4 \times 4 \times 3$까지 갔는데요. 왜냐하면 우리는 패딩을 사용하지 않았기 떄문입니다. 하지만 패딩을 통해 여러분은 $n \times n \times 18$차원을 유지할 수 있는데 여러분이 depthwise 컨볼루션을 적용해도 그것은 줄어들지 않습니다.

그 다음 pointwise 컨볼루션을 적용하면 이 경우에는 $1 \times 1 \times 18$-차원 필터로 컨볼빙 하는것을 뜻합니다. 예를 들어 여러분에게 3개의 필터와 c 프라임 필터가 있다면, $n \times n \times 3.인 출력의 결과를 얻게 되는데요.

왜냐하면 여러분에게 그러한 3개의 필터가 있기 때문입니다. 이 마지막 단계에서 우리는 $n \times n \times 18$에서 내려가 $n \times n \times 3$까지 그리고 MobileNet v2 병목 현상 블록에까지 갔습니다.

이 마지막 단계를 투영 단계라고 부르기도 하는데 그 이유는 $n \times 18$에서 $n \times 3$으로 하향 투영하기 때문입니다. 궁금하실 겁니다. 왜 우리는 이러한 병목현상 블록을 충족시키는 걸까요?

병목 블록은 확장 연산을 사용하여 병목 블록 내의 표현 크기를 증가시키는 두 가지 목표를 달성합니다. 이것은 신경망이 더 풍부한 기능을 배우게 해줍니다. 여기에는 더 많은 계산이 있습니다. 그러나 모바일 창치에 배치하는 경우 엣지 디바이스에서는 여러분은 자주 무거운 메모리 제약을 받습니다.

병목현상 블록은 pointwise 컨볼루션을 이용하거나 또는 더 작은 값 집합으로 다시 투영하는 순서에서 투영 작업을 하는데요. 따라서 다음 블록을 통과하면 이러한 값을 저장하는 데 필요한 메모리 양이 다시 줄어듭니다.

현명한 생각, 멋진 것은 병목현상 블록에서 그것은 더 많은 계산들을 가능하게 합니다. 따라서 여러분의 신경망이 풍부하고 복잡한 함수를 학습할 수 있습니다.

또한 레이어 간에 전달해야 하는 작업 크기의 메모리 양을 비교적 작게 유지합니다. 그렇기 때문에 MobileNet v2를 사용하면 MobileNet v1 보다 더 나은 성능을 얻을 수 있고 적은 양의 계산 및 메모리 리소스만 계속 사용하고 있습니다.

#### MobileNet

![image](https://user-images.githubusercontent.com/55765292/185034653-7060b988-7665-4d38-a7a7-9896bf0a8c48.png)

이 모든 것을 종합하면 MobileNet v1 및 v2에 대해 설명하는 초기 그림이 있습니다. MobileNet v2 아키텍처는 이 병목현상 블록을 17번 반복합니다. 만약 여러분의 목표가 분류를 만드는 것이라면 그 다음에는 보통 때처럼 이 풀링, 완전히 연결된 softmax 레이어 분류 출력을 생성합니다.

여러분은 이제 MobileNet v1과 v2의 주요 개념을 알게 되셨습니다. 데이터를 왼쪽에서 오른쪽으로 이동하면서 여러 도면층의 정확한 차원과 같은 몇 가지 추가 상세 내역을 보려면 다음과 같이 하시면 됩니다.

여러분은 Mark Sandler와 다른 사람들의 논문을 보셔도 됩니다.

이제 MobileNet v1 및 v2가 어떻게 작동하는지 depthwise separable 컨볼루션을 사용하고 병목 현상 블록을 사용하여 알게 되었습니다. 만약 여러분이 효율적인 신경망을 구축하시려면 아주 유용한 다른 하나의 아이디어가 있습니다. 그것은 효율적인 네트입니다. 그 아이디어를 이어서 간단히 살펴보도록 합시다.

#### MobileNet v2 Full Architecture

![image](https://user-images.githubusercontent.com/55765292/185034729-49b2403e-435f-43f2-a8ce-b04080ebdbcd.png)


### EfficientNet

MobileNet v1과 v2는 컴퓨팅 효율성이 더 높은 신경망을 구현하는 방법을 배웠습니다. 그러나 MobileNet이나 다른 아키텍처를 특정 장치에 맞게 튜닝 할 수 있는 방법이 있을까요?

컴퓨터 비전 알고리즘은 각기 다른 양의 컴퓨팅 리소스를 가진 다른 브랜드의 휴대폰이나 다른 엣지 장치용으로 구현하고 있을 것입니다.

산출이 조금 더 많다면 신경망이 조금 더 크면 정확도가 향상될 수 있고 산출에 제약이 있는 경우에는 조금 더 작은 신경망을 원할 수도 있습니다. 정확성을 희생하면서 조금 더 빠르게 동작할 수 있습니다.

특정 장치의 신경망을 자동으로 확장하거나 축소할 수 있는 방법은 무엇일까요?

EfficientNet은 이를 수행할 수 있는 방법을 제공합니다.

---

![image](https://user-images.githubusercontent.com/55765292/185043869-8ed24078-9b05-440c-a538-3d627b367a4d.png)

가령 여러분이 베이스라인 신경망 아키텍처가 있다고 가정할 때, 입력 이미지의 해상도는 r이고 새로운 네트워크의 깊이는 일정하며 레이어는 일정한 폭을 가집니다.

EfficientNet 논문의 저자들인 Mingxing Tan과 전 박사과정 학생인 Quoc Le는 일을 확장하거나 축소하기 위해 할 수 있는 세 가지를 관찰했습니다. 즉, 고해상도 이미지를 사용하는 것입니다. 따라서 새로운 이미지 해상도인 r 입니다.

이러한 영상에서 고해상도를 어떻게 표현해야 하는지 모르겠네요. 고해상도 이미지를 나타내기 위해 이 파란색 글로우를 사용하겠습니다. 아니면 이 네트워크를 훨씬 더 깊게 만들 수도 있습니다. 신경망의 깊이까지 d를 변경할 수도 있고, 레이어를 넓힐 수도 있습니다. 이들 레이어의 너비를 변경할 수도 있습니다.

문제는 특정한 산출 예산을 고려할 때 r, d, w 중 무엇을 선택하는 것이 좋은가 하는 것입니다. 또는 보유한 산출 리소스에 따라 이미지의 해상도, 깊이 및 신경망의 너비를 동시에 확대 또는 축소할 수 있는 복합 스케일링을 사용할 수도 있습니다.

여기서 어려운 점은 만약 여러분이 r, d 및 w를 확장하고 싶다면 이러한 각각의 규모를 얼마나 늘려야 할까요?

해상도를 두 배로 하고 깊이를 그대로 둘 것인지, 아니면 깊이는 두 배로 늘리고 나머지는 그대로 둘 것인지, 또는 해상도를 10% 만큼 증가시키거나, 깊이를 50%, 폭을 20 % 높일 수 있나요?

신경망을 확장하거나 축소하여 컴퓨팅 예산 내에서 최상의 성능을 얻기 위해 r, d 및 w를 절충하는 가장 좋은 방법은 무엇일까요?

특정 장치에 신경망 아키텍처를 적용하려는 경우 EfficientNet의 오픈 소스 구현 중 하나를 살펴보세요. 이는 r, d 및 w 사이에서 좋은 균형을 선택하는 데 도움이 됩니다.

MobileNet을 사용하면 효율적인 산출 레이어를 구축하는 방법을 배울 수 있으며 EfficientNet을 사용하면 작업 중인 장치의 리소스를 기반으로 이러한 신경망을 확장하거나 축소할 수 있습니다.

이것으로, 저는 여러분이 모바일 기기, 임베디드 기기, 그리고 메모리의 산출이 더 제한적일 수 있는 다른 기기들을 위한 신경망을 구축하는 데 필요한 기술을 갖췄으면 합니다. 이를 통해 현재 구축할 수 있는 많은 응용 프로그램이 열렸으면 합니다.
