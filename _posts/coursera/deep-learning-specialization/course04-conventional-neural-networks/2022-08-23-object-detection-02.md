---
title: "[Ⅳ. Convolutional Neural Networks] Object Detection (2)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Deep Learning
  - Facial Recognition System
  - Convolutional Neural Network
  - Tensorflow
  - Object Detection and Segmentation
toc: true
toc_sticky: true
toc_label: "Object Detection (2)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/183551502-3482e2d7-efb0-4815-9c94-b662606b4842.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Object Detection

## Detection Algorithms

### Object Localization

지난번에 컨볼네트를 사용해서 슬라이딩 윈도우 객체 감지 알고리즘에 대해 배웠죠. 하지만 이게 매우 느리다는 것을 보았었죠.

이번에는 그 알고리즘을 컨볼루셔널하게 어떻게 실행할 수 있는지 배워보겠습니다. 이게 뭘 의미하는지 보시죠.

#### Turning FC layer into convolutional layers

![image](https://user-images.githubusercontent.com/55765292/186089099-26f94160-2cec-4b00-9be9-bbe1cbf1fc92.png)

슬라이딩 윈도우의 컨볼루션 구현을 쌓기 위해서 먼저 신경망에서 완전히 연결된 레이어를 컨볼루션 레이어로 변환시킬 수 있을지 알아보겠습니다. 이번 그림에서 먼저하고 다음 그림에서도 할테지만 컨볼루션 실행을 여러분께 보여드리기 위해 이번 그림에 있는 것들부터 사용해보겠습니다.

객체 감지 알고리즘이 $14 \times 14 \times 3$ 이미지를 입력한다고 가정합시다. 이건 꽤 작지만 설명적인 목적을 위한 것이며 $5 \times 5$ 필터들를 사용한다고 칩시다.

그리고 $14 \times 14 \times 3$에서 $10 \times 10 \times 16$ 까지 이것을 매핑하기 위해서 그것들 중 16개의 필터만을 사용한다고 합시다.

그러면 $2 \times 2$ 맥스 풀링을 하면, $5 \times 5 \times 16$으로 줄입니다. 그리고 나서 400 유닛들을 연결하기 위한 완전히 연결된 레이어가 있죠.

그러면 이것들이 완전히 연결된 레이어이고, 최종적으로 softmax 유닛을 사용해서 y를 출력합니다. 우리가 잠시 후에 필요하게 될 수정사항을 만들기 위해 이 사진을 조금 바꾸겠습니다. 그리고 이 대신에 softmax유닛이 분류되는 네 개 클래스의 급간 확률에 상응하는 네 개의 숫자를 가지고 y를 볼 것입니다. FC는 보행자, 자동차, 오토바이, 그리고 배경 혹은 다른 것들이 되겠죠.

이제 여러분에게 보여드리고 싶은 것은 어떻게 이 레이어들이 컨볼루션 레이어로 전환될지 입니다. 컨볼네트는 예전처럼 처음 몇 단계의 레이어들을 그릴 것이고 그리고 이제, 이 다음 레이어를 실행하는 한 가지 방법은 이 완전 연결 레이어가 이것을 실행하는 것입니다. $5 \times 5$필터가지고 말이죠. 400개의 $5 \times 5$ 필터를 사용해 봅시다.

만약 $5 \times 5 \times 16$ 이미지를 $5 \times 5$ 필터로 컨볼브 시키면 $5 \times 5$ 필터는 $5 \times 5 \times 16$으로 실행되어 집니다. 왜냐하면 우리 컨벤션이 필터가 16개 채널 모두를 가로지르는 것처럼 보이기 때문이죠.

그래서 이 16과 이 16은 서로 매치가 되어야만 하고, 출력은 $1 \times 1$이 되는 것이죠. 만약 $5 \times 5 \times 16$ 필터가 여러분에게 400개가 있다면 출력 차원은 $1 \times 1 \times 400$ 이 될 것입니다.

이 400개를 노드 세트로 보기보다는 $1 \times 1 \times 400$볼륨으로 이걸 간주할 것입니다. 수학적으로 이것은 완전히 연결된 레이어와 동일합니다. 왜냐하면 이 400 개의 노드 각각은 $5 \times 5 \times 16$의 필터를 가지고 있기 때문입니다.

따라서 각각의 400 값은 이전 레이어의 $5 \times 5 \times 16$ 액티베이션에 대한 임의의 선형 함수입니다. 

다음으로 다음 컨볼루션 레이어를 구현하기 위해 $1 \times 1$ 컨볼루션을 구현할 것입니다 400 개의 $1 \times 1$ 필터가 있는 경우 400 개의 필터를 사용하면 다음 레이어가 $1 \times 1 \times 400$이됩니다 그래서 이것은 이 다음에 있는 완전히 연결된 레이어를 만들어줍니다.

마지막으로, 또 다른 $1 \times 1$ 필터가 있고 그 뒤에 softmax 활성화가 따릅니다. 네트워크가 연산하는 이 네 개의 숫자를 가지기 위해서는 $1 \times 1 \times 4$ 볼륨을 만들어주세요. 이것은 이러한 완전히 연결된 레이어를 취해 컨볼루션 레이어를 사용하여 구현하는 방법을 보여줍니다.

그 결과 이러한 유닛 세트가 $1 \times 1 \times 400$ 그리고, $1 \times 1 \times 4$ 볼륨으로 구현되지는 않습니다. 이러한 변환 후에, 슬라이딩 윈도우 객체 감지의 컨볼루션 구현을 할 수 있는지 살펴봅시다.

#### Convolution implementation of sliding windows

![image](https://user-images.githubusercontent.com/55765292/186089372-238242a7-5986-497b-b6c5-da7caf5c6ac3.png)

이 슬라이드에 있는 것은 OverFeat 논문을 근거로 한 것인데요. Pierre Sermanet, David Eigen와 Xiang Zhang, Michael Mathieu, Robert Fergus 및 Yann Lecun 에 의해 작성된 것입니다.

슬라이딩 윈도우가 $14 \times 14$ 이미지를 3 개의 이미지로 변환한다고 가정 해 보겠습니다. 이 그림에서 $14 \times 14$ 이미지와 같은 작은 숫자를 사용해서 숫자와 그림을 더 간단하게 만듭니다.

따라서 이전과 같이 다음과 같은 신경망이 이는 마침내 $1 \times 1 \times 4$ 볼륨을 출력합니다. softmax 출력이죠. 

다시 말하지만, 그림을 단순화하자면, $14 \times 14 \times 3$은 엄밀히 말하면 $5 \times 5$ 혹은 $10 \times 10 \times 16$ 볼륨입니다. 두번째 명백한 볼륨이죠.

그림을 단순화시키기 위해서 저는 이 볼륨의 앞면만 그리겠습니다. $1 \times 1 \times 400$ 볼륨을 그리는 대신에 이것들의 $1 \times 1$ 부분만 그릴 것입니다. 이 그림의 3가지 요소를 삭제했습니다. 이 그림에서만요.

따라서 컨볼네트가 $14 \times 14$ 이미지, 즉, $14 \times 14 \times 3$ 이미지로 14 개를 입력하고 테스트 된 이미지의 크기가 $16 \times 16 \times 3$ 이라고 생각해봅시다. 이제 이 이미지의 경계 면에 노란색 줄무늬를 추가했습니다.

원래의 슬라이딩 윈도우 알고리즘에서는 여러분은 파란색 영역을 컨볼네트로 입력해서 한 번 실행하여 연속 01을 생성한 후 약간 내려가고, 약간 아래로 조금씩, 적어도 2 픽셀의 슬라이드하고, 그것을 다시 2픽셀씩 오른쪽으로 밀면 됩니다.

그럼 이 초록색 직사각형을 컨볼네트로 인풋해서 컨볼네트 전체를 실행하면 또 다른 레이블 01을 얻게 되는 것입니다. 그런 다음이 주황색 영역을 컨볼네트에 입력하고 한 번 더 실행하여 다른 레이블을 얻을 수 있습니다. 그리고이 오른쪽 아래의 자주색 사각형으로 네 번째이자 마지막 실행을 하십시오.

이 $16 \times 3 \times 3$ 이미지에서 슬라이딩 창을 실행하는 것은 매우 작은 이미지입니다. 4 개의 레이블을 얻으려면 이 컨볼네트를 네 번 실행하십시오. 그러나 이 4 가지 컨볼네트에 의해 수행 된 많은 계산은 매우 중복적인 것임이 분명합니다.

따라서 슬라이딩 윈도우의 컨볼루션 실행은 컨볼네트에서 이러한 네 클래스들이 많은 계산을 공유 할 수 있게 합니다. 구체적으로, 다음과 같이 할 수 있습니다.

컨볼네트를 사용하여 동일한 파라미터 동일한 $5 \times 5$ 필터, 또한 16개의 $5 \times 5$ 필터로 이것을 실행하십시오. 이제 $12 \times 12 \times 16$ 아웃풋 볼륨을 가질 수 있습니다.

그런 다음 이전과 마찬가지로 맥스풀링을 수행하십시오. 이제 $6 \times 6 \times 16$ 가 있고 동일한 400 개의 $5 \times 5$ 필터로 실행해서 $2 \times 2 \times 400$ 볼륨을 얻습니다.

이제 $1 \times 1 \times 400$ 볼륨 대신 $2 \times 2 \times 400$ 볼륨이 됩니다. $1 \times 1$ 필터를 통해 실행하면 또 다른 $1 \times 1 \times 400$이 아니라 $2 \times 2 \times 400$ 을 얻게 됩니다.

한 번 더 해보면 이제는 $1 \times 1 \times 4$ 대신$ 2 \times 2 \times 4$ 출력 볼륨을 가지게 됩니다. 이 파란색 $1 \times 1 \times 4$ 부분 집합은 왼쪽 상단 구석 $14 \times 14$ 이미지로 실행 한 결과를 제공합니다.

이 오른쪽 상단의 $1 \times 1 \times 4$ 볼륨은 오른쪽 상단 결과를 제공합니다. 왼쪽 하단은 $14 \times 14$ 영역 왼쪽 아래에 컨볼네트를 구현한 결과입니다. 그리고 오른쪽 하단의 $1 \times 1 \times 4$ 볼륨은 $14 \times 14$ 차원으로 컨볼네트를 실행하는 것과 같은 결과를 제공합니다.

계산의 모든 단계를 거치면 녹색 예제를 보도록 하겠습니다. 이 영역을 잘라내어 컨볼네트를 통과 시키면 이 위쪽에 컨볼네트죠. 그러면 이 첫 레이어의 활성화가 정확하게 이 영역이 됩니다.

맥스 풀링 후 다음 레이어의 활성화는 정확하게 이 영역이었고, 그리고 나서 다음 레이어 그 다음 레이어는 다음과 같이 되었습니다. 이 과정이 하는 일은, 이 컨볼레이션 구현이 하는 일은, 여러분이 독립적으로 입력 이미지의 네 부분 집합상에 있는 네 개의 전파를 실행하도록 강요하기 보다는 네 개 모두를 하나의 계산형식으로 결합하고 공통 이미지 영역에 있는 많은 계산을 공유하는 것입니다.

우리가 여기에서 보았던 $14 \times 14$의 패치 중의 네 개 전부 그렇습니다. 이제 더 큰 예제를 살펴 보겠습니다.

$28 \times 28 \times 3$ 이미지에 대해 슬라이딩 윈도우를 실행한다고 가정해봅시다. 같은 방식으로 네 개를 다 실행하면 $8 \times 8 \times 4$ 출력을 가지게 됩니다.

그리고 작아져서 $14 \times 14$ 영역의 것으로 슬라이딩 윈도우가 남게 됩니다 그것은 그 영역에 대해 처음으로 슬라이딩 윈도우를 실행하는 것에 상응하는 것이죠.

따라서 왼쪽 상단 모서리 부분에 상응하는 출력을 제공하고 윈도우 하나를 옆으로 밀고 또 하나 옆으로, 또 하나 옆으로, 이런식으로 여덟 개의 위치에 대해 수행합니다.

그러면 이 첫 번째 행처럼 되고 이미지 아래쪽으로 갈 수록 이 모두 $8 \times 8 \times 4$ 출력이 됩니다. 이는 2의 맥스 풀링 때문인데요. 이는 원본 이미지에 대해 스트라이드 2로 신경망을 실행하는 것과 일치합니다.

---

![image](https://user-images.githubusercontent.com/55765292/186089410-2e0985ab-8ae6-4e18-9034-b7cf8fa689f5.png)

요약하자면, 슬라이딩 윈도우를 실행하기 위해서는 사전에 그 영역을 잘라내는 것입니다. $14 \times 14$ 라고 하면 컨볼네트를 이용해 실행하고 다음 영역에 대해서도 수행합니다. 그리고 나서 다음 $14 \times 14$ 영역에 대해서 수행을 합니다.

그리고 그 옆, 또 그 옆, 그 옆, 또 그 옆, 그런 식으로 자동차를 인식할 때 까지 진행합니다. 하지만 이제, 끊임없이 이렇기 하는 대신에 이전 그림에서 본 대로 이 컨볼루션 구현을 하면 이 전체 이미지를 실행할 수 있습니다.

모두 아마 $28 \times 28$ 이고 그리고 동시에 이 큰 컨볼네트를 한 칸씩 지나가면서 컨볼루션적으로 예측하게 하면 됩니다. 그리고 마침내 이것이 자동차의 위치를 인식하도록 하는 것이죠.

컨볼루셔널하게 슬라이딩 윈도우를 실행하는 방법과 그것이 훨씬 효과적으로 모든 것을 만들어 내는 것을 보았습니다. 이 알고리즘에는 여전히 한가지 약점이 있는데요. 경계 상자의 위치가 그리 정확하지 않다는 것입니다. 다음은 그 문제점을 해결하는 법을 알아보도록 하겠습니다.
