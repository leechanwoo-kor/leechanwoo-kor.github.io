---
title: "[Ⅳ. Convolutional Neural Networks] Convolutional Neural Networks (6)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Deep Learning
  - Facial Recognition System
  - Convolutional Neural Network
  - Tensorflow
  - Object Detection and Segmentation
toc: true
toc_sticky: true
toc_label: "Convolutional Neural Networks (6)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/183551502-3482e2d7-efb0-4815-9c94-b662606b4842.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Convolutional Neural Networks

## Foundations of Convolutional Neural Networks

### CNN Example

합성곱 신경망을 구성하는 대부분의 구성 요소를 살펴보았습니다. 예시를 한 번 살펴보겠습니다.

---

![image](https://user-images.githubusercontent.com/55765292/184089542-f22a5d47-6317-4514-b4bd-96663cca6e25.png)

$32 \times 32 \times 3$의 RGB 이미지를 입력하는데 손으로 쓴 숫자를 인식하려고 한다고 가정해 보겠습니다. 7 이라는 숫자가 $32 \times 32$의 RGB 이미지에 있고 0부터 9까지의 10 자리 숫자 중 어느 것이 이것인지 인식해 보겠습니다.

이것을 실행하는 신경망을 한 번 구축해 보겠습니다 LeNet-5 이라는 고전적인 신경망과 유사한 방법을 사용할 것입니다. 이 LeNet-5는 Yann LeCun이 수년 전에 개발한 것인데 지금 사용하는 것이 정확히 LeNet-5 는 아니지만 여러 변수들의 선택이 여기서 영감을 얻었습니다.

$32 \times 32 \times 3$의 입력을 첫 번째 레이어라고 부르고 $5 \times 5$ 필터와 스트라이드 1을 사용하고 패딩은 사용하지 않겠습니다.

6개의 필터를 사용한다면 출력은 $28 \times 28 \times 6$ 이 되고 이 레이어를 CONV1 이라고 부르겠습니다. 6개의 필터와 편향을 추가하고 ReLU 같은 비선형성을 적용하면 CONV1 의 출력이 됩니다.

다음으로는 풀링 레이어에 적용해 보겠습니다. 여기에서는 최대 풀링을 사용할 것인데 $f = 2, s = 2$라고 하겠습니다. 패딩을 적지 않을 때는 패딩이 0 이라는 의미입니다.

다음으로는 풀링 레이어를 적용해 보겠습니다. 필터가 $2 \times 2$이고 스트라이드가 2인 최대 풀링을 사용하겠습니다. 높이와 너비의 값을 절반으로 줄어듭니다.

그래서 $28 \times 28$이 $14 \times 14$로 변하게 되고 채널의 수는 유지되기 때문에 $14 \times 14 \times 6$이 됩니다. 이것을 POOL1 출력이라고 부르겠습니다.

합성곱의 문헌에는 레이어라고 부르는 것에 대해 약간 모순되는 두 가지 규칙이 있는 것으로 나타났습니다. 그 중 하나는 이것을 하나의 레이어고 하는 것인데 그래서 이것이 신경망의 레이어 1 이 되는 것이고 다른 하나는 합성곱 레이어와 풀링 레어어를 각각의 레이어로 여기는 것입니다.

일반적으로 신경망의 레이어의 개수를 말할 때 가중치와 변수를 가지는 레이어만 언급합니다. 풀링 레이어는 가중치와 변수가 없고 하이퍼파라미터만 있기 때문에 여기서는 CONV1 과 POOL1 을 하나의 레이어인 레이어 1이라고 부르겠습니다.

온라인 상의 문헌이나 논문에서는 사람들이 CONV1 레이어와 POOL1 레이어를 별개의 레이어로 다루기도 하지만 여기서는 이 두가지를 레이어 1이라고 하겠습니다.

이것이 서로 일치하지 않는 두 개의 관습이지만 레이어의 개수를 셀 때에는 가중치가 있는 레이어만 계산해서 레어어 1로 생각하겠습니다.

CONV1 과 POOL1 이라는 명칭에서 끝에 1 이라는 숫자는 두 레이어가 신경망의 레이어 1 에 속해 있다는 것을 의미합니다. POOL1 은 가중치가 없기 때문에 레이어 1 에 함께 묶이는 것입니다.

다음으로 $14 \times 14 \times 6$ 크기에서 다른 합성곱 레이어를 적용하고 $5 \times 5$ 크기의 필터를 사용하고 스트라이드 1을 사용하고 10개의 필터를 사용하겠습니다.

그러면 $10 \times 10 \times 10$ 크기가 만들어지고 이것을 CONV2라고 부르겠습니다.

이 망에서는 $f = 2, s = 2$인 최대 풀링을 적용하겠습니다. 출력을 예상해 보면 $f = 2, s = 2$이기 때문에 높이와 너비가 절반으로 축소되고 $5 \times 5 \times 10$가 남게됩니다. 이것을 POOL2라고 부르고 우리의 방식대로라면 이것은 합성곱의 레이어 2가 됩니다.

여기에 또 다른 합성곱 레이어를 적용해 보겠습니다. $5 \times 5$ 필터를 사용하기 때문에 $f = 5$이고 스트라이드는 1이고 패딩은 없습니다. 이것이 CONV2 출력을 생성하고 필터는 16개입니다.

따라서 이것은 $10 \times 10 \times 16$ 크기의 출력이 됩니다. 이것이 CONV2 레이어입니다.

여기에 $f = 2, s = 2$의 최대 풀링을 적용하겠습니다. 이것의 출력을 추측해 볼 수 있을 텐데요. $f = 2, s = 2$인 $10 \times 10 \times 16$의 최대 풀링이니까 높이와 너비를 절반으로 축소시킬 것입니다. 결과를 추측할 수 있겠죠? 

$f= 2, s = 2$의 최대 풀링이니까 높이와 너비를 반으로 축소시켜서 $5 \times 5 \times 16$으로 예전과 동일한 채널 수를 갖게 됩니다. 이것을 POOL2 라고 부르겠습니다.

우리 방식으로 이것이 레이어2가 되는데 가중치와 CONV2 레이어가 있기 때문입니다. $5 \times 5 \times 16$은 400이고 이 POOL2를 $400 \times 1$ 크기의 벡터로 확대시켜 보겠습니다. 여러 개의 뉴런같이 확대시킨다고 생각하면 됩니다.

이 400 개의 유닛을 가지고 120 개의 유닛을 가진 레이어를 만들어 보겠습니다. 이것이 바로 첫 번째 완전히 연결된 레이어가 되는데 FC3라고 부르겠습니다. 400 개의 유닛이 120 개의 유닛과 빽빽하기 연결되어 있기 때문입니다.

이 완전히 연결된 유닛인 레이어는 마치 과정 1, 2에서 보았던 단일 신경망 레이어와 유사합니다. 이것은 (120, 400)크기의 $W^{[3]}$으로 불리는 가중치 행렬을 가지는 표준 신경망입니다.

완전 연결이라고 하는 이유는 400 개의 유닛이 각각 120개의 유닛과 연결되어 있고 편향 매개 변수도 있는데 120개의 출력이 있기 때문입니다.

마지막으로 120 개의 유닛에 84개의 유닛인 조금 더 작은 레이어를 더해보겠습니다. 이것을 완전히 연결된 레이어 4라고 부르겠습니다. 그러면 소프트맥스 유닛에 적용 가능한 84 개의 실수를 갖게됩니다.

손 글씨를 인식을 하려 한다면 0, 1, 2, ..., 9를 인식해야 합니다. 그러면 이것은 10 개의 출력이 있는 소프트맥스가 됩니다. 

이것이 합성곱 신경망의 일반적인 예입니다. 많은 하이퍼파라미터가 있는 것처럼 보이는데 나중에 이 하이퍼파라미터를 선정하는 구체적인 방법을 살펴보겠습니다.

하나의 지침은 직접 하이퍼파라미터를 선정하지 말고 문헌에서 다른 사용자들에게 작동했던 하이퍼파라미터를 보고 자신의 응용프로그램에도 잘 작동할 구조를 선택하는 것입니다.

여기에 대해선 다음에 좀 더 다루도록 하겠습니다. 하지만 지금 시점에서는 신경망이 깊어질수록 $n_H$ 와 $n_W$인 높이와 너비가 감소한다는 것을 말씀드리고 싶습니다.

앞에서 보았듯이 $32 \times 32$는 $20 \times 20$으로 $14 \times 14$으로 또 $10 \times 10$으로 $5 \times 5$로 축소됩니다. 보통 더 깊어질수록 높이와 너비가 줄어들지만 반면에 채널 수는 증가합니다. 3에서 6으로 16으로 그리고 마지막에는 완전히 연결된 레이어가 있습니다.

또 다른 신경망의 흔한 패턴은 합성곱 레이어 뒤에 풀링 레이어가 있고 또 몇 개의 합성곱 레이어 뒤에 풀링 레이어가 있고 마지막에는 몇 개의 완전 연결된 레이어와 소프트맥스가 있다는 것입니다. 이것이 신경망에서 볼 수 있는 흔한 패턴 중에 하나입니다.

---

![image](https://user-images.githubusercontent.com/55765292/184089576-40be77fa-6890-4074-98d8-353798c4df8a.png)

활성값 형태와 크기와 신경망의 매개 변수의 개수 등 신경망에 대해 좀 더 자세히 살펴보겠습니다. 입력은 $32 \times 32 \times 3$ 이고 세 수를 곱하면 3,072를 얻게됩니다. 그래서 활성값 $a^{[0]}$ 는 3,072 의 크기를 가집니다. 실제로는 $32 \times 32 \times 3$이죠. 그리고 입력 층이라 변수는 따로 없습니다.

다른 층 들을 보면 한 번 직접 계산해보세요. 이것이 다양한 레이어의 활성값 형태와 크기가 됩니다. 몇 가지 유의할 점은 첫째, 최대 풀링 레이어는 매개 변수가 따로 없고 둘째, 이전 강의에서 언급했듯이 합성곱 레이어가 상대적으로 적은 변수를 갖는다는 것입니다.

그리고 신경망의 대부분의 변수는 완전 연결 레이어에 있는 경향이 있습니다. 그리고 활성값의 크기도 신경망이 깊어질수록 점점 감소합니다. 너무 빠르게 감소한다면 성능 측면에서 좋지 않을 수 있습니다.

그래서 6,000으로 시작해서 1,600 정도로 감소하고 꾸준히 감소해서 84 개로 내려가고 결국 소프트맥스 출력이 되는 것입니다. 많은 합성곱 신경망은 이 같은 속성 혹은 패턴을 가집니다.

---

지금까지 합성곱 신경망의 기본 구성 요소인 CONV 레이어, 풀링 레이어, 그리고 완전히 연결된 레이어를
살펴보았습니다.

많은 컴퓨터 비전 분야의 연구는 이 구성 요소를 어떻게 활용해서 효율적인 신경망을 구축하는 방법을 알아내기 위해 노력하고 있습니다. 이것들을 합치는 것에는 일종의 통찰력이 필요합니다.

여기에 대해서 좋은 직관을 얻는 방법은 다른 사람들이 작업했던 여러 개의 구체적인 예를 살펴보는 것입니다. 그래서 이서 방금 본 예를 넘어서서 사람들이 어떻게 이것들을 잘 조합해서 효율적인 신겸망을 구축했는지 몇 개의 구체적인 예를 보겠습니다.

마무리하기 전에 이어 살펴보겠지만 합성곱을 사용해야 하는 이유, 합성곱을 사용할 때의 장점과 이득, 어떻게 조합해야 방금 본 것과 같은 신경망을 구축하고 방금 본 신경망을 어떻게 훈련시켜야 이미지 인식이나 다른 작업을 수행할 수 있는지 알아보겠습니다


### Why convolutions?

신경망에 컨볼루션을 포함시킬 때 왜 그렇게 유용한지에 대해 잠시 이야기해 보겠습니다.

마지막으로, 이 모든 것을 종합하는 방법과 라벨 훈련 세트가 있을 때 어떻게 컨볼루션 신경망을 학습시킬 수 있을지 간략하게 설명하겠습니다.

---

#### Why convolutions

![image](https://user-images.githubusercontent.com/55765292/184092146-dfaef86e-61ea-4354-9a5c-aed8dad5f5f2.png)

저는 완전히 연결된 층을 사용하는 것보다 컨볼루션 층에는 두 가지 주요 장점이 있다고 생각합니다. 파라미터 공유와 연결의 희소성이 장점입니다. 예시를 통해 설명해 보겠습니다.

$32 \times 32 \times 3$ 차원 이미지가 있다고 가정 해 보죠. 이는 사실 이전 예제에서 가져온 것인데요.

$5 \times 5$ 필터와 6개의 필터를 사용한다고 가정해 보겠습니다. 따라서 $28 \times 28 \times 6$ 차원 출력을 얻을 수 있습니다. $32 \times 32 \times 3$는 3,072가되고, $28 \times 28 \times 6$, 이 숫자를 모두 곱하면 4,704가 됩니다.

한 층에 3,072개의 유닛이 있는 신경망을 만들고 다음 층에 4,704개의 유닛이 있는 신경망을 만든다면 그리고 이 뉴런들을 모두 연결하면 가중 매트릭스는 가중 매트릭스의 파라미터 수는 $3,072 \times 4,704$가 될 것 이며 이는 약 1,400만 개입니다.

이는 그냥 훈련시킬 파라미터가 많이 있다는 것이죠. 그리고 오늘날 1400 만 개 이상의 파라미터를 사용하여 신경망을 학습시킬 수 있지만, 이게 매우 작은 이미지임을 감안할 때, 많은 파라미터를 훈련시킬 수 있습니다.

물론, 이것이 $1,000 \times 1,000$ 이미지라면 디스플레이 매트릭스는 보이지 않을 만큼 커집니다. 그러나 이 컨볼루션 레이어에서 파라미터의 수를 살펴보면 각 필터는 $5 \times 5$ 이므로 각 필터에는 25 파라미터가 있으며 한 개의 바이어스 파라미터를 더해주면 필터당 26 파라미터가 됩니다.

그리고 6개의 필터가 있으므로 총 파라미터의 수는 156 파라미터와 같습니다. 따라서 이 conv 층의 파라미터 수는 매우 작습니다.

---

![image](https://user-images.githubusercontent.com/55765292/184092181-7f5dc966-d7c0-4913-9cd9-6fdc1dd9eda1.png)

conv 네트워크가 이러한 작은 파라미터에 도달한 이유는 두 가지입니다. 하나는 **파라미터 공유**입니다. 그리고 파라미터 공유는 수직 에지 검출기와 같은 특성 감지기를 관찰함으로써 동기 부여되고 이미지의 한 부분에서 유용하다면 이미지의 다른 부분에서도 유용 할 수 있습니다.

그게 의미하는 바는 수직 모서리를 감지하기 위해 $3 \times 3$ 필터를 사용했다면, 여기에 같은 $3 \times 3$ 필터를 적용한 다음, 다음 위치에도 또 다음 위치에도, 계속 사용해 갈 수 있다는 것입니다.

이 각각의 특성 탐지기들 각 출력은 동일한 9개의 파라미터 중 많은 부분에서 다른 위치에서 수직 모서리나 다른 특성을 감지하도록 똑같은 파라미터를 사용할 수 있습니다.

그리고 이것은 모서리와 같은 낮은 수준의 특성뿐만 아니라 얼굴이나 고양이 또는 그 밖의 무언가를 나타내는 눈을 감지하는 높은 수준의 특성에도 해당된다고 생각합니다.

이 경우에 공유되는 것은 동일한 파라미터를 사용하여 16개의 출력을 모두 계산할 수 있습니다. 파라미터 수를 줄이는 방법 중 하나라는 것입니다.

또한 수직 모서리 감지기와 같은 특성 감지기가 이미지의 왼쪽 상단 모서리에 대해 이를 계산하는 것도 직관적으로 보입니다. 이처럼 동일한 특성이 유용 할 것이고 이미지의 오른쪽 하단에도 유용할 것 같습니다.

따라서 이미지의 왼쪽 상단과 오른쪽 하단에 서로 다른 특성 감지기를 배워야 할 필요가 없죠. 왼쪽 상단 모서리와 오른쪽 하단 모서리의 다분포가 서로 다른 데이터 세트가 있을 수 있습니다. 모양은 조금 다르지만 비슷할 수 있고 모든 이미지에서 특성 감지기를 공유하며 잘 작동합니다.

conv 네트워크가 도망가는 파라미터가 상대적으로 적은 것은 연결이 희박하기 때문입니다. 여기서 제가 의미하는 것은 여러분이 0을 본다면 이것은 $3 \times 3$ 컨볼루션을 통해 계산됩니다.

따라서 이 $3 \times 3$ 입력 격자판 또는 셀에만 의존합니다. 즉, 오른쪽에 있는 출력 특성은 이 6개 중 $9 \times 6 \times 36$개 입력 특성에만 연결된 것과 같습니다. 특히 나머지 픽셀 값들 여기 있는 모든 픽셀 값은 이쪽 출력에 영향을 미치지 않습니다. 그게 바로 **연결의 희박함**입니다.

또 다른 예시로, 이 출력은 이 9 개의 입력 특성에만 의존합니다. 따라서 이쪽 9 개의 입력 특성만이 출력에 연결되어 있고, 나머지 픽셀은 이 출력에 전혀 영향을 주지 않습니다.

이 두 가지 메카니즘을 통해 더 작은 훈련 셀로 훈련할 수 있는 훨씬 적은 파라미터를 가지고 있고 30이 넘을 확률이 낮습니다.

때로는 컨볼루션 신경망이 변환 불변성을 매우 잘 포착한다는 이야기도 들으실 수 있습니다. 그리고 그것은 고양이 사진이 오른쪽으로 몇 픽셀 이동했다는 관찰이고 여전히 고양이인 게 분명해요.

그리고 컨볼루션 구조는 신경망이 몇 픽셀 이동된 이미지가 상당히 유사한 특징을 나타내며 동일한 타원형 레이블을 할당해야 한다는 사실을 인코딩하는 데 도움이 됩니다.

그리고 동일한 필터에 적용한다는 사실은 초기 층과 후기 층 모두에서 이미지의 모든 위치를 알고 있기 때문에 신경망이 자동으로 보다 견고해지는 방법을 배우거나 변환 불변성의 바람직한 특성을 더 잘 포착할 수 있습니다.

이런 것들이 컴퓨터 비전에서 컨볼루션이나 컨볼루션 신경망이 잘 작동하는 이유 중 몇 가지일 것입니다.

---

#### Putting it together

![image](https://user-images.githubusercontent.com/55765292/184092230-02ab2be7-5e39-42b5-ad5c-5eb54282ad5f.png)

마지막으로 이러한 네트워크 중 하나를 어떻게 교육할 수 있는지 살펴보겠습니다. 고양이 탐지기를 만들고 싶다고 가정해 보겠는데요.

다음과 같은 라벨이 부착된 교육 세트를 갖는데요. 여기서 $x$는 이미지입니다. 그리고 $y$는 이진수 라벨이거나 $K$ 원인 중 하나 일 수 있습니다.

그리고 여러분이 컨볼루션 신경망 구조를 선택했다고 가정 해 봅시다. 이미지를 삽입한 다음 컨볼루션 및 풀링 레이어를 가진 다음 완전히 연결된 레이어 몇 개에 이어 $\hat{y}$을 작동하는 소프트웨어 출력을 가질 수 있습니다.

이어서는 $\hat{y}$ 작동을 하는 Softmax가 뒤따라옵니다. conv 레이어와 완전히 연결된 레이어는 다양한 파라미터 $W$, 그리고 바이어스의 $b$ 가 있습니다.

따라서 파라미터를 설정하면 이전 코스에서 살펴본 것과 유사한 비용 함수를 정의할 수 있습니다. 여기에서 파라미터 $W$ 및 $b$를 임의로 초기화했습니다.

여러분은 비용 $J$를 계산할 수 있는데요. 전체 훈련 세트에서 신경망의 예측에서 생긴 손실 총액을 $m$ 으로 나누면 되겠죠.

따라서 신경망을 훈련시키기 위해서 해야 할 일은 비용 함수 $J$ 값을 줄이는 노력으로 신경망의 모든 파라미터를 최적화할 수 있도록 기울기 하강 모멘텀이나, RMSProp 혹은 Adam 또는 다른 알고리즘을 사용하는 것입니다.

이렇게 하면 매우 효과적인 고양이 감지기나 또 다른 감지기도 만들 수 있습니다.

---

이제는 컨볼루션 신경망의 모든 기본 구성 요소를 보았고 어떻게 그것들을 효과적인 이미지 인식 시스템으로 결합할 수 있을지 살펴보았습니다.

이번 예제들은 이런 모든 것들이 보다 구체적으로 이루어질 것이라고 생각합니다. 그리고 직접 이러한 것들을 구현하고 스스로 작동하는 것을 볼 수 있는 기회를 얻게 될 것입니다.

다음에도 계속해서 컨볼루션 신경망에 대해 자세히 다룰 것입니다. 앞에서 언급했듯이 컨볼루션 신경망에는 많은 하이퍼 파라미터가 있습니다. 그래서 다음에는 가장 효과적인 컨볼루션 신경망의 몇 가지 사례를 보여드리고, 어떤 유형의 네트워크 아키텍처가 효과적인 패턴인지 알 수 있도록 도와드리겠습니다.

그리고 사람들이 흔히 하는 일 중 하나는 다른 사람이 발견하여 연구 논문에 발표한 아키텍처를 여러분의 애플리케이션에 사용하는 것입니다.

따라서, 다음에는 더 많은 구체적인 예시를 통해 그걸 어떻게 하면 더 잘 할 수 있는지 배웁니다. 그 외에도 무엇이 conv 네트워크가 잘 작동하게 만드는지에 대해서도 알아보도록 하겠습니다.

나머지 부분에서는 물체 감지 및 신경 저장소 전송과 같은 다양한 컴퓨터 비전 애플리케이션도 볼 수 있습니다. 알고리즘 세트를 사용하여 어떻게 새로운 형태의 예술작품을 만드는지 알아보도록 하겠습니다.
