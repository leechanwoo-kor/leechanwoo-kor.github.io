---
title: "[Ⅳ. Convolutional Neural Networks] Deep Convolutional Models (2)"
categories:
  - Deep Learning Specialization
tags:
  - Coursera
  - Deep Learning Specialization
  - Deep Learning
  - Facial Recognition System
  - Convolutional Neural Network
  - Tensorflow
  - Object Detection and Segmentation
toc: true
toc_sticky: true
toc_label: "Deep Convolutional Models (2)"
toc_icon: "sticky-note"
---

![image](https://user-images.githubusercontent.com/55765292/183551502-3482e2d7-efb0-4815-9c94-b662606b4842.png){: width="50%" height="50%"}{: .align-center}

<br><br>

# Deep Convolutional Models

## Case Studies

### Inception Network Motivation

컨볼넷을 위한 레이어를 설계할 때는 $1 \times 1$ 필터, 혹은 $3 \times 3$, 또는 $5 \times 5$, 또는 풀링 레이어 중 어느 것을 선택할 필요가 있습니다. 인셉션망은 이야기하고자 하는 것은 왜 다 해야 하죠? 라는 겁니다.

이로 인해 네트워크 아키텍처가 더욱 복잡해지지만 매우 잘 작동합니다. 어떻게 작동하는지 봅시다.

#### Motivation for inception network

![image](https://user-images.githubusercontent.com/55765292/185004920-b416e74f-8c31-42ee-bdb7-e515fe00fab1.png)

예를 들어 다음과 같이 입력했다고 가정해 보겠습니다. 중간 볼륨으로 줄였습니다. 인셉션망 또는 인셉션 레이어가 말하고자 하는 것은 컨볼 레이어에서 여러분이 원하는 필터사이즈를 고르는 대신에 아니면 컨볼루션 레이어 또는 풀링 레이어를 원하시나요? 전부 다 해봅시다.

$1 \times 1$ 컨볼루션을 사용하면, $28 \times 28 \times$ 무언가를 출력할 수 있습니다. $28 \times 28 \times 64$ 출력 이라고 하면 그리고 거기에 볼륨이 있습니다.

어쩌면 여러분은 $3 \times 3$을 시도해보고 싶을 것이고 $28 \times 28 \times 128$ 출력 될 겁니다. 그리고 이 두 번째 볼륨을 첫 번째 볼륨 옆에 쌓습니다. 그리고 차원을 일치 시키려면 이것을 같은 컨볼루션으로 만들어 봅시다.

그래서 출력 차원은 높이와 너비 측면에서 출력 차원처럼 여전히 $28 \times 28$입니다. 그러나 이 예에서는 $28 \times 28 \times 128$ 입니다. 그리고 아마 양쪽에 다 걸으라고 말할지도 모릅니다. 아마 $5 \times 5$필터가 더 효과적일 수 있으니까요. 그러니 그것도 해봅시다. 그리고 이건 출력 $28 \times 28 \times 32$가 됩니다. 그리고 같은 컨볼루션을 사용하여 차원을 동일하게 유지합니다.

그리고 아마도 여러분은 컨볼루션 레이어를 원치 않으실 테니 풀링을 적용 해 보고 그러면 어떤 다른 출력이 될 테고 그럼 그걸 쌓아봅시다. 여기에 풀링 출력이 $28 \times 28 \times 32$입니다.

이 모든 차원이 잘 맞도록 실제로 최대 풀링을 위해 패딩을 사용해야 합니다. 따라서 이것은 흔하지 않은 일반적 풀링입니다. 입력 값이 $28 \times 28$보다 크고 출력이 있으면 다른 차원과 $28 \times 28$ 만큼 일치하기 때문입니다. 풀링에는 같은 패딩과 하나의 스트라이드를 사용해야 합니다.

이제 이 세부 사항이 좀 웃기게 느껴질 수 있지만 계속 진행하겠습니다. 이 모든 것이 나중에 잘 작동 할 수 있도록 만들 것 입니다. 그러나 이런 인셉션 모듈에서는 볼륨과 출력을 입력할 수 있습니다.

이 경우에 이 모든 숫자들을 더하면 32 + 32 + 128 + 64는 256 이 됩니다. 따라서 1개의 인셉션 모듈 입력 $28 \times 28 \times 192$ 및 출력 $28 \times 28 \times 256$이 됩니다. 이것은 인셉션망의 핵심입니다.

기본적인 생각은 이러한 필터 크기 또는 풀링 중 하나를 선택하여 커밋하는 것이 아니라 모든 작업을 수행하고 모든 출력을 연결할 수 있다는 것입니다. 네트워크가 사용하는 파라미터의 조합이나 필터 사이즈의 조합에 관계없이 학습할 수 있습니다.

여기서 설명한 바와 같이 인셉션 레이어에 문제가 있다는 것이 밝혀졌습니다 바로 계산 비용입니다. 이어서 여기 블럭을 만드는 이 $5 \times 5$ 필터의 계산 비용이 얼마나 되는지 알아 보겠습니다 

#### The problem of computational cost

![image](https://user-images.githubusercontent.com/55765292/185004964-e56bcd7a-d54c-4c94-a0db-398e211b479c.png)

이전 그림의 $5 \times 5$ 포트에 초점을 맞추기 위해 $28 \times 28 \times 192$ 블록을 입력하고 32 개 필터를 가진 $5 \times 5$ 동일한 컨볼루션을 $28 \times 28 \times 32$ 출력합니다. 이전 그림에서는 얇은 보라색으로 그렸었습니다.

이 $20 \times 20 \times 32$로 출력하는데 드는 계산 비용을 살펴 보겠습니다. 출력에는 32 개의 채널이 있고 각 필터는 $5 \times 5 \times 192$ 가 될 것이기 때문에 32개의 필터가 있습니다.

따라서 출력 크기가 $20 \times 20 \times 32$가 되고 $28 \times 28 \times 32$의 숫자를 계산해야 합니다. 그리고 각각에 대해 이렇게 많은 곱셈을 해야 합니다. $5 \times 5 \times 192$입니다.

필요한 총 곱셈 수는 각 출력 값을 계산하는 데 필요한 곱셈 수에 계산해야 하는 출력 값 수를 곱한 것입니다. 그리고 이 숫자들을 모두 곱하면 이것은 1억 2천만입니다. 현대 컴퓨터에서 1억 2천만 배의 곱셈을 할 수는 있지만 여전히 비싼 작업입니다.

다음 그림에서는 $1 \times 1$ 컨볼루션을 사용하는 방법을 보여 줍니다. 지난 번에 배운 내용인데요. 계산 비용을 약 10배 절감할 수 있습니다. 약 1억 2천만배에서 약 10분의 1로 증가했습니다. 숫자 120을 기억해 두면 다음 슬라이드에 나와 있는 1억 2천만과 비교할 수 있습니다. 여기에 $28 \times 28 \times 192$를 입력하고 $28 \times 28 \times 32$의 출력을 하기 위한 대체 아키텍쳐가 있습니다.

#### Using $1 \times 1$ convolution

![image](https://user-images.githubusercontent.com/55765292/185005001-e34719c4-bf5d-42c3-a908-9ebe1810945c.png)

192 채널 대신 16 채널로 볼륨을 줄이기 위해서 볼륨을 사용하고 $1 \times 1$ 컨볼루션을 사용하여 볼륨을 192채널이 아닌 16채널로 줄이고 최종 출력을 제공하기 위해 $5 \times 5$ 컨볼루션 실행시킬 것입니다.

따라서 입력 차원과 출력 차원은 여전히 동일합니다. 이전 그림처럼 입력을 $28 \times 28 \times 192$를 입력하고 $28 \times 28 \times 32$로 출력 하세요.

왼쪽에 있는 큰 볼륨을 $28 \times 28 \times 192$차원 볼륨의 이는 192채널 대신에 16개 채널만 가지고 있습니다. 때때로 이것을 병목현상 레이어라고 부릅니다. 병목현상 레이어는 이 네트워크의 가장 작은 부분입니다. 이제 계산 된 비용을 살펴 보겠습니다.

$1 \times 1$ 컨볼루션을 적용하기 위해 16 개의 필터가 있습니다. 각 필터는 $1 \times 1 \times 192$의 차원이 될 것이고 이 192는 그 192와 일치 할 것입니다.

따라서 이 $28 \times 28 \times 16$ 볼륨을 계산하는 데 드는 비용은 충분할 것입니다. 여러분은 이 많은 출력이 필요하며 이들 각각을 위해 192번의 곱셈을 해야만 합니다. $1 \times 1 \times 192$ 이렇게 쓸 수 있었겠죠?

다시 말해, 이걸 곱하면, 이것은 240만입니다. 대략 240만 입니다. 두 번째 것은 어떻죠? 이것이 첫 번째 컨볼루션 레이어의 비용입니다. 이 두 번째 컨볼루션 레이어의 비용은 그게 됩니다. 이렇게 많은 출력이 있습니다. 그래서 $28 \times 32 \times 32$ 입니다.

그리고 나서 각 출력에 대해 $5 \times 5 \times 16$ 차원 필터를 적용해야 합니다. 따라서 $5 \times 5 \times 16$ 가 되는 것이죠. 그리고 이 둘을 곱하면 10.0M과 같게 됩니다.

따라서 필요한 곱셈의 총합은 1240만 배수의 곱셈의 합계입니다. 그리고 이것을 이전 그림과 비교해보시면 계산 비용을 약 1억 2천만에서 약 10분의 1 배까지 줄여서 1240만 곱셈으로 줄이는 겁니다. 필요한 덧셈 횟수는 수행해야 하는 곱셈의 수와 매우 유사합니다. 그래서 곱셈을 하고 있는 거예요.

---

요약하면, 신경망 레이어를 구축하고 있고, $1 \times 1$ 을 원하는지, $3 \times 3$, $5 \times 5$ 혹은 풀링 레이어 아님 인셉션 모듈을 원하는지 결정할 필요가 없다면 전부 계산하고 결과를 연결시켜 봅시다.

그리고 계산 비용 문제로 이어집니다. 어떻게 $1 \times 1$ 컨볼루션을 이용하는지 알아보았는데요. 이 병목현상 레이어를 생성해서 계산 비용을 크게 줄일 수 있었습니다.

이제 여러분은 아마도 표현의 크기를 너무 과하게 줄인 건지 신경망의 성능을 해치고 있는지 궁금해하고 계실 것입니다. 병목현상 레이어를 구현하면 표현의 크기를 상당히 줄일 수 있고 성능을 해치는 것처럼 보이지는 않지만 많은 계산량을 절약 할 수 있습니다.

따라서 이것이 인셉션 모듈의 핵심 아이디어입니다. 이것들을 조합해 완전한 인셉션 네트워크의 구조를 나타냅니다.


### Inception Network

이미 인셉션 네트워크의 기본 구성 요소를 모두 확인하셨습니다. 이번에는 이러한 구성 요소를을 조합하여 고유한 인셉션망을 구축하는 방법을 알아보겠습니다.

#### Inception module

![image](https://user-images.githubusercontent.com/55765292/185008812-3af6200e-72e0-4b2d-a169-94ce12bc074d.png)

인셉션 모듈은 활성화 또는 이전 레이어로부터의 출력을 입력으로 받아들입니다. 논의를 위해 우리의 이전에 본 $28 \times 28 \times 192$를 사용합시다.

깊이 있게 작업했던 이 예제는 $1 \times 1$ 다음에 $5 \times 5$ 레이어로 이어져 있습니다. $1 \times 1$에는 16개의 채널이 있고 그러면, $5 \times 5$는 $28 \times 28$의 32개 채널을 출력 할 것입니다.

그런 다음 $3 \times 3$ 컨볼루션에 계산을 저장하려면 여기서도 같은 작업을 수행 할 수 있습니다. 그리고 나서 $3 \times 3$은 $28 \times 28 \times 128$ 을 출력합니다.

그리고 $1 \times 1$의 컨볼루션도 고려해 보는 것이 좋을지도 모릅니다. $1 \times 1$ 컨볼루션 뒤에 나오는 또 다른 $1 \times 1$ 컨볼루션은 작업할 필요가 없습니다. 따라서, 하나의 작업 단계만 있습니다. 이 출력을 $28 \times 28 \times 64$ 이라고 합시다.

그리고 마지막으로 풀링 레이어입니다. 이제 여기서 우리는 재미있는 것을 해 볼 텐데요. 이러한 모든 출력을 실제로 연결하기 위해 풀링에 동일한 유형의 패딩을 사용합니다. 출력 높이와 너비는 여전히 $28 \times 28$입니다.

다른 출력과 연결할 수 있습니다. 단, 같은 패딩이라도 max 풀링을 실행하면 $3 \times 3$ 필터가 1로 시행됩니다. 여기 출력은 $28 \times 28 \times 192$ 입니다.

채널 수와 깊이가 여기서 입력한 내용과 동일합니다. 그래서 이것은 많은 채널을 가지고 있는 것처럼 보입니다. 이제 채널 수를 늘리기 위해 $1 \times 1$ 컨볼 레이어를 하나 추가하는 것입니다.

그러면 이 $28 \times 28 \times 32$로 줄일 수 있죠. 그렇게 할 수 있는 방법은 $1 \times 1 \times 192$ 차원의 32개의 필터를 사용하는 것입니다. 그렇기 때문에 출력 차원에는 2개의 채널이 축소되어 있습니다. 그러면 우리는 풀링 레이어로 끝나지 않습니다.

최종 출력의 모든 채널을 차지합니다 마지막으로 이 모든 블록을 채널에 일치시킵니다. 이 64 + 128 + 32 + 32를 연결하면됩니다. 그리고 이걸 다 더하면 $28 \times 28 \times 256$차원 출력이 됩니다. 채널 연결이란 이전 강의에서 보았던 블록들을 연결하는 것입니다. 이것은 하나의 인셉션 모듈입니다. 그리고 인셉션망의 역할은 많은 모듈을 조합하는 것입니다.

#### Inception network

![image](https://user-images.githubusercontent.com/55765292/185008841-e707516d-f459-4880-95ac-62c8535986b1.png)

다음은 Szegety et al.의 논문에서 가져온 인셉션 망입니다. 그리고 이 안에 많은 블록이 반복되는 것을 볼 수 있습니다. 아마 이 그림은 정말 복잡하게 보일 거예요.

그 블록 중 하나를 보시면 기본적으로 이전그림에서 보았던 인셉션 모듈입니다. 자세한 내용은 언급하지 않겠습니다만 이것은 또 다른 시작 블록입니다. 이것은 다른 인셉션 블록입니다.

여기에는 높이와 너비의 차원를 변경하기 위한 추가 max 풀링 레이어가 있습니다. 하지만 또 다른 인셉션 블록이 있습니다. 그리고 높이와 너비를 바꿀 수 있는 또 다른 max 풀링이 있습니다.

하지만 기본적으로 또 다른 인셉션 블록이 있죠. 그 인셉션망은 네트워크의 여러 위치에 대해 반복적으로 학습 한 많은 블록들입니다. 이전 그림의 인셉션 블록을 이해하셨다면 인셉션망도 이해할 수 있습니다.

원래의 연구 논문을 읽어보면 인셉션망에 대한 마지막 세부사항이 나옵니다. 이게 바로 제가 여기에
덧붙여놓은 추가적인 곁가지들입니다.

자, 그래서 이것은 무엇을 할까요? 네트워크의 마지막 몇 개의 레이어는 완전히 연결된 레이어이며 그 후에 예측을 시도하기 위해 softmax 레이어가 이어집니다. 이 곁가지들이 하는 일은 숨겨진 레이어를 사용하여 예측을 하는 것입니다. 그래서 이것은 실제로 softmax 출력이며 이것 역시 그렇습니다.

그리고 이 다른 쪽 곁가지는 이것은 은닉 레이어가 연결된 레이어처럼 몇 개의 레이어를 통과합니다. 다음으로 softmax가 출력 라벨을 예측하도록 합니다. 그리고 당신은 이것을 단지 효과가 있었던 시작의 또 다른 세부 사항이라고 생각해야 합니다. 다만, 특성이 계산되고 있는 것을 확인하는 것이 도움이 됩니다.

표제 단위에서도 중간 레이어에서도 마찬가지입니다. 이미지의 출력 원인을 보호하기에 나쁘지 않습니다. 그리고 이것은 인셉션망에 정규화 효과가 있어 이 네트워크가 과적합하는 것을 방지하는 데 도움이 되는 것으로 보입니다.

---

![image](https://user-images.githubusercontent.com/55765292/185008850-ce7ae11d-5399-4916-8394-fd5b35e0f3b3.png)

더 깊이 연구할 필요가 있기 때문에 이 인셉션 논문은 이 사진을 인용하고 있습니다. 인셉션 이라는 제목의 이 영화를 보셨다면 아마도 이 밈이 이해가 될 것입니다.

그러나 저자들은 실제로 이 밈을 보다 깊은 새로운 네트워크를 구축해야 하는 동기로 꼽고 있습니다. 그렇게 해서 그들은 초기 아키텍처를 고안해 냈습니다. 연구 논문이 인용문에서 인터넷 밈을 인용하는 것은 그리 흔한 일은 아닌데요. 하지만 이번 경우는 꽤 잘 된 것 같아요.

---

요약하면 인셉션 모듈을 이해하면 인셉션 망을 이해하게 됩니다. 인셉션망은 대체로 네트워크 전체에 걸쳐 여러 번 반복되는 인셉션 모듈입니다.

오리지널 인셉션 모듈을 개발 한 이후로 저자와 다른 사람들은 그것을 바탕으로 다른 버전도 개발했습니다. 그래서 새로운 버전의 인셉션 알고리즘에 대한 연구 논문들이 있는데요. 인셉션 V2, 인셉션 V3, 인셉션 V4와 같은 최신 버전의 일부를 사람들이 사용하는 것을 볼 수 있을 것입니다.

인셉션 버젼도 있습니다. 이것은 연결을 건너뛰었다는 공명적인 생각과 결합되어 때로는 더 잘 작동하기도 합니다. 그러나 이러한 모든 변형은 인셉션 모듈과 그들을 함께 쌓는 것에 대해 강의에서 배운 기본 기념에 근거해 구축됩니다.

그리고 이 비디오를 통해 여러분은 초기 논문을 읽고 이해할 수 있을 것입니다. 그리고 어쩌면 나중에 미분 된 내용을 설명하는 일부 논문도 읽을 수 있을 것입니다.

자, 여기까지입니다. 여러분은 많은 특수 신경망 구조들을 다뤘습니다. 다음에는 이러한 알고리즘을 사용하여 자신의 컴퓨터 비전 시스템을 구축하는 방법에 대한 보다 실용적인 조언을 보여드리겠습니다.
