---
title: "[Database System] Tree Index"
categories:
  - Database System
tags:
  - Database System
  - Tree Index
toc: true
toc_sticky: true
toc_label: "Tree Index"
toc_icon: "sticky-note"
---

# Database System

## Equality/Range Search

### Equality Search

- 주어진 검색 키 K로 레코드 찾기; 루트에서 시작하여 적절한 트리 포인터를 찾으십시오.
- 그런 다음 올바른 리프 노드에 도달할 때까지 다음 레벨로 포인터를 반복해서 따라갑니다.
- K가 Kj와 같으면 데이터 포인터 Pj를 따라 값이 K인 레코드를 찾습니다.
- 키가 20인 레코드를 찾으려면 ?
![image](https://user-images.githubusercontent.com/55765292/140866239-b333a33f-7b7a-46f2-9b03-27a2d6045a40.png){: width="80%" height="80%"}{: .align-center}

### Algorithm Equality Search

- 키 값이 K인 레코드 찾기

```
Algorithm Equality Search (K, p)
  p ← root node page;
  read page p into main memory buffer;      
  while (p is not a leaf page) do
    { /* In-Memory Search */
      if K < p.K1 then p = p.P1
      else if K >= p.Km-1 then p = p.Pm
      else
        {
          search page p for entry i such that p.Ki-1 ≤ K < p.Ki
          p ← i ;
        }
      read page p into memory buffer;
    }
    search leaf page p for entry (Ki , Pri ) with K = Ki ;  
    if found, then read data page with address Pri ;
```

### Range Search

- B+ 트리는 {<, >, >=, ... } 를 사용하는 **range** 쿼리에도 유용합니다.
- 범위가 Ka ≤ K ≤ Kb인 키 값이 있는 모든 레코드를 찾으려면

1. Equality Search 알고리즘을 사용하여 키 값 Ka를 검색합니다. Ka가 있을 수 있는 리프 노드에서 키 >= Ka를 검색합니다.
2. 획득한 키 값이 ≤ Kb인 한, 오른쪽 잎 블록 포인터를 따라 후속 블록을 추적하고 키 값을 계속 검사합니다.
3. ≥ Kb 값을 찾거나 블록 체인이 끝날 때까지 2단계를 반복합니다.

<br>
<br>

## Insertion

- 새 레코드를 삽입하려면 검색 알고리즘을 사용하여 올바른 **리프** 노드 **L**을 찾습니다.
- **L**에 충분한 공간이 있으면 **L**에 삽입하십시오. 그렇지 않으면 **L을 split**하십시오. (**L**로 그리고 새로운 노드 **L'** 로)
  - 항목을 **L** 과 **L'** 에 균등하게 **분배**하여 각각이 최소 절반(50%)이 되도록 합니다.
  - 중간 키를 상위에 **복사**합니다.
- 이 분할은 상위 레벨까지 반복적으로 발생할 수 있습니다.
  - 리프가 아닌 노드를 분할하려면 항목을 균등하게 재배포하되 중간 키를 위로 **올리십시오.** (리프 노드 분할과 대조됩니다.)
- split은 tree의 높이를 증가시킵니다; 루트 노드 split은 높이를 증가시킵니다.

### No Split

- 15 삽입
  - **L** 이 가득 차있지 않기 때문에 그냥 삽입

![image](https://user-images.githubusercontent.com/55765292/140867882-7b525f06-15f0-432c-a366-3aefe9367c13.png){: width="80%" height="80%"}{: .align-center}

### Leaf Split

- 8 삽입
  - **L** 이 가득 찼습니다. 새 노드 **L'** 로 분할합니다. Distribute entries
  - 가운데 키(5)를 위로 복사합니다. (리프 노드 5개)

![image](https://user-images.githubusercontent.com/55765292/140868147-8de60e0d-7e8c-4c34-9819-2adc293a0eaf.png){: width="80%" height="80%"}{: .align-center}

### Non-Leaf(Root) Split

- 8 삽입
  - **L** 이 가득 찼습니다. 새 노드 **L'** 로 분할합니다. Distribute entries
  - 가운데 키(5)를 위로 복사합니다. (리프 노드 5개)
  - 상위(루트)가 가득 찼습니다. Split; 중간 키(17)를 위로 올립니다. (17은 남지 않음)
  - 이때 tree의 높이는 1 증가합니다.

![image](https://user-images.githubusercontent.com/55765292/140868389-ee702d62-da39-4972-b348-2d92fd355b34.png){: width="80%" height="80%"}{: .align-center}

### Copy Up vs. Push-Up

![image](https://user-images.githubusercontent.com/55765292/140868580-594238ec-d41c-4502-91af-cd7f20620bd3.png){: width="50%" height="50%"}{: .align-center}

- Copy-Up: 가운데 키 5가 복사되고 데이터 레코드를 안내하기 위해 리프 노드에 남아 있음
- Push-Up: 중간 키 19가 위로 올라와 인덱스 노드에서 안내하기 위해 '한 번'만 나타납니다

### Root Split

- Split은 리프 수준에서 시작하여 인덱스 노드가 완전히 사용되는 한 위쪽으로 계속됩니다.
- 결국 이것은 루트 노드의 split으로 이어질 수 있습니다. 이 경우 새 루트를 만들어야 합니다.
- 루트 분할이 얼마나 자주 발생할 것으로 예상하십니까? 아주 드물다.
  - 루트는 50% 미만의 점유율을 가질 수 있는 유일한 노드입니다. 이것은 tree 높이가 증가하는 유일한 상황입니다.
  - 대부분의 노드 split은 결국 특정 수준에서 중지됩니다.
  - 루트 split 후 많은 리프 노드에 여유 공간이 있을 수 있습니다.

### Properties

- 데이터 파일에 새 레코드가 삽입되면 **균형을 유지**하기 위해 B+ 트리 인덱스를 변경(기록)해야 합니다. ISAM과 달리 오버플로 페이지를 사용하지 않습니다.
- 리프 및 리프가 아닌 노드 split 모두에서 **최소 점유** 및 균형이 어떻게 **보장**되는지 확인할 수 있다
- split 유형
  - 리프 노드 분할: Copy-Up
  - 리프가 아닌(인덱스) 노드 분할: Push-Up
- 노드 split은 리프에서 루트 수준으로 전파되어 높이가 1 증가할 수 있습니다. (그러나 이것은 거의 발생하지 않음)

### Variation of Insertion

- 노드 L을 분할하기 전에 형제와 함께 노드 L의 항목을 재배포합니다.
- 재배포가 가능한지 여부를 결정하려면 형제를 검색해야 합니다. 형제에 공간이 있으면 거기에 새 키를 삽입합니다. 그렇지 않으면(두 형제가 모두 가득 찼음) 어쨌든 노드를 분할해야 합니다.
- 재배포가 가능한지 확인하면 특히 두 형제를 모두 확인하는 경우 I/O가 증가할 수 있습니다.
- 그러나 재배포가 성공하면 노드 분할을 상위 수준으로 전파할 필요가 없기 때문에 I/O가 줄어들 수 있습니다. 우리는 tree가 자라는 것을 피할 수 있습니다. 이것은 B+ 트리의 평균 점유율을 향상시킵니다.
- 삽입의 또 다른 변형은 **presplitting**입니다.

<br>
<br>

## Deletion

- 레코드를 삭제하려면 검색 알고리즘을 사용하여 올바른 **리프** 노드 L을 찾습니다.
- 키를 제거한 후 L이 절반 이상 차면 완료! 그렇지 않으면,
  - 형제(L과 부모가 같은 인접 노드)에서 차용하여 **re-distribution(재분배)**를 시도합니다.
  - 재배포에 실패하면 **L**과 그 형제를 **merge(병합)**합니다.
- 병합이 발생하면 **L**의 상위 항목(**L** 또는 형제를 가리킴)을 삭제해야 합니다
- 병합은 트리를 **축소**할 수 있습니다. 병합은 높이를 **줄임**으로써 루트로 전파될 수 있습니다.

- 삭제로 인해 리프 노드 L이 50% 미만으로 떨어진다고 가정합니다.
  - **Redistribution**: (왼쪽 또는 오른쪽) 형제 노드에 예비 항목이 있습니다.
    - 항목은 노드 L과 형제 노드 L' 사이에 재분배됩니다.
    - L을 가리키는 부모 노드의 키 값은 L'에서 가장 작은 키로 변경됩니다.
  - **Merge**: 형제 노드에 예비 항목이 없습니다.
    - 항목은 노드 L과 형제 노드 L' 사이에 병합됩니다
      - 리프 노드 병합
      - 리프가 아닌 노드 병합

### Simple Case

- 27 삭제
  - L에는 충분한 공간이 있으므로 삭제하면 됩니다

![image](https://user-images.githubusercontent.com/55765292/140870984-bea6625a-707c-43ec-a1f3-731f662051a0.png){: width="80%" height="80%"}{: .align-center}


### Redistribution

- 20 삭제
  - 20이 삭제된 후 L은 언더플로입니다. 오른쪽 형제 L'을 보세요.
  - L'에는 충분한 공간이 있습니다. L'에서 25를 빌리십시오.
  - 부모의 25는 복사된 L'의 가장 작은 키(27)에 의해 변경됩니다.

![image](https://user-images.githubusercontent.com/55765292/140871053-ab61d866-6dae-432a-8d8d-a6b185a7ea5d.png){: width="80%" height="80%"}{: .align-center}

### Merge

- 20 삭제
  - L은 언더플로입니다. 오른쪽 형제 L'을 보세요. L'에는 공간이 충분하지 않습니다.
  - L과 L' 병합 25, 29를 L'에서 L로 이동하고 노드 L'을 제거합니다.
  - 부모의 25는 더 이상 필요하지 않으므로 삭제하십시오.

![image](https://user-images.githubusercontent.com/55765292/140871193-ae44a461-dfac-44ce-b869-dc0bd1a55ed0.png){: width="80%" height="80%"}{: .align-center}

- 병합 P와 P'; 5, 14를 P로 이동하고 노드 P'를 삭제합니다.
- 상위 P는 이제 언더플로입니다. 왼쪽 형제 P'를 보십시오. P'에는 공간이 충분하지 않습니다.
- 병합 P와 P'; 부모에서 17을 아래로 당겨 부모(루트)를 제거합니다.

![image](https://user-images.githubusercontent.com/55765292/140871315-352a9341-6118-4e58-9f5d-a2c9a7e8279d.png){: width="80%" height="80%"}{: .align-center}

### Properties

- 데이터 파일에서 레코드가 삭제되면 균형을 유지하기 위해 B+ 트리 인덱스 구조를 변경(기록)해야 합니다.
- 재배포 및 병합을 사용하여 리프 노드와 인덱스 노드 모두에서 최소 점유 및 균형이 어떻게 보장되는지 관찰하십시오.
- Merge(병합) 유형
  - 리프 병합
  - 리프가 아닌(루트) 병합
- 병합은 리프에서 루트 수준으로 전파되어 높이가 1 감소합니다. (그러나 이것은 거의 발생하지 않습니다)

### 꼭 Delete를 해야하나?

- 삭제를 전혀 수정하지 않는 B+ 트리 구현이 있습니다. 리프 노드에 키가 너무 적으면 그대로 두는 것이 허용됩니다.
- 실제 DBMS 구현은 종종 병합 및/또는 재배포 비용을 피하지만 최소 점유 규칙을 완화합니다.
- 리프가 언더플로가 되는 삭제가 가끔 있을 수 있지만 대부분의 파일은 증가하고 리프는 곧 다시 최소 점유율에 도달합니다.
- 또한 동시성을 향상시키기 위해 삭제된 인덱스 항목은 삭제된 것으로 표시되고 나중에만 제거됩니다. 이를 위해서는 전체 인덱스 재구성이 필요합니다.
