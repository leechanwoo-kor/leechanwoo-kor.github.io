---
title: "[Database System] Tree Index"
categories:
  - Database System
tags:
  - Database System
  - Tree Index
toc: true
toc_sticky: true
toc_label: "Tree Index"
toc_icon: "sticky-note"
---

# Database System

## Equality/Range Search

### Equality Search

- 주어진 검색 키 K로 레코드 찾기; 루트에서 시작하여 적절한 트리 포인터를 찾으십시오.
- 그런 다음 올바른 리프 노드에 도달할 때까지 다음 레벨로 포인터를 반복해서 따라갑니다.
- K가 Kj와 같으면 데이터 포인터 Pj를 따라 값이 K인 레코드를 찾습니다.
- 키가 20인 레코드를 찾으려면 ?
![image](https://user-images.githubusercontent.com/55765292/140866239-b333a33f-7b7a-46f2-9b03-27a2d6045a40.png){: width="80%" height="80%"}{: .align-center}

### Algorithm Equality Search

- 키 값이 K인 레코드 찾기

```
Algorithm Equality Search (K, p)
  p ← root node page;
  read page p into main memory buffer;      
  while (p is not a leaf page) do
    { /* In-Memory Search */
      if K < p.K1 then p = p.P1
      else if K >= p.Km-1 then p = p.Pm
      else
        {
          search page p for entry i such that p.Ki-1 ≤ K < p.Ki
          p ← i ;
        }
      read page p into memory buffer;
    }
    search leaf page p for entry (Ki , Pri ) with K = Ki ;  
    if found, then read data page with address Pri ;
```

### Range Search

- B+ 트리는 {<, >, >=, ... } 를 사용하는 **range** 쿼리에도 유용합니다.
- 범위가 Ka ≤ K ≤ Kb인 키 값이 있는 모든 레코드를 찾으려면

1. Equality Search 알고리즘을 사용하여 키 값 Ka를 검색합니다. Ka가 있을 수 있는 리프 노드에서 키 >= Ka를 검색합니다.
2. 획득한 키 값이 ≤ Kb인 한, 오른쪽 잎 블록 포인터를 따라 후속 블록을 추적하고 키 값을 계속 검사합니다.
3. ≥ Kb 값을 찾거나 블록 체인이 끝날 때까지 2단계를 반복합니다.

<br>
<br>

## Insertion

- 새 레코드를 삽입하려면 검색 알고리즘을 사용하여 올바른 **리프** 노드 **L**을 찾습니다.
- **L**에 충분한 공간이 있으면 **L**에 삽입하십시오. 그렇지 않으면 **L을 split**하십시오. (**L**로 그리고 새로운 노드 **L'** 로)
  - 항목을 **L** 과 **L'** 에 균등하게 **분배**하여 각각이 최소 절반(50%)이 되도록 합니다.
  - 중간 키를 상위에 **복사**합니다.
- 이 분할은 상위 레벨까지 반복적으로 발생할 수 있습니다.
  - 리프가 아닌 노드를 분할하려면 항목을 균등하게 재배포하되 중간 키를 위로 **올리십시오.** (리프 노드 분할과 대조됩니다.)
- split은 tree의 높이를 증가시킵니다; 루트 노드 split은 높이를 증가시킵니다.

### No Split

- 15 삽입
  - **L** 이 가득 차있지 않기 때문에 그냥 삽입

![image](https://user-images.githubusercontent.com/55765292/140867882-7b525f06-15f0-432c-a366-3aefe9367c13.png){: width="80%" height="80%"}{: .align-center}

### Leaf Split

- 8 삽입
  - **L** 이 가득 찼습니다. 새 노드 **L'** 로 분할합니다. Distribute entries
  - 가운데 키(5)를 위로 복사합니다. (리프 노드 5개)

![image](https://user-images.githubusercontent.com/55765292/140868147-8de60e0d-7e8c-4c34-9819-2adc293a0eaf.png){: width="80%" height="80%"}{: .align-center}

### Non-Leaf(Root) Split

- 8 삽입
  - **L** 이 가득 찼습니다. 새 노드 **L'** 로 분할합니다. Distribute entries
  - 가운데 키(5)를 위로 복사합니다. (리프 노드 5개)
  - 상위(루트)가 가득 찼습니다. Split; 중간 키(17)를 위로 올립니다. (17은 남지 않음)
  - 이때 tree의 높이는 1 증가합니다.

![image](https://user-images.githubusercontent.com/55765292/140868389-ee702d62-da39-4972-b348-2d92fd355b34.png){: width="80%" height="80%"}{: .align-center}

### Copy Up vs. Push-Up

![image](https://user-images.githubusercontent.com/55765292/140868580-594238ec-d41c-4502-91af-cd7f20620bd3.png){: width="50%" height="50%"}{: .align-center}

- Copy-Up: 가운데 키 5가 복사되고 데이터 레코드를 안내하기 위해 리프 노드에 남아 있음
- Push-Up: 중간 키 19가 위로 올라와 인덱스 노드에서 안내하기 위해 '한 번'만 나타납니다

### Root Split

- Split은 리프 수준에서 시작하여 인덱스 노드가 완전히 사용되는 한 위쪽으로 계속됩니다.
- 결국 이것은 루트 노드의 split으로 이어질 수 있습니다. 이 경우 새 루트를 만들어야 합니다.
- 루트 분할이 얼마나 자주 발생할 것으로 예상하십니까? 아주 드물다.
  - 루트는 50% 미만의 점유율을 가질 수 있는 유일한 노드입니다. 이것은 tree 높이가 증가하는 유일한 상황입니다.
  - 대부분의 노드 split은 결국 특정 수준에서 중지됩니다.
  - 루트 split 후 많은 리프 노드에 여유 공간이 있을 수 있습니다.

### Properties

- 데이터 파일에 새 레코드가 삽입되면 **균형을 유지**하기 위해 B+ 트리 인덱스를 변경(기록)해야 합니다. ISAM과 달리 오버플로 페이지를 사용하지 않습니다.
- 리프 및 리프가 아닌 노드 split 모두에서 **최소 점유** 및 균형이 어떻게 **보장**되는지 확인할 수 있다
- split 유형
  - 리프 노드 분할: Copy-Up
  - 리프가 아닌(인덱스) 노드 분할: Push-Up
- 노드 split은 리프에서 루트 수준으로 전파되어 높이가 1 증가할 수 있습니다. (그러나 이것은 거의 발생하지 않음)

### Variation of Insertion

- 노드 L을 분할하기 전에 형제와 함께 노드 L의 항목을 재배포합니다.
- 재배포가 가능한지 여부를 결정하려면 형제를 검색해야 합니다. 형제에 공간이 있으면 거기에 새 키를 삽입합니다. 그렇지 않으면(두 형제가 모두 가득 찼음) 어쨌든 노드를 분할해야 합니다.
- 재배포가 가능한지 확인하면 특히 두 형제를 모두 확인하는 경우 I/O가 증가할 수 있습니다.
- 그러나 재배포가 성공하면 노드 분할을 상위 수준으로 전파할 필요가 없기 때문에 I/O가 줄어들 수 있습니다. 우리는 tree가 자라는 것을 피할 수 있습니다. 이것은 B+ 트리의 평균 점유율을 향상시킵니다.
- 삽입의 또 다른 변형은 **presplitting**입니다.
